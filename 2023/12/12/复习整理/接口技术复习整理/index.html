<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>接口技术复习整理 | WinkySpeed's Blog</title><meta name="author" content="WinkySpeed"><meta name="copyright" content="WinkySpeed"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="接口技术复习整理 引言 本课程主要用于计算机控制 计算机控制的实质是不同信号的不同处理过程，一般经过“数据采集过程”和“过程控制”2个阶段  计算机在工业生产过程的闭环控制  总线分类 地址总线AB：用来传送CPU输出的地址信号，确定被访问的存储单元、I&#x2F;O端口。地址线的根数决定了CPU的寻址范围 CPU的寻址范围 &#x3D; \(2^n\)， n：地址线根数 数据总线DB：在CPU">
<meta property="og:type" content="article">
<meta property="og:title" content="接口技术复习整理">
<meta property="og:url" content="http://example.com/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="WinkySpeed&#39;s Blog">
<meta property="og:description" content="接口技术复习整理 引言 本课程主要用于计算机控制 计算机控制的实质是不同信号的不同处理过程，一般经过“数据采集过程”和“过程控制”2个阶段  计算机在工业生产过程的闭环控制  总线分类 地址总线AB：用来传送CPU输出的地址信号，确定被访问的存储单元、I&#x2F;O端口。地址线的根数决定了CPU的寻址范围 CPU的寻址范围 &#x3D; \(2^n\)， n：地址线根数 数据总线DB：在CPU">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/WinkySpeed%20SP%20-%20Repaired.jpg">
<meta property="article:published_time" content="2023-12-12T02:56:09.000Z">
<meta property="article:modified_time" content="2023-12-25T14:02:22.761Z">
<meta property="article:author" content="WinkySpeed">
<meta property="article:tag" content="复习整理">
<meta property="article:tag" content="接口技术">
<meta property="article:tag" content="8086">
<meta property="article:tag" content="汇编语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/WinkySpeed%20SP%20-%20Repaired.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '接口技术复习整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-25 22:02:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/WinkySpeed%20SP%20-%20Repaired.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">44</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/33703665_p0.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="WinkySpeed's Blog"><span class="site-name">WinkySpeed's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">接口技术复习整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-12T02:56:09.000Z" title="发表于 2023-12-12 10:56:09">2023-12-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-25T14:02:22.761Z" title="更新于 2023-12-25 22:02:22">2023-12-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="接口技术复习整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="接口技术复习整理">接口技术复习整理</h1>
<h1 id="引言">引言</h1>
<p>本课程主要用于计算机控制</p>
<p>计算机控制的实质是不同信号的不同处理过程，一般经过“<strong>数据采集过程</strong>”和“<strong>过程控制</strong>”2个阶段</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231213162326913.png" class title="image-20231213162326913">
<h2 id="计算机在工业生产过程的闭环控制">计算机在工业生产过程的闭环控制</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231213162408785.png" class title="image-20231213162408785">
<h2 id="总线分类">总线分类</h2>
<p>地址总线AB：用来传送CPU输出的地址信号，确定被访问的存储单元、I/O端口。地址线的根数决定了CPU的寻址范围</p>
<p>CPU的寻址范围 = <span class="math inline">\(2^n\)</span>，
n：地址线根数</p>
<p>数据总线DB：在CPU与存储器、I/O接口之间数据传送的公共通路。数据总线的条数决定CPU一次最多可以传送的数据宽度</p>
<p>控制总线CB：用来传送各种控制信号</p>
<h2 id="cpu">CPU</h2>
<p>计算机的运算中心和控制中心，提供运算、判断能力</p>
<p>构成：运算器ALU、控制器CU、寄存器组</p>
<h2 id="io接口">I/O接口</h2>
<p>输入/输出接口，简写为I/O接口，是CPU与外部设备间的桥梁，外设通过I/O接口与主机连接，与CPU实现信息传送</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231213162933839.png" class title="image-20231213162933839">
<h3 id="外设通过io接口与总线连接的原因">外设通过I/O接口与总线连接的原因</h3>
<p>CPU、内存能直接连接到总线，外设需要用I/O接口</p>
<p>一般的输入/输出设备都是机械的或机电相结合的产物，它们相对于高速的中央处理器来说，速度要<strong>慢</strong>得多</p>
<p>此外，不同外设的<strong>信号形式、数据格式</strong>也各不相同</p>
<p>因此，外部设备不能与CPU直接相连，需要通过相应的电路来完成它们之间的速度匹配、信号转换，并完成某些控制功能</p>
<h2 id="微机">微机</h2>
<h3 id="微机基本概念">微机基本概念</h3>
<p><strong>微处理器</strong>即CPU,是微型机的主要核心部件，微机和其它大、中、小型计算机的根本区别：微机的CPU由运算器和控制器<strong>集成</strong>而成</p>
<p><strong>微型计算机</strong>由微处理器、接口、I/O设备通过总线连接而成</p>
<p><strong>微型计算机系统</strong>由硬件和软件构成，硬件由微处理器、接口、I/O设备通过总线连接而成；软件由系统软件和应用软件构成。硬件是基础，软件是灵魂，计算机的功能只有在硬件基础上通过软件才能发挥</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231213163340357.png" class title="image-20231213163340357">
<h3 id="微机工作过程">微机工作过程</h3>
<p>①微机上运行高级语言程序，先须经过编译、链接生成机器语言可执行程序才能直接运行</p>
<p>②机器语言程序是按照算法运算顺序由许多机器指令按一定顺序组成的程序，即程序是由多条有逻辑关系的指令组成</p>
<p>③数据和程序均以二进制代码的形式不加区别地存放在存储器中，存放位置由二进制地址指定</p>
<p>④由控制器控制整个机器语言程序和数据的存取以及程序的执行。而指令执行由运算器完成</p>
<p><br></p>
<p>为实现自动连续地执行程序，控制器设置一<strong>程序计数器PC</strong>，它可根据指令的长度自动增量（总是指向下一条指令）</p>
<p>只要给出程序中第一条指令的地址，控制器就可依据存储程序中的指令顺序周而复始地取指令、译码、执行，直到完成全部指令操作为止，即控制器通过<strong>指令流的串行驱动</strong>实现程序控制</p>
<h3 id="微机分类">微机分类</h3>
<p>按照组装形式和系统规模，可以把微型计算机划分为单片机、单板机和个人计算机</p>
<p><strong>单片机</strong>：将CPU、部分存储器、部分I/O接口集成在一个<strong>芯片</strong>上</p>
<p><strong>单板机</strong>：将CPU、存储器、I/O接口及部分I/O设备安装在一个<strong>印刷线路板</strong>上</p>
<p><strong>个人计算机PC</strong>：在主板上连接CPU、存储器、I/O接口，再配置上外设而成</p>
<h3 id="微机组成">微机组成</h3>
<p>微机<strong>原理</strong>组成：运算器、控制器、存储器、输入设备、输出设备</p>
<p>微机<strong>物理结构（实际）</strong>组成：主机（主板、CPU、内存条、硬盘、软驱、光驱、显卡、声卡、网卡等）、外设（显示器、打印机、键盘、鼠标等）</p>
<p>微机<strong>概念</strong>组成：在总线上直接挂接上CPU、内存、I/O接口，外设通过I/O接口实现与计算机连接</p>
<h3 id="微机工作原理">微机工作原理</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231213201627715.png" class title="image-20231213201627715">
<p>运算器部件是计算机中进行数据加工的部件</p>
<p>ALU运算需２个操作数，分别来自ACC和X寄存器，运算结果保存到ACC及MQ寄存器</p>
<p><br></p>
<p>控制器完成一条指令的“取指、分析、执行”</p>
<p>控制器由控制单元CU、指令部件、时序部件、PC（Program
Counter）、IR等组成</p>
<p>指令部件由指令寄存器IR、程序计数器PC、指令译码器ID组成</p>
<p>PC存放当前欲执行指令的地址，具有计数功能</p>
<p>IR存放当前欲执行的指令</p>
<p><br></p>
<p>存储器完成程序、数据、地址码的存储，具有读出和写入两种操作</p>
<p>存储器由地址寄存器MAR、数据缓冲寄存器MDR和存储阵列组成</p>
<p>MAR存放CPU要访问的内存地址，CPU对内存单元的读写都要经过MDR传送</p>
<p><br></p>
<p>I/O系统由I/O接口和I/O设备组成</p>
<p>I/O设备完成程序、数据的I/O操作</p>
<p>I/O接口是I/O设备完成程序、数据I/O操作的中转站</p>
<p>CPU通过对I/O接口<strong>状态寄存器</strong>的读取，来了解外设的工作状态</p>
<p>I/O设备通过I/O接口接受CU发出的各种控制命令完成相应的I/O操作</p>
<h1 id="系统结构">8086系统结构</h1>
<p>在传统的CPU中，采用串行工作方式，总是先从存储器中取出下一条指令，读出一个操作数，然后执行指令，即：</p>
<p>取指→执指→取指→执指→取指→执指</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214210233323.png" class title="image-20231214210233323">
<p>CPU访问存储器(存取数据或指令)时要等待总线操作的完成</p>
<p>CPU执行指令时总线处于空闲状态</p>
<p>缺点：CPU无法全速运行</p>
<p>解决：总线空闲时预取指令，使CPU需要指令时能立刻得到</p>
<p><br></p>
<p>在8086中，这些步骤被分配给两个独立的处理单元执行：</p>
<p>指令执行部件（<strong>EU</strong>）负责执行指令</p>
<p>总线接口部件（<strong>BIU</strong>）负责取指、读出操作数和写入结果</p>
<p>这两个单元可以独立工作，大多数情况下取指令执行指令重叠进行</p>
<p>即取指过程中，指令执行部件也在工作，加快系统运算速率</p>
<p>这种方式是<strong>流水线工作方式</strong></p>
<p><br></p>
<p>EU在执行指令时不需要访存取指令，只需要从指令队列取指，并分析执行</p>
<p>如果指令执行中需要访存或I/O端口，则EU向BIU发送访存的<strong>逻辑</strong>地址，BIU根据要求形成访存<strong>物理</strong>地址，然后访问存储器或I/O端口，取得操作数后送到EU参加运算，必要时再将运算结果写会存储器</p>
<p>EU实际不与外界打交道，所有与外部有关的操作都在BIU控制下完成</p>
<h2 id="cpu结构">8086CPU结构</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214191858981.png" class title="image-20231214191858981">
<p>地址总线是20位</p>
<h3 id="cpu内部结构框图">8086CPU内部结构框图</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214191946410.png" class title="image-20231214191946410">
<h3 id="总线接口部件biubus-interfaceunit">总线接口部件BIU(Bus
InterfaceUnit)</h3>
<p>提供与外部的接口</p>
<p>数据总线 ：<strong>双向</strong>三态，16位</p>
<p>地址总线 ：<strong>单向</strong>三态，20位</p>
<h4 id="biu功能">BIU功能</h4>
<p>地址形成</p>
<p>访存并取指令</p>
<p>指令排队</p>
<p>读/写操作数</p>
<p>总线控制</p>
<h4 id="biu组成">BIU组成</h4>
<h5 id="段寄存器段基址寄存器">段寄存器（段基址寄存器）</h5>
<p>段寄存器都是16位</p>
<p>CS（Code Segment）：代码段寄存器，存放程序代码段起始地址的高16位</p>
<p>DS（Data Segment）：数据段寄存器，存放数据段起始地址的高16位</p>
<p>SS（Stack Segment）：堆栈段寄存器，存放堆栈段起始地址的高16位</p>
<p>ES（Extended
Segment）：扩展段寄存器，存放扩展数据段起始地址的高16位</p>
<h5 id="指令指针寄存器">指令指针寄存器</h5>
<p>IP（Instruction
Pointer）：指令指针寄存器，存指令在代码段中的偏移量，16位</p>
<h5 id="物理地址加法器">物理地址加法器</h5>
<p><span class="math display">\[
物理地址=段基址\times16+偏移地址
\]</span></p>
<p>乘16在二进制数的表现为左移4位</p>
<p>即相当于在16位的段基址最低位后添加4个0，再与偏移地址相加，得到20位的地址</p>
<p>例如：</p>
<p>CS=2000H，IP=003AH
则物理地址<code>CS : IP</code>就为<code>CS x 16 + IP</code>，即2003AH</p>
<p>注意：2000H，003AH，2003AH都为16进制，最后的结果2003AH换算为二进制就是5x4=20位，符合20位物理地址</p>
<p><br></p>
<p>关于<code>CS : IP</code>的解释：</p>
<p>在8086微处理器中，冒号（:）用于连接段寄存器和偏移寄存器，以形成一个完整的内存地址</p>
<p>冒号前面的部分（如CS，DS，SS，ES等）是段寄存器，它存放的是基地址</p>
<p>这个基地址需要乘以16（或者说，向左移动4位），以将它转换为20位的物理地址</p>
<p>然后，将冒号后面的部分（如IP，BX，SI，DI等）加到这个物理地址上，就得到了最终的物理地址</p>
<h5 id="指令队列">指令队列</h5>
<p>存放指令，算是缓冲的作用</p>
<p>空间为6个字节</p>
<p>但不代表只能存6条指令，因为有的指令可能不止1个字节</p>
<p>这些指令队列寄存器通过总线接口单元BIU将后继要执行的指令提前由内存提前调入其内，以加快指令读取速度</p>
<p>利用指令队列寄存器可以构成指令流水线，以提高CPU工作效率</p>
<h5 id="总线控制部件">总线控制部件</h5>
<p>主要功能是产生总线控制信号，如访问存储器或者I/O端口的读写信号等</p>
<p>总线控制逻辑部件负责对CPU全部外部引脚的操作，核心功能是控制系统总线</p>
<p>当执行单元（EU）需要与I/O设备、存储器进行数据交换时，总线控制逻辑部件会协助EU完成数据交换</p>
<h4 id="biu工作过程">BIU工作过程</h4>
<p>CS和IP形成20位地址，送地址总线、送出MEM读信号、取指令到指令队列待用（6字节）</p>
<p>当EU取走指令，则自动调整指针并补充读入，如队列满，则空闲</p>
<p>如指令中需访问MEM或IO，则BIU根据EU给出的逻辑地址形成20位物理地址，由BIU负责读/写</p>
<p>IP寄存器，如CALL指令，则把当前指令的下一条指令的IP入栈，并清队列，根据新地址取6个字节待用，JMP相类似</p>
<p>总线控制部件发出总线控制信号，完成MEM或IO的读写</p>
<h3 id="指令执行部件euexecution-unit">指令执行部件EU(Execution
Unit)</h3>
<p>提供通用寄存器阵列，都为16位</p>
<p>运算器，16位</p>
<h4 id="eu功能">EU功能</h4>
<p>译码</p>
<p>执行</p>
<h4 id="eu组成">EU组成</h4>
<h5 id="算术运算逻辑部件alu">算术运算逻辑部件ALU</h5>
<h5 id="标志寄存器frflag-register">标志寄存器FR（Flag Register）</h5>
<p>标志寄存器16位</p>
<p>标志寄存器里存的信息被称为程序状态字（Program Status Word，PSW）</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214222135576.png" class title="image-20231214222135576">
<p>9个标志位</p>
<h6 id="状态标志">状态标志</h6>
<p>CF（Carry Flag）：进位标志位</p>
<p>CF=1，则本次运算最高位（<span class="math inline">\(D_{15}\)</span>或<span class="math inline">\(D_{7}\)</span>）有进位（加法运算时）或有借位（减法运算时）</p>
<p><br></p>
<p>PF（Parity Flag）：奇偶校验标志位</p>
<p>PF=1，表示本次运算结果中有偶数个“1”；PF=0表示本次运算结果中有奇数个“1”</p>
<p><br></p>
<p>AF（Auxiliary Carry Flag）：辅助进位标志位</p>
<p>AF=1，表示运算结果的8位数据中，低4位向高4位有进位（加法运算时）或有借位（减法运算时）</p>
<p>这个标志位<strong>仅在十进制数即BCD码运算</strong>中有效</p>
<p><br></p>
<p>ZF（Zero Flag）：零标志位</p>
<p>ZF=1，表示本次运算结果为0，ZF=0，运算结果非0</p>
<p><br></p>
<p>SF（Sign Flag）：符号标志位</p>
<p>SF=1，表示本次运算结果的最高位（<span class="math inline">\(D_{15}\)</span>或<span class="math inline">\(D_{7}\)</span>）为“1”，即符号数运算结果为负，否则SF=0</p>
<p><br></p>
<p>OF（Overflow Flag）：溢出标志位</p>
<p>OF=1，表示本次算术运算结果溢出</p>
<p>溢出：字节运算的结果超出了-128 ~ 127；或者字运算超出了-32768 ~
32767</p>
<p>二进制表示：</p>
<p>字节运算的范围：10000000 ~ 01111111（8位）</p>
<p>字运算的范围：1000000000000000 ~ 0111111111111111（16位）</p>
<p><br></p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231215161907482.png" class title="image-20231215161907482">
<p>例子：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231215162403301.png" class title="image-20231215162403301">
<p>可见，超过范围OF置1，最高位为1时SF置1，产生进位CF置1</p>
<h6 id="控制标志">控制标志</h6>
<p>IF（Interrupt Flag）：中断标志位</p>
<p>IF=1，表示允许CPU响应可屏蔽中断</p>
<p>IF=0，表示CPU禁止中断</p>
<p><br></p>
<p>DF（Direction Flag）：方向标志位</p>
<p>串操作指令中，DF=0表示串操作指令地址指针自动增量，即串操作的地址由低地址向高地址进行</p>
<p>DF=1表示地址指针自动减量，即串操作的地址由高地址向低地址进行</p>
<p>DF=0，从低地址到高地址搜索</p>
<p>"串操作"是一种特殊的操作，它可以对在内存中连续存在的数据进行操作。这些操作通常是组合操作，能完成几条指令的功能</p>
<p>详情见“<a href="#explanation of String">串指令</a>”</p>
<p><br></p>
<p>TF（Trap Flag）：单步标志位</p>
<p>TF=1，表示控制CPU进入单步工作方式，这种工作方式，CPU每执行完一条指令就自动产生一次内部中断，在调试程序很有用</p>
<h5 id="通用寄存器">通用寄存器</h5>
<p>通用寄存器都是16位</p>
<p>分为两组：数据寄存器和指针变址寄存器</p>
<h6 id="数据寄存器">数据寄存器</h6>
<p>通用数据寄存器既可作为16位寄存器，也可作为8位寄存器，即把16位的寄存器分成高8位和低8位</p>
<p>低8位被命名为AL, BL, CL, DL</p>
<p>高8位被命名为AH, BH ,CH, DH</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214204202684.png" class title="image-20231214204202684">
<p><br></p>
<p>AX（Accumulator
Register）：累加器，用于存放参加运算的数据和结果，在乘、除法运算、I/O操作、BCD数运算中有着不可代替的作用</p>
<p>AX的特殊用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL		BL</span><br></pre></td></tr></table></figure>
<p>8位乘法指令，功能为寄存器<code>AL x BL</code></p>
<p>其中，一个乘数一定放在AL中，另一个乘数可以放在BL中，也可以放在BH,
CL等8位寄存器中，最后的乘积一定放在AX中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL		BX</span><br></pre></td></tr></table></figure>
<p>16位乘法指令，功能为寄存器<code>AX x BX</code></p>
<p>其中，一个乘数一定放在AX中，另一个乘数可以放在BX中，也可以放在CX,
DX等16位寄存器中，乘积一定放在DXAX中，其中DX保存高16位</p>
<p><br></p>
<p>BX（Base
Register）：基址寄存器，除了作为数据寄存器，还可存放<strong>内存的逻辑偏移地址</strong>，<strong>AX,
CX,
DX不能</strong>，即<code>[BX]</code>这个用法是合法的，但是不能用<code>[AX], [CX], [DX]</code>这样的写法</p>
<p><code>[ ]</code>这个符号给出了<strong>逻辑偏移地址</strong>，可以用来算出对应的物理地址，具体解释见“<a href="#examples of []"><code>[]</code>逻辑地址</a>”</p>
<p>BX的特殊用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV		AL,	[BX]</span><br></pre></td></tr></table></figure>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214211131144.png" class title="image-20231214211131144">
<blockquote>
<p>在汇编语言中，<code>[BX]</code>表示的是一个内存地址，这个地址的偏移量存储在BX寄存器中。例如，如果BX中存放的数是40F6H，那么<code>[BX]</code>就表示的是以“DS
* 16 + 40F6H”为地址的内存单元。</p>
<p>当我们在<strong>指令中</strong>使用<code>[BX]</code>时，我们实际上是在引用BX寄存器中存储的地址指向的内存单元的内容。例如，指令<code>MOV AX, [BX]</code>的功能是将BX中存放的数据作为一个<strong>偏移地址</strong>，段地址<strong>默认在DS中</strong>，将DS:BX处的数据送入AX中。</p>
<p>这段汇编代码<code>MOV AL, [BX]</code>的含义是将内存中的数据（以BX内容为地址）传送到AL寄存器里。也就是说，执行这条指令后，AL寄存器的内容会变得与内存
<code>[BX]</code>的内容一样。</p>
</blockquote>
<p><br></p>
<p>CX（Counter
Register）：数据寄存器，既可作为数据寄存器，又可在串指令和位移指令中计数用</p>
<p>比如C语言中的<code>for(int i=100; i &gt; 0; i--)</code>，每次循环<code>i</code>都会自减，执行100次后循环结束，在8086中称为“串操作”</p>
<p>CX的特殊用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV CX, 5    ; 设置循环次数为5</span><br><span class="line">MOV AX, 2    ; 初始化AX寄存器的值为2</span><br><span class="line"></span><br><span class="line">START_LOOP:</span><br><span class="line">    ADD AX, AX    ; 将AX寄存器的值加倍</span><br><span class="line">    LOOP START_LOOP    ; 如果CX不为0，减少CX的值并跳转到START_LOOP，否则继续执行下一条指令</span><br></pre></td></tr></table></figure>
<p><code>LOOP</code>指令对CX做减1操作，并将结果返回到CX中，再判断CX的内容，若CX不为0，则回到标号处重新执行，直到CX为0为止，执行后面的语句，相当于C语言循环控制变量<code>i--</code>到<code>0</code></p>
<p>关于汇编语言中循环控制的方法：</p>
<blockquote>
<p>在汇编语言中，循环的实现方式与C语言有所不同。在C语言中，我们可以使用各种循环结构（如for，while，do
while等）并且可以自由地增加或减少循环计数器。但在汇编语言中，循环通常是通过特定的循环指令和一个循环计数器（通常是CX或ECX寄存器）来实现的。</p>
<p>例如，汇编语言中的<code>LOOP</code>指令会自动将CX寄存器的值减1，然后检查CX是否为零。如果CX不为零，程序就会跳转到指定的位置继续执行；如果CX为零，<code>LOOP</code>指令就会结束，程序会继续执行<code>LOOP</code>指令后面的代码。因此，这种循环的行为类似于C语言中的<code>i--</code>。</p>
<p>但是，汇编语言还提供了其他的循环控制指令，如<code>LOOPE/LOOPZ</code>和<code>LOOPNE/LOOPNZ</code>，这些指令除了检查CX或ECX是否为零外，还会检查零标志（ZF）。这就为汇编语言的循环提供了更多的灵活性。</p>
<p>总的来说，虽然汇编语言的循环控制方式与C语言有所不同，但它们都提供了强大的循环控制能力。</p>
</blockquote>
<p><br></p>
<p>DX （Data
Register）：数据寄存器，除了可以作为通用数据寄存器，还在乘除法、带符号数扩展指令中有特殊作用</p>
<p>DX的特殊用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN		AL		DX</span><br></pre></td></tr></table></figure>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214215836066.png" class title="image-20231214215836066">
<p>DX存的内容可以作为端口的I/O地址，如图所示，若DX存的内容为0080H，则上述指令就是从编号为0080H的I/O端口输入一个8为数据给AL，这是常见的I/O操作，用于从外部设备读取数据</p>
<p>DX内容为<strong>I/O端口地址</strong>的功能是别的寄存器所不具备的</p>
<p><br></p>
<h6 id="指针变址寄存器">指针变址寄存器</h6>
<p>数据寄存器AX, BX, CX,
DX中，只有BX可以作为地址指针，考虑到实际编程中需要大量的地址指针，只有BX指示或寻址数组中的元素是不够的，于是8086引入了指针和变址寄存器，由SI,
DI, SP, BP组成，特殊功能是存放存储器地址</p>
<p><br></p>
<p>SI（Source
Index）：源变址寄存器，用于存放内存的逻辑偏移地址，也可存放数据</p>
<p>DI（Destination
Index）：目标变址寄存器，用于存放内存的逻辑偏移地址，也可存放数据</p>
<p>SP（Stack Pointer）：堆栈指针，用于存放栈顶的逻辑偏移地址</p>
<p>BP（Base
Pointer）：基址指针，用于存放内存的逻辑偏移地址，<strong>跟SS寄存器默认搭配</strong></p>
<p><br></p>
<p>SI, DI, BP与BX的功能差不多，但SP有明显差异，主要用于指示堆栈栈顶</p>
<h5 id="eu控制器">EU控制器</h5>
<p>取指控制及时序控制</p>
<h4 id="eu的工作过程">EU的工作过程</h4>
<p>发出控制信号，从指令队列中取出指令译码，完成执行</p>
<p>算术逻辑部件ALU完成算术运算和逻辑运算，改写PSWW</p>
<p>BIU和EU可以并行工作，即流水线技术，但仅当CALL、RET及JMP等指令时，要<strong>改变执行顺序</strong>时，不能并行工作</p>
<h2 id="cpu引脚">8086CPU引脚</h2>
<p>8086CPU可以工作在最小模式和最大模式下</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231215171505623.png" class title="image-20231215171505623">
<p>由于受到当时制造工艺的限制，部分引脚采用分时复用</p>
<p>这里仅写我认为重要的，不看懂就无法理解8086工作原理的几个引脚，剩下的应该不是很重要，查手册就可以</p>
<p><br></p>
<p>AD15 - AD0（Address Data
Bus）：<strong>分时复用</strong>的地址、数据总线</p>
<p><br></p>
<p>A19/S6，A18/S5，A17/S4，A16/S3（Address/Status）：<strong>分时复用</strong>的地址、状态线</p>
<p>作为地址线用时，A19 - A16与AD15 - AD0一起构成了访存的20位地址线</p>
<p>CPU访问I/O端口时，A19 - A16保持低电平“0”</p>
<p>作为状态线用时，S6 -
S3用来输出状态信息，其中S3和S4表示当前正在使用的段寄存器名</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231215170527993.png" class title="image-20231215170527993">
<p>例如S4S3 =
10时，表示当前使用CS寄存器对存储器寻址，或当前正在对I/O端口或中断向量寻址</p>
<p>S5用来表示中断标志状态，与IF状态一致，即S5=0时禁止一切可屏蔽中断，S5=1时允许可屏蔽中断请求</p>
<p>8086工作在最小模式下时，S6恒为0</p>
<p><br></p>
<p>~BHE/S7（Bus High
Enable/Status）：总线高位有效信号（三态输出，低电平有效），表示当前高8位数据总线上的数据有效</p>
<p>低8位数据总线选通信号为AD0（偶地址）</p>
<p>~BHE/S7可以用来控制高八位的存存储器或I/O接口芯片，以区分和控制存取的是一个字节还是一个字</p>
<p>例如，在偶数地址开始的一个字节存取时，~
BHE/S7为0，AD0为1（此时高8位数据总线上进行字节传送）；在奇数地址开始的一个字节存取时，~
BHE/S7为1，AD0为0（此时低8位数据总线上进行字节传送）</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217162843395.png" class title="image-20231217162843395">
<h2 id="与8088不同之处">8086与8088不同之处</h2>
<table>
<thead>
<tr class="header">
<th></th>
<th>8086</th>
<th>8088</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>外部数据总线</td>
<td>16位</td>
<td>8位</td>
</tr>
<tr class="even">
<td>指令队列</td>
<td>6字节</td>
<td>4字节</td>
</tr>
<tr class="odd">
<td>Memory和IO空间选择</td>
<td>M/IO</td>
<td>IO/M</td>
</tr>
</tbody>
</table>
<h2 id="存储器组织">8086存储器组织</h2>
<p>8086CPU的存储器是一个最多寻址1MB的存储空间，系统为每字节分配一个20位的物理地址（对应十六进制地址范围为00000H~FFFFFH）</p>
<p>存储器中，任何两个相邻的字节被定义为一个“字”</p>
<p>在一个字中，每字节都有一个地址，这两个地址中<strong>较小的一个</strong>被用来作为这个字的地址</p>
<h3 id="线性编址">线性编址</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217155444075.png" class title="image-20231217155444075">
<p>微型计算机的内存储器以<strong>字节</strong>为基本单位存储信息，每个字节占用一个存储单元，每个存储单元给定一个唯一的地址，这个地址称为物理地址，物理地址以二进制无符号整数形式从0开始编号，顺序增1</p>
<h3 id="数据存储">数据存储</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217160333677.png" class title="image-20231217160333677">
<p>一个字的起始地址可以从偶地址开始，如图里的6B07H</p>
<p>一个字的起始地址也可以从奇地址开始，如图里的3E60H</p>
<p><strong>较高地址</strong>的字节存的是该字的<strong>高8位</strong></p>
<p><strong>较低地址</strong>的字节存的是该字的<strong>低8位</strong></p>
<p>如00001H存的是6B07H的6B，00000H存的是07；00006H存的是3E60H的3E，00005H存的是60</p>
<p><br></p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217160608122.png" class title="image-20231217160608122">
<p>偶地址开始存储的是“规则字”</p>
<p>奇地址开始存储的是“非规则字”</p>
<p>对于这两种字的解释在“<a href="#explanation of two words">8086存储器组织-分体结构</a>”中有详细解释</p>
<p><br></p>
<p><strong>总结</strong>：</p>
<p>存储器中<strong>以字节为单位</strong>存储信息</p>
<p>每个存储单元有唯一的物理地址</p>
<p>存放顺序：低字节存放在低地址；高字节存放在高地址</p>
<h3 id="分段技术">分段技术</h3>
<h4 id="存储空间的分段">存储空间的分段</h4>
<p>8086系统把1MB的内存空间（地址线是20根，寻址空间为<span class="math inline">\(2^{20}=1MB\)</span>）分为若干个段，要求：</p>
<p>①每段的容量<strong>不超过64KB</strong>（寄存器只有16根数据线，可寻址<span class="math inline">\(2^{16}=64KB\)</span>）</p>
<p>②段内起始地址必须能被16整除</p>
<p>各段的功能因具体用途而定，可分为代码段、数据段、堆栈段、附加段（对应BIU内的CS,
DS, SS, ES段寄存器）</p>
<p>段内起始单元地址的高16位（<strong>低4位为0</strong>）称为段基址，段内某单元距首单元的位移量称为偏移地址/有效地址</p>
<p>例子：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217161201592.png" class title="image-20231217161201592">
<p>1234H作为段基址，则段内起始单元地址为“12340H”，多出来的低4位0可以保证段内起始单元地址能被16整除：
<span class="math display">\[
12340H = 0\times16^0+4\times16^1+3\times16^2+2\times16^3+1\times16^4
\]</span> 分段技术可以使每个存储单元都可以用两种地址表示：</p>
<p><strong>物理地址</strong>是内存中信息存储的实际地址</p>
<p><strong>逻辑地址</strong>（段基址 <code>:</code>
偏移地址）是允许在程序中编排的地址</p>
<p>CPU必须按照物理地址对对内存进行寻址，访存时首先把逻辑地址转换为物理地址，然后再对内存单元进行读/写</p>
<p><br></p>
<p>将段基址与偏移地址放入BIU的物理地址加法器就可以计算出实际物理地址</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217161803751.png" class title="image-20231217161803751">
<p><br></p>
<p>如每个段都是64K，则最多可分16个段：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217164130441.png" class title="image-20231217164130441">
<p><span class="math display">\[
1MB=2^{20}=2^{16}\times2^{4}=64KB\times16个
\]</span></p>
<p>段与段可以交差甚至重叠：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217164150131.png" class title="image-20231217164150131">
<h4 id="物理地址的形成">物理地址的形成</h4>
<p>BIU里有4个段寄存器：CS, DS, SS, ES</p>
<p>逻辑地址由段寄存器和段内偏移量寄存器组成 <span class="math display">\[
\begin{align*}
物理地址&amp;=段基址\times16+偏移地址\\
&amp;=段寄存器的值\times16+段内偏移量寄存器的值
\end{align*}
\]</span> <img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217164859557.png" class title="image-20231217164859557"></p>
<h4 id="逻辑地址的来源段寄存器与段内指针寄存器搭配使用">逻辑地址的来源（段寄存器与段内指针寄存器搭配使用）</h4>
<p><code>CS : IP</code>指向代码段（当前执行的代码的地址）</p>
<p><code>SS : SP</code>指向堆栈段（SS指向堆栈段首地址，SP指向堆栈段栈顶）</p>
<p><code>SS : BP</code>，因为后面“基址/变址寻址”用到了这个知识点，就补充在这里：BP默认是和SS搭配</p>
<p><code>DS : BX(SI, DI)</code>指向数据段（指向数据段中的特定位置）</p>
<p><code>ES : DI</code>（串操作）指向附加段</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217165722841.png" class title="image-20231217165722841">
<h3 id="分体结构">分体结构</h3>
<p>在8086系统中，存储器采用分体结构，即1MB的存储空间分为两个512KB的存储体，一个存储体中包含偶数地址，另一个存储体包含奇数地址</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217170434989.png" class title="image-20231217170434989">
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217162843395.png" class title="image-20231217162843395">
<p>可见，数据总线的高8位连接偶地址存储器，低8位连接奇地址存储器</p>
<p>地址线仅用到A19 - A1，原因是A0用于区分当前访问的是哪个存储体</p>
<p><br></p>
<p><a id="explanation of two words"></a></p>
<p>8086的有些指令是访问（读或写）字节的，有些指令是访问（读或写）字的</p>
<p>在同一时间，8086存储器中取出来的信息数量<strong>总是16位</strong>的，而且该16位数据是在存储器中以<strong>偶地址开头</strong>2字节的内容</p>
<p>当8086要访问字节时，在被读出的16位数据中，只要忽略高8位或者低8位就可以得到所需要的1字节信息，如下图(a)(b)所示：</p>
<p>当8086要访问1个字，而这个字是偶地址起始的，只需要使A0=0,
~BHE=0，就可以一次性访问到该字的内容，如下图(c)所示：</p>
<p>当8086要访问1个字，而这个字是奇地址起始的，情况就很复杂，必须对两个连续的偶地址字做<strong>两次</strong>存储器访问，每次访问<strong>忽略不要的1字节</strong>，保留剩余的1字节，然后变换得到一个完整的字信息，如下图(d)所示：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217203850572.png" class title="image-20231217203850572">
<p>8086编程并不涉及这些细节，一条指令只是访问一个特定的字节或字，细节操作是在处理器的控制下自动实现的</p>
<p>综上，在字访问的情况下，对奇地址存放的字需要进行两次读/写操作，对偶地址存放的字仅需一次读/写操作</p>
<p>为了加快程序的运行速度，希望被访问的存储器的字地址为偶地址，所以偶地址起始的字称为“对准字”或“规则字”，奇地址起始的字称为“非对准字”或“非规则字”</p>
<h4 id="相邻两个单元字的读写">相邻两个单元（字）的读写</h4>
<h5 id="偶地址为低字节的字的读写">偶地址为低字节的字的读写</h5>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217211531747.png" class title="image-20231217211531747">
<p>奇偶存储体都是低电平有效</p>
<p>A0=0, ~BHE=0使得奇偶存储体都有效，再根据A19 - A1获取相应地址</p>
<p>这样数据总线可以一次从奇偶两个存储体读/写16位数据，即一次访存读/写一整个字</p>
<h5 id="奇地址为低字节的字的读写">奇地址为低字节的字的读写</h5>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217212242001.png" class title="image-20231217212242001">
<p>可见奇地址为低字节的两个连续字节形成的字，物理地址最后几位不像偶地址低字节一样仅差一位，奇地址低字节物理地址后三位有差别，所以不能在一次访存中获取这两个字节</p>
<p>于是就需要两次访存，第一次拿出8位的奇字节，第二次拿出8位的偶字节，这样才能拼出完整的字</p>
<p>一次访存是操作16位的数据，所以每次都会舍弃8位不需要的数据</p>
<h4 id="堆栈">堆栈</h4>
<p>SS指向堆栈段首地址</p>
<p>SP指向当前栈顶</p>
<p>8086的堆栈是“向下增长”的，具体来说，栈的空间是从<code>SS : SP</code>指向的地址开始，向低地址方向延伸</p>
<p>举个例子：假设栈初始化为这样：SS=1000H，SP=0100H</p>
<p>假设这个时候栈为空，什么都没存，则说明这个堆栈段最大就只能存0100H个字节，即从<code>SS : SP</code>开始延伸，最大延伸到<code>SS : 0000H</code></p>
<p>在8086中，<code>PUSH</code>和<code>POP</code>指令都是对16位寄存器或存储器两单元的操作数来操作的，但是内存空间（包括栈空间）是以字节（8位）为单位进行存储的，所以无论进栈或出栈，都要使用栈空间的<strong>两个字节</strong>；同时也要注意高地址放高字节，低地址放低字节</p>
<p>此时对栈进行压栈操作，SP的值会减少2个字节，即<code>0100H - 2H = 00FEH</code></p>
<p>同理，出栈操作，SP的值会增加2个字节，即<code>00FEH + 2H = 0100H</code></p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217225714156.png" class title="image-20231217225714156">
<p>工作过程图解：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219110742329.png" class title="image-20231219110742329">
<h2 id="作业">作业</h2>
<p>在某系统中，已知当前（SS）=2360H，（SP）=0800H，请说明该堆栈段在存储器中的物理地址范围。若往堆栈中存放20字节数据，那么SP的内容为什么值？</p>
<p><strong>答</strong>：（SS）&lt;&lt;
4＋（SP）＝23600H＋0800H＝23E00H（见图2-10），堆栈段在存储器中的物理地址范围是23600H～23E00H。若往堆栈中存入20个字节数据，那么SP的内容为0800H－14H＝07ECH。（20的十六进制为14H）</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231223194725025.png" class title="image-20231223194725025">
<p><br></p>
<p>已知当前数据段位于存储器的B4000H~C3FFFH范围内，则DS段寄存器的内容为多少？</p>
<p><strong>答</strong>：段寄存器DS的内容为B400H</p>
<p><br></p>
<p>若已知当前（DS）=7F06H，在偏移地址为0075H开始的存储器中连续存放6字节的数据，分别为11H、22H、33H、44H、55H和66H。请指出这些数据在存储器中的物理地址。如果要从存储器中读出这些数据，需要访问几次存储器？各读出哪些数据？</p>
<p><strong>答</strong>：物理地址：7F06H&lt;&lt;4＋0075H＝7F0D5H（见图2-10），故从7F0D5H起６个地址数据在存储器中的地址为：</p>
<p>7F0D5H：11H</p>
<p>7F0D6H：22H</p>
<p>7F0D7H：33H</p>
<p>7F0D8H：44H</p>
<p>7F0D9H：55H</p>
<p>7F0DAH：66H</p>
<p>由于是从奇地址（7F0D5H）开始存放，至少需要4次读存储器操作，分别是：读出11H，3322H，5544H和66H。（注意：数据的低位在低地址存储，数据的高位在高地址存储。）</p>
<p>具体过程参考“<a href="#explanation of two words">8086存储器组织-分体结构</a>”里面“访问一个字”的说明</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231223194827690.png" class title="image-20231223194827690">
<h1 id="指令系统">8086指令系统</h1>
<h2 id="指令的特点">8086指令的特点</h2>
<h3 id="灵活的指令格式">1.灵活的指令格式</h3>
<p>指令由<strong>操作码</strong>和<strong>操作数</strong>组成</p>
<p>操作码一般有1~2字节</p>
<p>操作数：参加操作的数或者数<strong>所在位置（地址码）</strong></p>
<p>操作数部分一般有0~4字节</p>
<h3 id="指令格式的一对多形式">2.指令格式的一对多形式</h3>
<p>例如JE/JZ 都表示ZF=1时转移</p>
<h3 id="较强的运算指令">3.较强的运算指令</h3>
<p>有专用的乘法、除法指令</p>
<h3 id="指令有极强的寻址能力">4.指令有极强的寻址能力</h3>
<p>寻址方式有多种</p>
<h3 id="指令有处理多种数据的能力">5.指令有处理多种数据的能力</h3>
<p>处理8位/16位、带符号数/无符号数以及压缩BCD数/非压缩BCD数</p>
<h2 id="指令寻址方式">8086指令寻址方式</h2>
<p>“寻址方式”是<strong>指令寻找操作数</strong>的方法</p>
<p>8086CPU指令中的操作数有一个或两个，个别还有三个</p>
<p>操作数分为分为<strong>源操作数</strong>和<strong>目的操作数</strong></p>
<p>比如数据传输指令：<code>MOV  目的操作数, 源操作数</code></p>
<p>目的操作数不允许立即寻址（立即数）</p>
<h3 id="寻址方式">寻址方式</h3>
<p>总共八种寻址方式：</p>
<p>立即寻址</p>
<p>寄存器寻址</p>
<p>直接寻址</p>
<p>寄存器间接寻址</p>
<p>基址/变址寻址</p>
<p>基址+变址寻址</p>
<p>串寻址</p>
<p>I/O端口寻址</p>
<h4 id="立即寻址">立即寻址</h4>
<p>立即寻址，<strong>操作数就在指令中</strong>，紧跟着操作码后面，作为指令的一部分存放在内存的代码中，这种操作数被称为“立即数”</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV    AX, 34EAH</span><br><span class="line">MOV    BL, 20</span><br></pre></td></tr></table></figure>
<p>第一句是把16位的十六进制源操作数34EAH存入AX中</p>
<p>第二句是把8位的十进制数20存入BL中（具体几位得看对应的寄存器位数）</p>
<p>注意区分进制，二进制会在末尾写B，八进制会在末尾写O，十六进制会在末尾写H</p>
<p>十进制一般末尾就没有字母</p>
<h4 id="寄存器寻址">寄存器寻址</h4>
<p>如果<strong>操作数在寄存器中</strong>，指令中源操作数和目的操作数就可以用寄存器寻址</p>
<p>16位的操作数，寄存器可以是AX, BX, CX, DX, SI, DI, SP,
BP这些16位的通用寄存器</p>
<p>8位的操作数，寄存器可以是AL, BL, CL, DL, AH, BH, CH,
DH这些8位的通用寄存器</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV     BP,	SP</span><br></pre></td></tr></table></figure>
<p>这一句会把寄存器SP的值存入寄存器BP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV   	AX,	1234H</span><br><span class="line">MOV  	AL,	AH</span><br></pre></td></tr></table></figure>
<p>这两句会把16位的1234H存入AX，再把高8位AH的内容存入低八位AL</p>
<p>也就是说最后AX的内容是1212H</p>
<h4 id="直接寻址">直接寻址</h4>
<p><a id="examples of []"></a></p>
<p>当<strong>操作数在内存单元里</strong>时，在指令中必须给出被访问内存单元的逻辑地址，再被8086转化为物理地址，才能对选中的内存单元读或写</p>
<p>指令中的源操作数或目的操作数采用“<strong>直接给出被访问内存单元的逻辑地址</strong>”这种方式时，被称为“直接寻址”</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV   AX, [3E4CH]</span><br></pre></td></tr></table></figure>
<p>源操作数采用直接寻址方式，指令中用“<code>[ ]</code>”内给出来的内容是被访问内存单元的<strong>逻辑偏移地址</strong>，逻辑段地址隐含在DS寄存器内</p>
<p>也就是说，这段指令实现的功能是：取出物理地址为“DS * 10H +
3E4CH”内存单元里的数据，存入AX寄存器中</p>
<p>又比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV  [1234H], BL</span><br></pre></td></tr></table></figure>
<p>目的操作数采用直接寻址方式</p>
<p>将寄存器BL里的8位数据传递到逻辑地址1234H，物理地址为“DS * 10H
+1234H”的内存单元中</p>
<p>又比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV  ES:[1234H], BL</span><br></pre></td></tr></table></figure>
<p>给出了ES寄存器，所以目的操作数的物理地址就是“ES * 10H +1234H”</p>
<p>指定一个非默认的段，这种方式叫“<strong>段超越</strong>”</p>
<p><br></p>
<p>以上例子中，指令的直接地址是用十六进制数形式给出的，但实际编程中，一般用符号地址，即实现定义好的符号表示逻辑偏移地址（相当于一个存了逻辑偏移地址的变量）</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		AX, BUFF</span><br><span class="line">MOV		ES:BUFF, BL</span><br></pre></td></tr></table></figure>
<p>功能和上面一样，只是偏移地址用了<code>BUFF</code>这个变量表示</p>
<p><br></p>
<p>默认关系：CS:IP、SS:SP、DS:BX、DS:SI、DS:DI、DS和直接偏移</p>
<h4 id="寄存器间接寻址">寄存器间接寻址</h4>
<p>当<strong>操作数在内存单元里</strong>时，可以使用这种方式</p>
<p>与直接寻址不同的是：内存单元的逻辑偏移地址通过间接的方式给出，即先将被访问内存单元的逻辑偏移地址<strong>传送给寄存器</strong>，在指令中再由<strong>寄存器给出被访问的内存单元的逻辑偏移地址</strong></p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV   SI, 61A8H</span><br><span class="line">MOV   DX, [SI]</span><br></pre></td></tr></table></figure>
<p>先把61A8H这个16位数给SI寄存器</p>
<p>再用<code>[]</code>给出逻辑偏移地址，即把SI寄存器里存的61A8H当做偏移地址</p>
<p>也就是说，这段指令的作用是把物理地址“DS * 16 +
61A8H”的内容送入DX寄存器中</p>
<p>注：AX、CX、DX不能在寄存器间接寻址中使用，也就是说不能用<code>[AX], [CX], [DX]</code>这样的写法</p>
<h4 id="基址变址寻址">基址/变址寻址</h4>
<p>方便<strong>一维表格数据</strong></p>
<p>基址/变址方式提出了“<strong>位移量</strong>”的概念，即在寄存器间接寻址给出的地址信息上再加一个相对位移量，也称为“<strong>相对寻址</strong>”</p>
<p>位移量是一个带符号的16位十六进制数</p>
<p>当使用寄存器BX或BP(Base
Pointer，基址指针，通常与SS搭配)时，称为“<strong>基址寻址</strong>”</p>
<p>当使用寄存器SI或DI时，称为“<strong>变址寻址</strong>”</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV   CX, 36H[BX]		;基址寻址</span><br></pre></td></tr></table></figure>
<p>这一句也可以写成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV   CX, [BX+36H]		;基址寻址</span><br></pre></td></tr></table></figure>
<p>所以，源操作数对应的物理地址为“DS * 10H + BX + 36H”</p>
<p>又比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV   -20[BP], AL		;基址寻址</span><br></pre></td></tr></table></figure>
<p>注意：<code>BP</code>寄存器默认和<strong>SS</strong>寄存器搭配，并且给的是20，是十进制</p>
<p>所以这里的物理地址计算为：“SS * 10H + BP - 14H”</p>
<h4 id="基址变址寻址-1">基址+变址寻址</h4>
<p>可以使用<strong>段超越</strong>，适用于<strong>二维表</strong></p>
<p>有效地址由三部分组成：“基址寄存器BX” 或 “BP”的内容 +
变址寄存器SI或DI的内容 + 位移量</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV   AX,	8AH[BX][SI]  </span><br><span class="line">MOV   AX,	[BX+SI+8AH]    </span><br></pre></td></tr></table></figure>
<p>以上两句等价</p>
<p>物理地址为：“DS * 10H + BX + SI + 8AH”</p>
<h4 id="串寻址">串寻址</h4>
<p>串寻址仅在8086串指令中用</p>
<p>串指令的操作数由其他指令提供，且操作数在内存单元中</p>
<p>源操作数逻辑地址DS : SI，目的操作数的逻辑地址ES : DI</p>
<p>由DF（方向标志），自动调整SI和DI</p>
<h4 id="io端口寻址">I/O端口寻址</h4>
<p>当操作数在外部设备时使用I/O指令</p>
<p>外部设备的地址叫做<strong>端口地址</strong></p>
<p>当外部设备地址用<strong>8位</strong>寻址时，<strong>直接端口寻址</strong>方式，这种寻址方式I/O地址仅有256个（00H
- FFH，高8位全为0）</p>
<p>当外部设备地址用<strong>16位</strong>寻址时，<strong>寄存器（DX）间接寻址</strong>方式</p>
<p><br></p>
<p>由于外部设备的数据宽度不同，输入指令中目的操作数可以为AL（8位）或AX（16位），输出指令同理</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN    AL, 25H</span><br></pre></td></tr></table></figure>
<p>将端口地址为25H的输入设备中8位数据送到AL中</p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		DX, 3E4H</span><br><span class="line">OUT  	DX, AL</span><br></pre></td></tr></table></figure>
<p>先把03E4H写进DX（用作间接寻址寄存器），再把AL寄存器的内容输出到端口地址为3E4H的外设</p>
<h2 id="指令格式">8086指令格式</h2>
<p>单操作数指令</p>
<p>双操作数指令</p>
<p>三操作数指令（其中一个操作数隐藏在操作码中）</p>
<p>三操作数指令如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC		AX, BX</span><br></pre></td></tr></table></figure>
<p>该指令完成操作数AX, BX和CF位（进位Flag，被隐藏）相加</p>
<p>又比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDS		SI, [BX]</span><br></pre></td></tr></table></figure>
<p>源操作数<code>DS:[BX]</code>组成的物理地址的连续4个字节分别存入SI和DS（被隐藏）中</p>
<h2 id="数据类型">8086数据类型</h2>
<p>(1)无符号数：8位和16位</p>
<p>(2)带符号数：8位和16位</p>
<p>(3)ASCII：在程序中用单引号括起来</p>
<p>(4)BCD数：压缩BCD和非压缩BCD</p>
<p>压缩BCD码：一个字节表示<strong>两位</strong>十进制数，如56的压缩BCD就是<code>0101_0110B</code></p>
<p>非压缩BCD码：一个字节表示<strong>一位</strong>十进制数，其中高4位为0，低4位存放个位，比如5的非压缩BCD就是<code>0000_0101B</code></p>
<h2 id="指令集">8086指令集</h2>
<p>按功能分为六种：数据传输类、算术运算类、逻辑运算类（位操作）、串操作类、程序控制类（CS：IP）、处理机控制类</p>
<h3 id="数据传输指令">数据传输指令</h3>
<p>数据传输指令实现存储器和寄存器、寄存器和寄存器、AX或AL寄存器与I/O端口之间的字节型或字型数据的传输</p>
<h4 id="数据传输指令共同特点">数据传输指令共同特点</h4>
<p>除了<code>POPF</code>和<code>SAHF</code>指令，这类指令的操作结果<strong>不会影响FR寄存器中的标志</strong></p>
<p>指令中有两个操作数，目的操作数和源操作数，执行过程为：源操作数→目的操作数；当指令中仅存在一个操作数时，另一个操作数为隐含</p>
<h4 id="通用数据传输指令">通用数据传输指令</h4>
<p>8086有4个通用数据传输指令：<code>MOV, PUSH, POP, XCHG</code>，除了<code>XCHG</code>，都可以以段寄存器为操作数，这是其他类型指令无法实现的</p>
<h5 id="传送指令mov">传送指令<code>MOV</code></h5>
<p>指令格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV		目的操作数,	源操作数</span><br></pre></td></tr></table></figure>
<p><code>MOV</code>指令有三种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV		Register, oprd		;以寄存器r为目的操作数</span><br><span class="line"></span><br><span class="line">MOV		mem, oprd			;以存储器mem为目的操作数</span><br><span class="line"></span><br><span class="line">MOV		seg, oprd			;以段寄存器seg为目的操作数</span><br></pre></td></tr></table></figure>
<p>具体过程如下图：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231224092706350.png" class title="image-20231224092706350">
<p>以寄存器r为目的操作数时，源操作数可以是：寄存器r、存储器mem、段寄存器seg、立即数im（通用寄存器可以从通用寄存器里拿数据）</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV 	CL, AH			;源操作数为寄存器r</span><br><span class="line">MOV 	AL, 12H			;源操作数为立即数im</span><br><span class="line">MOV 	AX, [BX+1]		;源操作数为存储器mem</span><br><span class="line">MOV 	BX, DS			;源操作数为段寄存器seg</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>以存储器mem为目的操作数时，源操作数可以是：寄存器r、段寄存器seg、立即数im（<strong>没有mem</strong>，图上mem不能指向自己，也就是说存储器mem不能从mem拿数据）</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV		[BX], 1234H			;源操作数为立即数im</span><br><span class="line">MOV 	[SI+5], BL			;源操作数为寄存器r</span><br><span class="line">MOV 	[BX+SI+10], DS		;源操作数为段寄存器seg</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>以段寄存器seg为目的操作数时，源操作数可以是：寄存器r、存储器mem（<strong>没有立即数im和段寄存器seg</strong>）</p>
<p>这里的seg<strong>不包括代码段段寄存器CS</strong></p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV DS, AX		;源操作数为寄存器r</span><br><span class="line">MOV ES, [SI+5]	;源操作数为存储器mem</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>编程时尽量采用寄存器变量</p>
<p><br></p>
<h6 id="mov指令需要注意"><code>MOV</code>指令需要注意</h6>
<p>寄存器<strong>不包括IP</strong></p>
<p>目的操作数<strong>不允许使用段寄存器CS</strong>（指令涉及CS时要小心，执行这条语句后会改变CS的值，使一个新的段成为代码段，但此时IP的值还是没变，所以在改变CS的同时也应该改变IP的值）</p>
<p>目的操作数<strong>不能是立即数</strong>（只有变量才能被赋值）</p>
<p>立即数<strong>不能直接送到段寄存器</strong>，如果需要，就通过其他寄存器传送</p>
<p>源操作数和目的操作数的数据类型<strong>必须相同</strong>：比如指令<code>MOV    AL, BX</code>就是错误的，BX是16位，AL只有8位；又比如，指令<code>MOV   [BX], 12H</code>也是错误的，因为立即数<code>12H</code>可能是8位，也可能是16位，在<code>MOV   [BX], 12H</code>时没有进行说明（用<code>byte ptr</code>或<code>word ptr</code>）</p>
<p>不允许在两个存储单元中直接传送数据，如果需要，就要通过寄存器传输</p>
<p>源操作数和目的操作数不可同时为段寄存器</p>
<p><br></p>
<p>为了说明数据是8位的，可用下面的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		[BX],	byte ptr 12H</span><br><span class="line">MOV		byte ptr [BX],	12H</span><br></pre></td></tr></table></figure>
<p><code>byte ptr</code>说明后面的对象是8位操作数</p>
<p><br></p>
<p>为了说明数据是16位的，可用下面的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		[BX],	word ptr 12H</span><br><span class="line">MOV		word ptr [BX],	12H</span><br></pre></td></tr></table></figure>
<p><code>word ptr</code>说明后面的对象是16位操作数，此时<code>word ptr 12H</code>就是<code>0012H</code></p>
<h5 id="入栈指令push">入栈指令<code>PUSH</code></h5>
<p>指令格式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH	oprd</span><br></pre></td></tr></table></figure>
<p>堆栈操作总是对<strong>16位数据</strong>进行，指令中目的操作数隐含为堆栈</p>
<p>进栈操作把数据传输到以SS为段基址、SP为偏移地址的栈中，具体过程如下：</p>
<ol type="1">
<li><p>SP先减2，指向新的栈顶</p></li>
<li><p>oprd存入<code>SS : SP</code>指向的栈顶，完成进栈操作</p></li>
</ol>
<p><code>PUSH</code>的源操作数oprd，可以是<strong>除了立即数以外的变量</strong>，即通用寄存器r，存储器mem，段寄存器seg</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH	BX</span><br><span class="line">PUSH 	[BX]</span><br><span class="line">PUSH 	DS   </span><br></pre></td></tr></table></figure>
<h5 id="出栈指令pop">出栈指令<code>POP</code></h5>
<p>指令格式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POP		oprd</span><br></pre></td></tr></table></figure>
<p>目的操作数隐含为堆栈</p>
<p>出栈操作把以SS为段基址、SP为偏移地址的栈顶内容传输到目的操作数中，具体过程如下：</p>
<ol type="1">
<li><p>将<code>SS : SP</code>指示的栈顶2字节内容传输到目的操作数中</p></li>
<li><p>SP加2，指向新栈顶，完成出栈</p></li>
</ol>
<p><code>POP</code>的源操作数oprd，可以是<strong>除了立即数以外的变量</strong>，即通用寄存器r，存储器mem，段寄存器seg（也不能是CS）</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POP		AX</span><br><span class="line">POP		[BX+SI+100H]</span><br><span class="line">POP		ES   </span><br></pre></td></tr></table></figure>
<h5 id="交换指令xchg">交换指令<code>XCHG</code></h5>
<p>XCHG（Exchange）</p>
<p>指令格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XCHG	r, oprd</span><br></pre></td></tr></table></figure>
<p>完成目的操作数和源操作数的内容互换</p>
<p>上述指令执行时数据交换，属于变量赋值所以oprd可以是通用寄存器r，存储器mem，操作数不能是立即数</p>
<p>源操作数和目的操作数不能同时为mem</p>
<p>段寄存器seg不能作为操作数</p>
<p><br></p>
<p>如果需要将字型数据偏移地址为2040H单元和2050单元的内容交换：</p>
<p>方案一：<code>MOV</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, [2040H]   </span><br><span class="line">MOV	BX,	[2050H]</span><br><span class="line">MOV [2050H], AX</span><br><span class="line">MOV [2040H], BX</span><br></pre></td></tr></table></figure>
<p>方案二：<code>XCHG</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, [2040H]   </span><br><span class="line">XCHG AX, [2050H]</span><br><span class="line">MOV [2040H], AX</span><br></pre></td></tr></table></figure>
<p>方案三：<code>PUSH, POP</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUSH [2040H]</span><br><span class="line">PUSH [2050H]</span><br><span class="line">POP  [2040H]</span><br><span class="line">POP  [2050H]</span><br></pre></td></tr></table></figure>
<h4 id="累加器专用传输指令">累加器专用传输指令</h4>
<p>8086与外部设备交换数据，必须通过累加器AX或AL传输给I/O端口，外设从输出端口取数据，完成数据输出</p>
<p>反之，则外设需要将数据传到I/O端口，CPU从端口中取数据到AX,
AL中，完成数据输入</p>
<h5 id="输入指令in">输入指令<code>IN</code></h5>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN	a, oprd</span><br></pre></td></tr></table></figure>
<p><code>IN</code>指令把oprd指示的端口内容传输到累加器a</p>
<p>目的操作数为累加器a，代表16位的AX和8位的AL，源操作数是I/O端口地址</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IN  AL, 80H      ;0080H作为地址，不需要加[]表示地址</span><br><span class="line">IN  AL, DX</span><br><span class="line">IN  AX, 80H</span><br><span class="line">IN  AX, DX</span><br></pre></td></tr></table></figure>
<p>注意：在<code>MOV</code>指令中，表示地址的一般都用<code>[ ]</code>表示逻辑地址，比如<code>[0080H]</code>，因为在<code>MOV</code>指令中的<code>0080H</code>作为立即数，所以需要加<code>[ ]</code>表明是地址；而<code>IN</code>指令中，源操作数已经被指定为地址，所以就不需要加<code>[ ]</code>强调地址了</p>
<p>即：<code>IN  AL, 80H</code>这句表示的是从端口地址为<code>80H</code>的接口输入数据给AL，采用直接寻址</p>
<p>端口地址若是超过8位，应使用DX间接寻址</p>
<h5 id="输出指令out">输出指令<code>OUT</code></h5>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OUT		oprd, a</span><br></pre></td></tr></table></figure>
<p><code>OUT</code>指令把累加器a的内容传送到oprd指定的端口，目的操作数是I/O端口地址</p>
<p>输出设备的端口地址若是<strong>超过8位，应使用DX间接寻址</strong></p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OUT		3EBH, AX	;错的</span><br></pre></td></tr></table></figure>
<p>这里端口地址为3EBH，超过8位，应该换DX间接寻址</p>
<p>修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		DX,	3E8H</span><br><span class="line">OUT		DX,	AX</span><br></pre></td></tr></table></figure>
<h5 id="换码指令xlat">换码指令<code>XLAT</code></h5>
<p>XLAT（Translate）</p>
<p>指令格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XLAT</span><br></pre></td></tr></table></figure>
<p>这个指令没有明显的操作数，因此是隐含寻址，涉及的寄存器有AL和BX</p>
<p>其功能为：以BX的内容加AL的内容构成数据段中的一个地址（<code>[BX + AL]</code>），然后从这个地址中取数给AL</p>
<p>所谓“换码”，是指令能够完成1字节的查表转换</p>
<p>有时需要将一种代码换成另一种代码，或在实际问题中采用映射关系来实现转换</p>
<p><br></p>
<p>因为涉及到BX和AL两个寄存器，所以这条指令执行前，需要改变BX,
AL两个寄存器的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		BX,	表的偏移首地址</span><br><span class="line">MOV		AL,	被转换码</span><br></pre></td></tr></table></figure>
<p><code>XLAT</code>指令不能单独执行，所以有时被称为“复合指令”</p>
<p><br></p>
<p>例如：建立一个0~9的平方表，求5的平方值</p>
<p>将0~9的平方表建立在偏移地址为2000H的内存中</p>
<p>完成求5的平方指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV		BX,	2000H	;指向平方表首地址</span><br><span class="line">MOV		AL,	5		;把5放入AL</span><br><span class="line">XLAT				;执行换码指令，先求BX + AL得到5平方对应的地址，再把这个地址存的数据放入AL</span><br></pre></td></tr></table></figure>
<p>这个例子仅仅为<code>XLAT</code>指令设计</p>
<h4 id="目标地址传输指令">目标地址传输指令</h4>
<p>目标地址传输指令是计算有效地址的指令，有效地址是指存储器地址</p>
<p>因此在这类指令中，源操作数必须是存储器</p>
<h5 id="lea有效地址传输到寄存器"><code>LEA</code>（有效地址传输到寄存器）</h5>
<p>LEA（Load Effective Address）</p>
<p>指令格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEA		r,	mem</span><br></pre></td></tr></table></figure>
<p>指令的功能是：取mem指示的地址（这里就是偏移地址）送寄存器r</p>
<p>注意：r是16位</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEA		SI, [2040H]</span><br></pre></td></tr></table></figure>
<p>指令执行后，SI的内容为2040H，也就是取了这个偏移地址，存到SI寄存器中</p>
<p>对比：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV		SI, [2040H]</span><br></pre></td></tr></table></figure>
<p><code>MOV</code>指令执行后，SI内容为偏移地址2040H内存单元存的内容，而不2040H这个值</p>
<p><br></p>
<p>也就是说，<code>LEA</code>这个指令用于取mem的偏移地址，然后存入r中</p>
<h5 id="lds装入一个新的物理地址"><code>LDS</code>（装入一个新的物理地址）</h5>
<p>LDS（Load DS）</p>
<p>指令格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDS		r,	mem</span><br></pre></td></tr></table></figure>
<p><code>LDS</code>指令是三操作数指令，其中有两个目的操作数</p>
<p>功能是：将源操作数指示的偏移地址开始的<strong>4个连续字节</strong>的内容传输到<strong>目的寄存器r</strong>和<strong>数据段寄存器DS</strong>中</p>
<p>r是16位</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV  BX, 2080H     ;用BX间接寻址</span><br><span class="line">LDS  SI, [BX]      ;SI←[2080H], DS←[2082H]</span><br><span class="line">MOV  AL, [SI]      ; AL = 88H </span><br></pre></td></tr></table></figure>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231224113311006.png" class title="image-20231224113311006">
<p>如图，先从“DS * 10H + 2080H”的物理地址中取出内容给SI</p>
<p>再从“DS * 10H + 2082H”的物理地址中取出内容给DS（即更新了DS）</p>
<p>于是再用<code>MOV  AL, [SI]</code>时，就是从新的DS开始计算物理地址“DS
* 10H + 001EH”，内容为88H，就存入AL</p>
<h5 id="les装入一个新的物理地址"><code>LES</code>（装入一个新的物理地址）</h5>
<p>LES（Load ES）</p>
<p>与<code>LDS</code>指令类似，只是段寄存器为ES而不是DS</p>
<h4 id="标志寄存器传送指令">标志寄存器传送指令</h4>
<p>FR寄存器是个特殊的寄存器，虽然是16位，但8086中只用了9位</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214222135576.png" class title="image-20231214222135576">
<p>对FR的操作与其他寄存器不一样，指令形式特点为：操作数都是隐含的</p>
<p>其中8位的传输是对SF, ZF, AF, PF和CF操作</p>
<p><code>LAHF</code>：FR寄存器的低8位存入AH</p>
<p><code>SAHF</code>：AH存入FR寄存器的低8位</p>
<p><code>PUSHF</code>：FR寄存器内容入栈</p>
<p><code>POPF</code>：从栈顶弹出内容存入FR寄存器</p>
<p><br></p>
<p>利用标志寄存器传送指令，特别是入栈、出栈指令，可以实现对FR寄存器的一些特殊操作要求</p>
<p>比如：对FR寄存器中的TF标志位（第9位）置1，其他位不变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUSHF				;FR寄存器内容入栈</span><br><span class="line">POP		AX			;FR寄存器内容存入AX</span><br><span class="line">OR		AX,	0200H	;或操作，实现第九位（0000_0010_0000_0000B）置1，然后存入AX中</span><br><span class="line">PUSH	AX			;更新完的AX入栈</span><br><span class="line">POPF				;更新的AX出栈，弹出到FR寄存器，完成操作</span><br></pre></td></tr></table></figure>
<h3 id="算术运算指令">算术运算指令</h3>
<h4 id="算数运算指令的共同点">算数运算指令的共同点</h4>
<p>运算指令<strong>影响状态标志</strong></p>
<p>参加运算的数可以是无符号整型数、带符号整型数、压缩BCD数和非压缩BCD数</p>
<p>乘法/除法指令中，乘数、被乘数以及除数、被除数、商和余数的存放位置有规定</p>
<p>乘法和除法指令的书写形式有要求</p>
<h4 id="算术加法指令">算术加法指令</h4>
<h5 id="算术加法add">算术加法<code>ADD</code></h5>
<p>指令功能：<code>目的操作数 ←- 目的操作数 + 源操作数</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD		目的操作数,	源操作数</span><br></pre></td></tr></table></figure>
<p>这个格式可以展开两种加法指令：</p>
<p>以通用寄存器r为目的操作数，源操作数可以是通用寄存器r，存储器mem，立即数im</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD  AX, BX</span><br><span class="line">ADD  BX, [BP+SI+1000H]</span><br><span class="line">ADD  AL, 12H</span><br></pre></td></tr></table></figure>
<p>以存储器mem为目的操作数，源操作数可以是通用寄存器r，立即数im</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD  WORD PTR[BX],	5B28H</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><code>ADD</code>指令说明：</p>
<ol type="1">
<li>指令的目的操作数不能是立即寻址</li>
<li>两个操作数不能同时为存储器变量</li>
<li>加法操作中产生的进位影响CF标志</li>
<li>带符号数相加要考虑溢出</li>
</ol>
<h5 id="带进位算术加法adc">带进位算术加法<code>ADC</code></h5>
<p>ADC（Add with Carry）</p>
<p>指令功能：<code>目的操作数 ←- 目的操作数 + 源操作数 + CF</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC		目的操作数,	源操作数</span><br></pre></td></tr></table></figure>
<p>这个格式可以展开两种加法指令：</p>
<p>以通用寄存器r为目的操作数，源操作数可以是通用寄存器r，存储器mem，立即数im</p>
<p>以存储器mem为目的操作数，源操作数可以是通用寄存器r，存储器mem</p>
<p><br></p>
<p><code>ADC</code>指令说明：</p>
<ol type="1">
<li>指令中有3个操作数，其中CF是本指令<strong>执行前的状态</strong></li>
<li>需要完成多字节数（如4字节的32位数或更多字节）相加时可以用该指令</li>
<li>指令的目的操作数不能是立即寻址</li>
<li>加法操作中产生的进位进入CF标志位</li>
<li>带符号操作数相加要考虑溢出</li>
</ol>
<p>例如：完成无符号数 5B68F271H 和 0AC6D5698H 加法操作</p>
<p>操作数为32位，8086寄存器只有16位，所以分两次：先<code>ADD</code>算低16位，产生的进位再跟高16位<code>ADC</code>计算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV   AX, F271H		;加数的低16位</span><br><span class="line">ADD   AX, 5698H 	;与被加数的低16位相加，结果存在AX，进位影响CF</span><br><span class="line">MOV   DX, 5B68H 	;加数的高16位</span><br><span class="line">ADC   DX, AC6DH 	;与被加数的高16位和CF相加，运算结果存在DX，进位影响CF</span><br></pre></td></tr></table></figure>
<h5 id="加1指令inc">加1指令<code>INC</code></h5>
<p>指令功能：<code>目的操作数 ←- 目的操作数 + 1</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INC		oprd</span><br></pre></td></tr></table></figure>
<p>根据指令的功能，oprd只能是变量，因此可选：通用寄存器r，存储器mem</p>
<p>注：立即数不是变量，所以操作数不能是立即寻址</p>
<p>该指令<strong>不影响CF标志</strong></p>
<p>操作数为内存寻址时，因为无法确定是8位还是16位变量，所以需要指明字节型（<code>BYTE PTR</code>）或字型（<code>WORD PTR</code>）</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INC  BYTE PTR [BX]  ;BYTE PTR指明字节型</span><br><span class="line">INC  AX</span><br></pre></td></tr></table></figure>
<p>很显然，<code>INC  AX</code>可以由<code>ADD    AX, 1</code>代替，但是<code>ADD</code>指令会影响CF标志位，<code>INC</code>不影响CF标志位，这是主要区别</p>
<h5 id="对压缩bcd数加法操作的结果进行校正daa">对压缩BCD数加法操作的结果进行校正<code>DAA</code></h5>
<p>指令功能：对AL寄存器的内容进行十进制数调整</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DAA</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV    AL, 0001_0101B	;15的BCD表示</span><br><span class="line">ADD    AL, 0001_0110B	;16的BCD表示</span><br><span class="line">DAA</span><br></pre></td></tr></table></figure>
<p><code>DAA</code>这个指令就是用于BCD码运算后<strong>结果处理</strong>的</p>
<p>比如这个例子，我给AL先传入的是15的BCD码<code>0001_0101B</code>，换成16进制就是<code>15H</code></p>
<p>然后再用<code>ADD</code>指令，把16的BCD码<code>0001_0110B</code>（换成16进制就是<code>16H</code>）与AL内容相加，得到的结果为<code>0001_0101B + 0001_0110B = 0010_1011B</code>，换算成十六进制就是<code>15H + 16H = 2BH</code></p>
<p>很显然，15+16的结果应该是31，如果写成BCD码应该是<code>0011_0001B</code>，换成16进制为<code>31H</code></p>
<p>现在AL寄存器的内容为<code>2BH</code>，很明显不是我们要的BCD运算结果</p>
<p>这时就可以用<code>DAA</code>指令，就会将AL中的<code>2BH</code>修正为<code>31H</code>，这就是<code>DAA</code>指令的作用</p>
<p>可以看到，一个数的BCD表示写成十六进制和它的十进制<strong>完全相同</strong>，比如15的BCD码<code>0001_0101B</code>，换成16进制就是<code>15H</code></p>
<p><br></p>
<p>经过这个例子的讲解，<code>DAA</code>指令的功能已经很明确了，再来看书上讲的啥b例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV    AL, 85H</span><br><span class="line">ADD    AL, 96H</span><br><span class="line">DAA</span><br></pre></td></tr></table></figure>
<p>这里的<code>85H</code>和<code>96H</code>都是BCD码，分别代表了十进制的85和96，而不是普通的十六进制133（85H）和150（96H）</p>
<p>85+96=1<strong>81</strong>（81就是最后AL里应该存的值），但是在<code>ADD</code>运算后，AL里存的是<code>1BH</code>（普通十六进制加法：<code>85H + 96H = 11BH</code>，但AL只有8位，所以只能存<code>1BH</code>，并且产生进位，CF=1）</p>
<p>所以<code>DAA</code>这一步处理，就是把AL里的<code>1BH</code>修正为<code>81H</code>（8位的BCD最多表示到99，所以还是产生进位，CF仍旧为1）</p>
<p><code>DAA</code>指令说明：</p>
<ol type="1">
<li>要求操作的数<strong>必须是BCD数</strong>，即存在AL的数必须是BCD数</li>
<li>该指令用在<strong>压缩BCD数加法操作后</strong>，操作数隐含在AL中</li>
</ol>
<h5 id="对非压缩bcd数加法操作的结果进行校正aaa">对非压缩BCD数加法操作的结果进行校正<code>AAA</code></h5>
<p>压缩BCD码：一个字节表示<strong>两位</strong>十进制数，如56的压缩BCD就是<code>0101_0110B</code></p>
<p>非压缩BCD码：一个字节表示<strong>一位</strong>十进制数，其中高4位为0，低4位存放个位，比如5的非压缩BCD就是<code>0000_0101B</code></p>
<p>指令功能：对AL寄存器的内容进行十进制数调整</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAA</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV    AX, 09H	;AH清零，AL中为加数</span><br><span class="line">ADD    AL, 07</span><br><span class="line">AAA				;结果在AX中为0106</span><br></pre></td></tr></table></figure>
<p><code>AAA</code>指令说明：</p>
<ol type="1">
<li>要求参加操作的数必须是非压缩BCD数</li>
<li>该指令用在<strong>非压缩BCD数加法操作后</strong>，操作数隐含在AL中</li>
<li>该指令使用了AH寄存器，所以事先应该将AH内容清零</li>
</ol>
<h4 id="算术减法指令">算术减法指令</h4>
<h5 id="算术减法sub">算术减法<code>SUB</code></h5>
<p>指令功能：<code>目的操作数 ←- 目的操作数 - 源操作数</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUB		目的操作数,	源操作数</span><br></pre></td></tr></table></figure>
<p>这个格式可以展开两种减法指令：</p>
<p>以通用寄存器r为目的操作数，源操作数可以是通用寄存器r，存储器mem，立即数im</p>
<p>以存储器mem为目的操作数，源操作数可以是通用寄存器r，立即数im</p>
<p><br></p>
<p><code>SUB</code>指令说明：</p>
<ol type="1">
<li>指令的目的操作数不能是立即寻址</li>
<li>两个操作数不能同时为存储器变量</li>
<li>减法操作中产生的借位影响CF标志</li>
<li>无符号操作数相减，若CF=1，则结果为补码</li>
<li>带符号数相减要考虑溢出</li>
</ol>
<h5 id="带进位算术减法sbb">带进位算术减法<code>SBB</code></h5>
<p>SBB（Subtract with Borrow）</p>
<p>指令功能：<code>目的操作数 ←- 目的操作数 - 源操作数 - CF</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SBB		目的操作数,	源操作数</span><br></pre></td></tr></table></figure>
<p>这个格式可以展开两种减法指令：</p>
<p>以通用寄存器r为目的操作数，源操作数可以是通用寄存器r，存储器mem，立即数im</p>
<p>以存储器mem为目的操作数，源操作数可以是通用寄存器r，存储器mem</p>
<p><br></p>
<p><code>SBB</code>指令说明：</p>
<ol type="1">
<li>指令有3个操作数，CF是指令执行前的借位</li>
<li>需要完成多字节数（如4字节的32位数或更多字节）相减时可以用该指令</li>
<li>目的操作数不能是立即寻址</li>
<li>无符号操作数相减，若CF=1，则结果为补码</li>
<li>带符号数相减要考虑溢出</li>
</ol>
<p>例：完成无符号数 5B68F271H 和 0AC6D5698H 减法操作</p>
<p>操作数为32位，8086寄存器只有16位，所以分两次：先<code>SUB</code>算低16位，产生的借位再跟高16位<code>SBB</code>计算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV   AX, F271H		;被减数的低16位</span><br><span class="line">SUB   AX, 5698H 	;与减数的低16位相减，结果存在AX，借位影响CF</span><br><span class="line">MOV   DX, 5B68H 	;被减数的高16位</span><br><span class="line">SBB   DX, AC6DH 	;与减数的高16位和借位CF相减，运算结果存在DX，借位影响CF</span><br></pre></td></tr></table></figure>
<h5 id="减1指令dec">减1指令<code>DEC</code></h5>
<p>指令功能：<code>目的操作数 ←- 目的操作数 - 1</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEC		oprd</span><br></pre></td></tr></table></figure>
<p>根据指令的功能，oprd只能是变量，因此可选：通用寄存器r，存储器mem</p>
<p>注：立即数不是变量，所以操作数不能是立即寻址</p>
<p>该指令<strong>不影响CF标志</strong></p>
<p>操作数为内存寻址时，因为无法确定是8位还是16位变量，所以需要指明字节型（<code>BYTE PTR</code>）或字型（<code>WORD PTR</code>）</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEC		CX</span><br><span class="line">DEC		WORD PTR	[BX]</span><br></pre></td></tr></table></figure>
<h5 id="对压缩bcd数减法操作的结果进行校正das">对压缩BCD数减法操作的结果进行校正<code>DAS</code></h5>
<p>指令功能：对AL寄存器中的内容进行十进制数调整</p>
<h5 id="对非压缩bcd数减法操作的结果进行校正aas">对非压缩BCD数减法操作的结果进行校正<code>AAS</code></h5>
<p>指令功能：对AL寄存器中的内容进行十进制数调整</p>
<h5 id="比较指令cmp">比较指令<code>CMP</code></h5>
<p>指令功能：完成两个操作数相减</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMP		目的操作数,	源操作数</span><br></pre></td></tr></table></figure>
<p>执行<code>目的操作数 - 源操作数</code>，但是<strong>不保存结果</strong></p>
<p>如果结果为0，说明两个数相等，使ZF = 1</p>
<p>如果CF = 1，说明产生借位，则<code>目的操作数 &lt; 源操作数</code></p>
<p>如果CF =
0，说明没有产生借位，则<code>目的操作数 &gt;= 源操作数</code></p>
<h5 id="取补指令neg">取补指令<code>NEG</code></h5>
<p>指令功能：0 - 目的操作数</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NEG		oprd</span><br></pre></td></tr></table></figure>
<p>执行<code>0 - oprd -→ oprd</code></p>
<p><br></p>
<p>例如：把DX, AX组成的32位数取补，DX为高16位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NEG		DX		; 0 - DX → DX</span><br><span class="line">NEG		AX		; 0 - AX → AX</span><br><span class="line">SBB		DX,	0	; DX - 0 - CF → DX</span><br></pre></td></tr></table></figure>
<h4 id="算术乘法指令">算术乘法指令</h4>
<h5 id="无符号数乘法指令mul">无符号数乘法指令<code>MUL</code></h5>
<p>指令功能：完成两个操作数相乘，存入AX（32位时还用到了DX）</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL		oprd</span><br></pre></td></tr></table></figure>
<p>通用寄存器r或存储器mem，不能是立即数</p>
<p><code>MUL</code>指令说明：</p>
<ol type="1">
<li>8位×8位为16位，16位×16位为32位</li>
<li>乘数和被乘数都不能立即寻址</li>
<li>乘数或被乘数<strong>必须存放在AL或AX中</strong>，在指令中隐含AL或AX</li>
<li>16位运算结果<strong>在AX中存</strong>，32位运算结果在DX和AX中存</li>
</ol>
<p><br></p>
<p>例如：完成3EH×5DH的运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV		AL,	3EH</span><br><span class="line">MOV		BL,	5DH</span><br><span class="line">MUL		BL			;执行AL×BL存入AX</span><br></pre></td></tr></table></figure>
<h5 id="带符号数乘法指令imul">带符号数乘法指令<code>IMUL</code></h5>
<p>指令功能：完成两个操作数相乘，存入AX（32位时还用到了DX）</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMUL		oprd</span><br></pre></td></tr></table></figure>
<p>通用寄存器r或存储器mem，不能是立即数</p>
<p><code>IMUL</code>指令说明：</p>
<ol type="1">
<li>8位×8位为16位，16位×16位为32位</li>
<li>乘数和被乘数都不能立即寻址</li>
<li>乘数或被乘数<strong>必须存放在AL或AX中</strong>，在指令中隐含AL或AX</li>
<li>16位运算结果<strong>在AX中存</strong>，32位运算结果在DX和AX中存</li>
</ol>
<h5 id="非压缩bcd数乘法结果校正aam">非压缩BCD数乘法结果校正<code>AAM</code></h5>
<p>指令功能：完成两个非压缩BCD数乘法结果的十进制数调整</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAM</span><br></pre></td></tr></table></figure>
<h4 id="算术除法指令">算术除法指令</h4>
<h5 id="无符号数除法指令div">无符号数除法指令<code>DIV</code></h5>
<p>指令功能：完成<code>AX ÷ 操作数</code>，存入AX</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DIV		oprd</span><br></pre></td></tr></table></figure>
<p>通用寄存器r或存储器mem，不能是立即数</p>
<p><code>DIV</code>指令说明：</p>
<ol type="1">
<li>用16位除8位，32位除16位，如果被除数不够16位或32位，就进行扩展</li>
<li>除数和被除数都不能立即寻址</li>
<li>被除数<strong>必须存放在AX或DX:AX中</strong>，在指令中隐含</li>
<li>16位运算的商<strong>在AL中存</strong>，余数<strong>在AH中存</strong></li>
<li>32位运算的商<strong>在AX中存</strong>，余数<strong>在DX中存</strong></li>
</ol>
<p><br></p>
<p>例：完成无符号数3E2CH÷5BH运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV		AX,	3E2CH</span><br><span class="line">MOV		BL,	5BH</span><br><span class="line">DIV		BL</span><br></pre></td></tr></table></figure>
<h5 id="带符号数除法指令idiv">带符号数除法指令<code>IDIV</code></h5>
<p>指令功能：完成<code>AX ÷ 操作数</code>，存入AX</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDIV		oprd</span><br></pre></td></tr></table></figure>
<p>通用寄存器r或存储器mem，不能是立即数</p>
<h5 id="带符号数字节扩展指令cbw">带符号数字节扩展指令<code>CBW</code></h5>
<p>指令功能：将<strong>AL</strong>的8位拓展为16位</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CBW</span><br></pre></td></tr></table></figure>
<h5 id="带符号数字扩展指令cwd">带符号数字扩展指令<code>CWD</code></h5>
<p>指令功能：将<strong>AX</strong>的16位拓展为32位</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CWD</span><br></pre></td></tr></table></figure>
<h5 id="非压缩bcd数除法结果校正aad">非压缩BCD数除法结果校正<code>AAD</code></h5>
<p>指令功能：BCD校正</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAD</span><br></pre></td></tr></table></figure>
<h3 id="位操作指令">位操作指令</h3>
<h4 id="位操作指令共同特点">位操作指令共同特点</h4>
<p>可以按二进制位进行操作</p>
<p>逻辑运算指令按逻辑门电路运算规则</p>
<p>逻辑位移指令有左移右移，移出的位进入CF标志</p>
<p>因移空位的补充方式不同，有多种指令形式</p>
<p>逻辑移位指令中，移动超过1次，则用CL寄存器作为计数器</p>
<p>执行逻辑操作指令（不包括逻辑位移），CF均被清零</p>
<h4 id="逻辑运算指令">逻辑运算指令</h4>
<h5 id="逻辑非指令not">逻辑非指令<code>NOT</code></h5>
<p>指令功能：将8位、16位寄存器或存储器内容求反</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOT		oprd</span><br></pre></td></tr></table></figure>
<p>操作数可以是通用寄存器r，存储器mem</p>
<p><code>NOT</code>指令说明：</p>
<ol type="1">
<li>目的操作数不能为立即数寻址</li>
<li>对8位或16位一次性全部取反</li>
</ol>
<p><br></p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		AX,	1234H</span><br><span class="line">NOT		AX</span><br></pre></td></tr></table></figure>
<p>AX的内容为EDCBH</p>
<h5 id="逻辑与指令and">逻辑与指令<code>AND</code></h5>
<p>指令功能：将8位、16位寄存器或存储器内容和源操作数“与”</p>
<p><code>目的操作数 ←- 目的操作数 与 源操作数</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND		目的操作数, 源操作数</span><br></pre></td></tr></table></figure>
<p>目的操作数可以是通用寄存器r，也可以是存储器mem</p>
<p>当目的操作数为通用寄存器r时，操作数可以是通用寄存器r，存储器mem，立即数im</p>
<p>当目的操作数为存储器mem时，操作数可以是通用寄存器r，存储器mem</p>
<p><code>AND</code>指令说明：</p>
<ol type="1">
<li>目的操作数不能为立即数寻址</li>
<li>可由源操作数控制，对8位或16位数的某些位进行屏蔽或保留</li>
<li>目的操作数和源操作数不能同时为存储器mem</li>
</ol>
<p><br></p>
<p>例如：保留AL中的低4位，高4位清零</p>
<p>与，遇0出0，遇1不变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND		AL,	00001111B</span><br></pre></td></tr></table></figure>
<p>再例如：AL中有小写字符"a-z"其中之一的ASCII码，将其转换为大写</p>
<p>在ASCII码中，大写字母和小写字母的二进制表示只有第五位（从右往左数）不同。大写字母的第五位是0，而小写字母的第五位是1</p>
<p>比如：</p>
<p>大写A是65：<code>0100_0001B</code>；大写Z是90：<code>0101_1010B</code></p>
<p>小写a是97：<code>0110_0001B</code>；小写z是122：<code>0111_1010B</code></p>
<p>所以后5位保持不变，前2位保持不变，只把第五位从1变到0即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND		AL,	1101_1111B</span><br></pre></td></tr></table></figure>
<h5 id="逻辑或指令or">逻辑或指令<code>OR</code></h5>
<p>指令功能：将8位、16位寄存器或存储器内容和源操作数“或”</p>
<p><code>目的操作数 ←- 目的操作数 或 源操作数</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OR		目的操作数, 源操作数</span><br></pre></td></tr></table></figure>
<p>目的操作数可以是通用寄存器r，也可以是存储器mem</p>
<p>当目的操作数为通用寄存器r时，操作数可以是通用寄存器r，存储器mem，立即数im</p>
<p>当目的操作数为存储器mem时，操作数可以是通用寄存器r，存储器mem</p>
<p><code>OR</code>指令说明：</p>
<ol type="1">
<li>目的操作数不能为立即数寻址</li>
<li>可由源操作数控制，对8位或16位数的某些位进行置1或保留</li>
<li>目的操作数和源操作数不能同时为存储器mem</li>
</ol>
<p><br></p>
<p>例如：将DX的低八位置1：</p>
<p>或，遇1出1，遇0不变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OR		DX,	00FFH</span><br></pre></td></tr></table></figure>
<h5 id="逻辑异或指令xor">逻辑异或指令<code>XOR</code></h5>
<p>指令功能：将8位、16位寄存器或存储器内容和源操作数“异或”</p>
<p><code>目的操作数 ←- 目的操作数 异或 源操作数</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XOR		目的操作数, 源操作数</span><br></pre></td></tr></table></figure>
<p>目的操作数可以是通用寄存器r，也可以是存储器mem</p>
<p>当目的操作数为通用寄存器r时，操作数可以是通用寄存器r，存储器mem，立即数im</p>
<p>当目的操作数为存储器mem时，操作数可以是通用寄存器r，存储器mem</p>
<p><code>XOR</code>指令说明：</p>
<ol type="1">
<li>目的操作数不能为立即数寻址</li>
<li>可由源操作数控制，对8位或16位数的某些位进行求反或保留</li>
<li>目的操作数和源操作数不能同时为存储器mem</li>
</ol>
<p><br></p>
<p>例如：将AX的D1,D5,D6,D11和D15求反，其余位不变</p>
<p>异或0，则不变，异或1，则求反</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XOR		AX,	1000_1000_0110_0010B</span><br></pre></td></tr></table></figure>
<h5 id="测试指令test">测试指令<code>TEST</code></h5>
<p>这个指令还挺好用的，特别是搭配<code>JZ</code>指令，因为只涉及到ZF的值，不会改变目的操作数的值</p>
<p>这个在接口技术课设中用了特别多</p>
<p>指令功能：将8位、16位寄存器或存储器内容和源操作数“与”，但<strong>不会改变目的操作数的值</strong></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TEST	目的操作数, 源操作数</span><br></pre></td></tr></table></figure>
<p>目的操作数可以是通用寄存器r，也可以是存储器mem</p>
<p>当目的操作数为通用寄存器r时，操作数可以是通用寄存器r，存储器mem，立即数im</p>
<p>当目的操作数为存储器mem时，操作数可以是通用寄存器r，存储器mem</p>
<p><code>TEST</code>指令说明：</p>
<ol type="1">
<li>与<code>AND</code>指令寻址方式和运算规则相同，但<code>TEST</code>指令不产生运算结果，仅影响ZF</li>
<li>常用来判断某位是否是1或0</li>
</ol>
<p><br></p>
<p>例如：判断AX的D1是否为1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TEST	AX,	0002H</span><br></pre></td></tr></table></figure>
<p>检测ZF标志，如果为0，说明AX和0002H进行与操作最后的结果不是0，则说明D1确实为1；如果ZF为1，说明D1是0</p>
<p>举例来说：若AX为000FH，二进制就是<code>0000_0000_0000_1111B</code></p>
<p>这个值与<code>0000_0000_0000_0010B</code>做与操作，得到的是<code>0002H</code>，不是0，所以ZF标志位为0，所以D1确实为1</p>
<p>如果AX为0009H，即<code>0000_0000_0000_1001B</code>，与运算的结果就是<code>0000H</code>，结果为0，ZF置1，所以D1不是1</p>
<h4 id="逻辑移位指令">逻辑移位指令</h4>
<h5 id="非循环移位指令">非循环移位指令</h5>
<p>算术左移指令 <code>SAL</code>(Shift Arithmetic Left)</p>
<p>算术右移指令 <code>SAR</code>(Shift Arithmetic Right)</p>
<p>逻辑左移指令 <code>SHL</code>(Shift Left)</p>
<p>逻辑右移指令 <code>SHR</code>(Shift Right)</p>
<p>这四条指令格式相同，以<code>SAL</code>为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SAL		oprd,	1	;移动1位</span><br><span class="line">SAL		oprd,	CL	;移动多位，用CL控制次数</span><br></pre></td></tr></table></figure>
<p><code>SAL</code>指令说明：</p>
<ol type="1">
<li>移动1位，源操作数为1；移动超过1位，用CL寄存器控制移动次数</li>
<li>算术左移1位，原数据乘2</li>
<li>移空的位置补0</li>
</ol>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		DL,	0A5H</span><br><span class="line">SAL		DL,	1</span><br></pre></td></tr></table></figure>
<p>执行完后，DL存的就是4AH，最高位1移出去，让CF置1</p>
<p><br></p>
<p>移位指令执行的操作如图所示：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231224224907016.png" class title="image-20231224224907016">
<p>算术右移补的是<strong>符号位</strong></p>
<p>逻辑右移补的是0</p>
<h5 id="循环移位指令">循环移位指令</h5>
<p>不含进位位的循环左移指令 <code>ROL</code>（Rotate Left）</p>
<p>不含进位位的循环右移指令 <code>ROR</code>（Rotate Right）</p>
<p>含进位位的循环左移指令 <code>RCL</code>（Rotate through Carry
Left）</p>
<p>含进位位的循环右移指令 <code>RCR</code>（Rotate through Carry
Right）</p>
<p><br></p>
<p>R（Rotate）就是<strong>循环</strong>移位</p>
<p>S（Shift）就是<strong>非循环</strong>移位</p>
<p><br></p>
<p>格式同非循环移位指令</p>
<p>移位位数放在CL寄存器中，如果只移1位，也可以直接写在指令中</p>
<p>循环移位指令只影响标志位CF和OF</p>
<p>功能如图所示：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231225092923522.png" class title="image-20231225092923522">
<p>例如：将AL的高4位与低4位互换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		CL,	4</span><br><span class="line">ROL		AL,	CL</span><br></pre></td></tr></table></figure>
<h3 id="串处理指令">串处理指令</h3>
<p><a id="explanation of String"></a></p>
<p>串：顺序放在内存中的一组相同类型的数据</p>
<p>串操作：对串中的元素进行相同的操作</p>
<p>串处理指令是针对存储器的操作</p>
<h4 id="串处理指令共同点">串处理指令共同点</h4>
<ol type="1">
<li>指令特殊寻址方式：源操作数的逻辑地址由<code>DS : SI</code>给出，目的操作数的逻辑地址由<code>ES : DI</code>给出</li>
<li>存储单元由字型和字节型之分，所以指令助记符有W（Word）或B（Byte）之分</li>
<li>使用这类指令，存储单元的地址指针是<strong>自动移动</strong>的（串操作指令自动修改SI和DI，字节±1，字±2），用DF标志位控制指针移动方向：DF=0，地址往增大方向移动；DF=1，地址往减小方向移动</li>
<li><strong>串的长度由CX给定</strong></li>
<li>这类指令前面一般可以使用指令前缀（比如重复前缀<code>REP</code>和<code>REPNZ</code>），具体见“<a href="#explanation of Instruction Prefixes">指令前缀</a>”</li>
<li>这类指令后<strong>不带操作数</strong>，操作数隐含给定</li>
</ol>
<h4 id="串指令使用一般方法">串指令使用一般方法</h4>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231225095810612.png" class title="image-20231225095810612">
<h4 id="cld和std指令"><code>CLD</code>和<code>STD</code>指令</h4>
<p>因为串指令中使用DF位，所以把标志控制指令提前放在这里了</p>
<p><code>CLD</code>（Clear Direction
Flag）指令：将方向标志位DF清零，即从低地址到高地址</p>
<p><code>STD</code>（Set Direction
Flag）指令：将方向标志位DF置1，即从高地址到低地址</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLD</span><br><span class="line">STD</span><br></pre></td></tr></table></figure>
<h4 id="串传输指令movsb或movsw">串传输指令<code>MOVSB</code>或<code>MOVSW</code></h4>
<p>B指Byte</p>
<p>W指Word</p>
<p>指令功能：<code>目的操作数 ←- 源操作数</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVSB</span><br><span class="line">MOVSW</span><br></pre></td></tr></table></figure>
<p><strong>源操作数</strong>的逻辑地址由<code>DS : SI</code>给出，即操作<strong>SI</strong></p>
<p><strong>目的操作数</strong>的逻辑地址由<code>ES : DI</code>给出，即操作<strong>DI</strong></p>
<p>DF控制SI或DI是增大还是减小</p>
<p>B和W控制SI和DI是加减1还是加减2</p>
<p><strong>串的长度由CX给定</strong>（即数据区长度），但是指令执行一次，CX<strong>内容不变</strong>（所以要循环执行）</p>
<p><br></p>
<p>例如：用串传送指令，将偏移地址为BUFF1的内存区中200个字型数据，转移到偏移地址为BUFF2的内存区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LEA		SI,	BUFF1		;源操作数地址指针</span><br><span class="line">LEA		DI,	BUFF2		;目的操作数地址指针</span><br><span class="line">CLA						;DF=0</span><br><span class="line">MOV		CX,	200			;数据区长度</span><br><span class="line"></span><br><span class="line">;*******************************************************************</span><br><span class="line">;MOVSW	如果仅写一个MOVSW，这个操作只会被执行一次，所以需要加一个循环</span><br><span class="line">;*******************************************************************</span><br><span class="line"></span><br><span class="line">MOV_LOOP:				;循环MOVSW</span><br><span class="line">	MOVSW</span><br><span class="line">	LOOP	MOV_LOOP	;CX自减，直到CX为0</span><br></pre></td></tr></table></figure>
<p>注：如果仅写一个<code>MOVSW</code>，这个操作只会被执行一次（CX的值不会改变），所以需要加一个循环</p>
<p><br></p>
<p>指令也可写成：<code>MOVS  dest, src</code></p>
<p>但要求：</p>
<p>①<code>src</code>用<code>DS:SI</code>寻址,<code>dest</code>用<code>ES:DI</code>寻址</p>
<p>②传送是字节还是字，由操作数的类型决定</p>
<h4 id="串比较指令cmpsb或cmpsw">串比较指令<code>CMPSB</code>或<code>CMPSW</code></h4>
<p>指令功能：<code>目的操作数 - 源操作数</code>，与<code>CMP</code>指令类似，不会产生结果，只会影响ZF位</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMPSB</span><br><span class="line">CMPSW</span><br></pre></td></tr></table></figure>
<p><strong>源操作数</strong>的逻辑地址由<code>DS : SI</code>给出，即操作<strong>SI</strong></p>
<p><strong>目的操作数</strong>的逻辑地址由<code>ES : DI</code>给出，即操作<strong>DI</strong></p>
<p>指令也可写成：<code>CMPS  dest, src</code></p>
<h4 id="串搜索指令scasb或scasw">串搜索指令<code>SCASB</code>或<code>SCASW</code></h4>
<p><code>SCASB</code>（Scan String Byte）</p>
<p><code>SCASW</code>（Scan String Word）</p>
<p>指令功能：<code>AL/AX - 目的操作数</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCASB</span><br><span class="line">SCASW</span><br></pre></td></tr></table></figure>
<p><strong>源操作数</strong>的逻辑地址由<code>DS : SI</code>给出，即操作<strong>SI</strong></p>
<p><strong>目的操作数</strong>的逻辑地址由<code>ES : DI</code>给出，即操作<strong>DI</strong></p>
<p>本指令用于在串中查找指定的信息，要搜索的关键字放在AL(字节)或AX(字)中</p>
<p><br></p>
<p>例如：</p>
<p>在ES段的偏移1000H开始处存有10个ASCII码。搜索<code>E</code>，若找到则记下搜索次数及存放地址，并在屏幕上显示<code>Y</code>；若未找到则显示<code>N</code></p>
<p>在屏幕上显示一个字符的指令段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV  DL, &lt;字符&gt;</span><br><span class="line">MOV  AH, 2</span><br><span class="line">INT  21H</span><br></pre></td></tr></table></figure>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231225105324142.png" class title="image-20231225105324142">
<p>程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MOV  DI, 1000H         	;(DI)←串偏移地址</span><br><span class="line">MOV  CX, 10	            ;(CX)←串长度</span><br><span class="line">MOV  AL, ’E’          	;搜索关键字=’E’,要搜索的关键字放在AL(字节)或AX(字)中</span><br><span class="line">CLD                     ;置DF=0，从低地址到高地址进行搜索 </span><br><span class="line">REPNZ  SCASB            ;若未找到, 继续搜索                  </span><br><span class="line">JZ   FOUND              ;找到, 转至FOUND</span><br><span class="line">MOV  DL, ’N’          	;串中无’E’，(DL)←’N’</span><br><span class="line">JMP  DONE               ;转至DONE</span><br><span class="line">FOUND:</span><br><span class="line">DEC   DI                ;指针回退</span><br><span class="line">MOV  ADDR, DI           ;ADDR←’E’的地址	   </span><br><span class="line">SUB   DI, 1000H</span><br><span class="line">MOV  NUM, DI            ;NUM←搜索次数	    </span><br><span class="line">MOV  DL, ’Y’          	;(DL)←’Y’</span><br><span class="line">DONE:</span><br><span class="line">MOV  AH, 2		</span><br><span class="line">INT  21H             	;显示字符</span><br><span class="line">HLT 				  ;Halt指令，暂停程序</span><br></pre></td></tr></table></figure>
<p>对部分代码的解释：</p>
<p><code>REPNZ  SCASB</code>：<code>REPNZ</code>（Repeat While Not
Zero）是一个前缀指令，相当于循环执行CX次，同时CX自减，中间如果出现ZF=1就<code>break</code>，否则就正常结束循环</p>
<p>如果出现<code>break</code>的情况，那说明此时ZF一定为1（即<code>SCASB</code>搜索到对应值了），此时就紧接着执行<code>JZ   FOUND</code>指令，跳转到<code>FOUND</code>标签</p>
<p>如果没出现跳出循环的情况，<code>JZ   FOUND</code>指令就不起作用，紧接着执行的是<code>MOV  DL, ’N’</code>指令，按题目要求把<code>N</code>写入DL寄存器，然后执行<code>JMP   DONE</code>指令，跳转到<code>DONE</code>标签，执行显示操作</p>
<p><br></p>
<p>关于<code>FOUND</code>标签第一句：<code>DEC   DI</code>：不管<code>SCASB</code>找到没找到，DI一定会根据DF的值变化。在这里DF为0，DI一定会在<code>SCASB</code>执行完以后+1，所以如果DI到了E这里，执行搜索，搜到了，DI还是会自增1，这就是为什么在寻找E地址的时候需要<code>DEC DI</code></p>
<p>关于<code>MOV  ADDR, DI</code>和<code>MOV  NUM, DI</code>：这里的<code>ADDR</code>和<code>NUM</code>都是变量</p>
<p><br></p>
<p>关于最后的<code>HLT</code>指令：可以理解为C语言程序的<code>system("pause")</code>，处理器进入暂停状态，直到接收到中断信号</p>
<h4 id="串装入指令lodsb或lodsw">串装入指令<code>LODSB</code>或<code>LODSW</code></h4>
<p><code>LODSB</code>（Load String Byte）</p>
<p><code>LODSW</code>（Load String Word）</p>
<p>指令功能：<code>AL/AX ←- 源操作数</code></p>
<p><strong>源操作数</strong>的逻辑地址由<code>DS : SI</code>给出</p>
<p><br></p>
<p>每执行一次，将存储单元的内容写入累加器</p>
<p>不影响标志位</p>
<p><br></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LODSB</span><br><span class="line">LODSW</span><br></pre></td></tr></table></figure>
<p>执行完以后SI会自增，如果是B就自增1次，如果是W就自增2次</p>
<p>其中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LODSB</span><br><span class="line">等价于</span><br><span class="line">MOV  AL, [SI]</span><br><span class="line">INC  SI</span><br><span class="line"></span><br><span class="line">LODSW</span><br><span class="line">等价于</span><br><span class="line">MOV  AX, [SI]</span><br><span class="line">INC  SI</span><br><span class="line">INC  SI</span><br></pre></td></tr></table></figure>
<h4 id="串存储指令stosb或stosw">串存储指令<code>STOSB</code>或<code>STOSW</code></h4>
<p><code>STOSB</code>（Store String Byte）</p>
<p><code>STOSW</code>（Store String Word）</p>
<p>指令功能：<code>目的操作数 ←- AL/AX</code></p>
<p><strong>目的操作数</strong>的逻辑地址由<code>ES : DI</code>给出</p>
<p><br></p>
<p>每执行一次，将累加器的内容写入存储单元</p>
<p>不影响标志位</p>
<p><br></p>
<p>例如：把从A000H开始的2KB内存单元清零</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV  DI, A000H		;起始偏移地址</span><br><span class="line">MOV  AX, 0			;将累加器的内容写入存储单元，所以先将0写入AX</span><br><span class="line">MOV  CX, 2048		;2KB</span><br><span class="line">CLD				    ;低地址向高地址写</span><br><span class="line">REP  STOSB 			;循环执行</span><br></pre></td></tr></table></figure>
<p>又例如：把1000H开始的100个存储单元填入ASCII码2AH(*)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV  DI, 1000H        ; 首地址</span><br><span class="line">MOV  AL, 2AH          ; ‘*’ </span><br><span class="line">MOV  CX, 100          ; 重复执行100次</span><br><span class="line">CLD                   ; 增量修改DI </span><br><span class="line">REP	STOSB</span><br></pre></td></tr></table></figure>
<p>再例如：设在1000H开始存有四个压缩的BCD码12、34、56、78；要求把它们转换为ASCII码存放在3000H开始的单元中</p>
<p>假定DS、ES都已设置为数据段的段基址</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231225115612016.png" class title="image-20231225115612016">
<p><strong>源操作数</strong>的逻辑地址由<code>DS : SI</code>给出，即<code>LODSB</code>指令将<code>DS : SI</code>的内容Load进累加器AL</p>
<p><strong>目的操作数</strong>的逻辑地址由<code>ES : DI</code>给出，即<code>STOSB</code>指令将累加器AL的内容Store进<code>ES : DI</code></p>
<p>程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MOV  SI, 1000H	;SI←BCD首址，因为LODSB指令需要从DS : SI读取数据</span><br><span class="line">MOV  DI, 3000H	;DI←ASCII首址，因为STOSB指令需要把数据写入ES : DI</span><br><span class="line">MOV  BX, 4		;置计数器初值</span><br><span class="line">BBB: </span><br><span class="line">MOV  AL, [SI]    ;AL←BCD码,第一次取12H</span><br><span class="line">AND  AL, 0FH	;屏蔽高4位→02H</span><br><span class="line">OR   AL, 30H	;转换为ASCII码→32H</span><br><span class="line">STOSB           ;保存结果，将累加器AL的内容写入ES : DI</span><br><span class="line">LODSB		   ;读取结果，将DS : SI的内容Load进累加器AL</span><br><span class="line">MOV  CL, 4</span><br><span class="line">SHR  AL, CL      ;逻辑右移4位</span><br><span class="line">OR   AL, 30H     ;得到高4位ASCII码</span><br><span class="line">STOSB           ;保存结果</span><br><span class="line">DEC  BX	   	    ;(BX)←(BX)-1</span><br><span class="line">JNZ  BBB	    ;(BX)≠0，则继续循环</span><br></pre></td></tr></table></figure>
<h3 id="指令前缀">指令前缀</h3>
<p><a id="explanation of Instruction Prefixes"></a></p>
<p>在串操作指令中，串的长度（数据个数）输入进CX，而指令执行时并不对CX进行操作</p>
<p>重复执行这些指令时，需要对CX中的值自减来控制循环的结束</p>
<p>指令前缀就是控制串处理指令循环啊进行，每执行一次，CX内容减1，直到CX内容减到0</p>
<p>如果有些指令还涉及到了ZF标志，则还需要对ZF进行判别</p>
<h4 id="rep前缀"><code>REP</code>前缀</h4>
<p><code>REP</code>前缀就是重复，每执行一次，CX内容减1，直到CX为0退出循环</p>
<p>例如：将偏移地址为BUFF1的内存区中100个字型数据，传送到偏移地址为BUFF2的内存区</p>
<p><strong>源操作数</strong>的逻辑地址由<code>DS : SI</code>给出，即操作<strong>SI</strong></p>
<p><strong>目的操作数</strong>的逻辑地址由<code>ES : DI</code>给出，即操作<strong>DI</strong></p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LEA		SI,	BUFF1	;源操作数地址</span><br><span class="line">LEA		DI,	BUFF2	;目的操作数地址</span><br><span class="line">CLD					;DF=0，从低地址向高地址</span><br><span class="line">MOV 	CX,	100		;100个字型数据</span><br><span class="line">REP		MOVSW		;字型，用MOVSB</span><br></pre></td></tr></table></figure></p>
<h4 id="repzrepe前缀"><code>REPZ</code>/<code>REPE</code>前缀</h4>
<p><code>REPZ</code>/<code>REPE</code>前缀往往与<code>CMPS</code>配合使用</p>
<p><code>REPZ</code>（Repeat While Zero）</p>
<p><code>REPE</code>（Repeat While Equal）</p>
<p>若执行这样的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPZ	CMPS</span><br></pre></td></tr></table></figure>
<p>每执行一次<code>CMPS</code>指令，CX减1，ZF根据比较的结果，如果相同就置1</p>
<p>若CX≠0且ZF=1，比较继续进行</p>
<p>若CX≠0且ZF=0，比较停止</p>
<p>若CX=0，比较停止</p>
<p>所以这个可以用于判断两个串数据是否相等</p>
<h4 id="repnzrepne前缀"><code>REPNZ</code>/<code>REPNE</code>前缀</h4>
<p><code>REPNZ</code>/<code>REPNE</code>前缀往往与<code>SCAS</code>配合使用</p>
<p><code>REPNZ</code>（Repeat While Not Zero）</p>
<p><code>REPNE</code>（Repeat While Not Equal）</p>
<p>若执行这样的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPNZ	SCASB</span><br></pre></td></tr></table></figure>
<p>每执行一次<code>SCASB</code>指令，CX减1，根据比较累加器AX（或AL）的值与当前指针指向的值，如果相等则ZF=1</p>
<p>若CX≠0且ZF=0，比较继续进行</p>
<p>若CX≠0且ZF=1，<code>break</code>比较停止</p>
<p>若CX=0，比较停止</p>
<p>所以这个可以用于判断是否找到AX里的值</p>
<h3 id="程序控制转移指令">程序控制转移指令</h3>
<h4 id="无条件转移jmp">无条件转移<code>JMP</code></h4>
<h5 id="段内转移">段内转移</h5>
<p>段内直接转移用<code>NEAR PTR</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JMP		NEAR PTR	目标地址	;直接转移</span><br><span class="line">JMP		CX						;间接转移</span><br><span class="line">JMP		WORD PTR	[BX]		;间接转移</span><br></pre></td></tr></table></figure>
<h5 id="段间转移">段间转移</h5>
<p>段间直接转移用<code>FAR PTR</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMP		FAR PTR		目标地址	;直接转移</span><br></pre></td></tr></table></figure>
<h4 id="条件转移">条件转移</h4>
<p>我在课设里用<code>JZ</code>用的最多，也还挺好用的</p>
<p><code>JZ</code>/<code>JE</code>：ZF标志为1就转移</p>
<p><code>JNZ</code>/<code>JNE</code>：ZF标志为0就转移</p>
<p><code>JC</code>：CF标志为1就转移</p>
<p><code>JNC</code>：CF标志为0就转移</p>
<p><code>JS</code>：SF标志为1就转移</p>
<p><code>JNS</code>：SF标志为0就转移</p>
<p><code>JO</code>：OF标志为1就转移</p>
<p><code>JNO</code>：OF标志为0就转移</p>
<h4 id="循环控制指令">循环控制指令</h4>
<h5 id="loop"><code>LOOP</code></h5>
<p>执行<code>LOOP</code>会使CX减1</p>
<p>用我在接口技术课设里的代码举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C_16	PROC	NEAR		;标准C，16分音符</span><br><span class="line">	MOV		CX,	29</span><br><span class="line">	C_LOOP_16:</span><br><span class="line">		CALL	Music_C</span><br><span class="line">		LOOP	C_LOOP_16</span><br><span class="line">	RET</span><br><span class="line">C_16	ENDP</span><br></pre></td></tr></table></figure>
<p><code>C_16</code>这个程序里用到了这样一段<code>LOOP</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV		CX,	29</span><br><span class="line">C_LOOP_16:</span><br><span class="line">		CALL	Music_C</span><br><span class="line">		LOOP	C_LOOP_16</span><br></pre></td></tr></table></figure>
<p>先给CX一个值，表示循环次数为29次</p>
<p>然后循环里就一直调用<code>Music_C</code>函数，调用29次</p>
<p>结束循环后直接<code>RET</code></p>
<h4 id="子程序调用和返回指令">子程序调用和返回指令</h4>
<h5 id="子程序调用call">子程序调用<code>CALL</code></h5>
<p>根据我实际做课程设计的情况看，无论隔多远，都能<code>CALL</code>到</p>
<p>所以这里只记录段内直接调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL	函数名</span><br></pre></td></tr></table></figure>
<h5 id="子程序返回ret">子程序返回<code>RET</code></h5>
<p>这个就是高级语言的<code>return</code></p>
<h4 id="中断指令和中断返回指令">中断指令和中断返回指令</h4>
<p>中断指令<code>INT    N</code></p>
<p>中断返回指令<code>IRET</code></p>
<h3 id="处理器控制指令">处理器控制指令</h3>
<p><code>STC</code>：使CF置1</p>
<p><code>CLC</code>：使CF清0</p>
<p><code>CMC</code>：使CF取反</p>
<p><code>STD</code>：使DF置1</p>
<p><code>CLD</code>：使DF清0</p>
<p><code>STI</code>：使IF置1</p>
<p><code>CLI</code>：使IF清0</p>
<p><br></p>
<p><code>HLT</code>：暂停</p>
<p><code>WAIT</code>：等待</p>
<p><code>ESC</code>：换码指令/交权指令</p>
<p><code>LOCK</code>：总线封锁</p>
<p><code>NOP</code>：空操作指令</p>
<h2 id="指令集总结">8086指令集总结</h2>
<h3 id="用到的指令">用到的指令</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">MOV	目的操作数,	源操作数	;源操作数移动到目的操作数</span><br><span class="line"></span><br><span class="line">PUSH	oprd	;oprd指示的地址16位内容入栈，但不能是立即数</span><br><span class="line"></span><br><span class="line">POP	oprd	;16位栈顶元素出栈到oprd指示的地址</span><br><span class="line"></span><br><span class="line">XCHG	r,	oprd	;完成目的操作数和源操作数的内容互换</span><br><span class="line"></span><br><span class="line">IN	a,	oprd	;把oprd指示的端口内容传输到累加器a</span><br><span class="line"></span><br><span class="line">OUT	oprd, a	;把累加器a的内容传送到oprd指定的端口，目的操作数是I/O端口地址</span><br><span class="line"></span><br><span class="line">XLAT	;隐含寻址，从[BX + AL]地址中取数给AL</span><br><span class="line"></span><br><span class="line">LEA	r,	mem	;取mem指示的地址（这里就是偏移地址）送寄存器r，r应该是16位</span><br><span class="line"></span><br><span class="line">LDS	r,	mem	;将mem开始的4个连续字节的内容传输到目的寄存器r和数据段寄存器DS中</span><br><span class="line"></span><br><span class="line">LES	r,	mem	;与LDS类似，传输到ES中</span><br><span class="line"></span><br><span class="line">LAHF	;FR寄存器的低8位存入AH</span><br><span class="line"></span><br><span class="line">SAHF	;AH存入FR寄存器的低8位</span><br><span class="line"></span><br><span class="line">PUSHF	;FR寄存器内容入栈</span><br><span class="line"></span><br><span class="line">POPF	;从栈顶弹出内容存入FR寄存器</span><br><span class="line"></span><br><span class="line">;*********************************************************************************</span><br><span class="line"></span><br><span class="line">ADD	目的操作数,	源操作数	;目的操作数 ←- 目的操作数 + 源操作数</span><br><span class="line"></span><br><span class="line">ADC	目的操作数,	源操作数	;目的操作数 ←- 目的操作数 + 源操作数 + CF</span><br><span class="line"></span><br><span class="line">INC	oprd	;目的操作数 ←- 目的操作数 + 1，不影响CF标志</span><br><span class="line"></span><br><span class="line">DAA	;对压缩BCD数加法操作的结果进行校正</span><br><span class="line"></span><br><span class="line">AAA	;对非压缩BCD数加法操作的结果进行校正</span><br><span class="line"></span><br><span class="line">SUB	目的操作数,	源操作数	;目的操作数 ←- 目的操作数 - 源操作数</span><br><span class="line"></span><br><span class="line">SBB	目的操作数,	源操作数	;目的操作数 ←- 目的操作数 - 源操作数 - CF</span><br><span class="line"></span><br><span class="line">DEC	oprd	;目的操作数 ←- 目的操作数 - 1，不影响CF标志</span><br><span class="line"></span><br><span class="line">DAS	;对压缩BCD数减法操作的结果进行校正</span><br><span class="line"></span><br><span class="line">AAS	;对非压缩BCD数减法操作的结果进行校正</span><br><span class="line"></span><br><span class="line">CMP	目的操作数,	源操作数	;目的操作数 - 源操作数，但是不保存结果，仅影响ZF和CF</span><br><span class="line"></span><br><span class="line">NEG	oprd	;取补，0 - oprd -→ oprd</span><br><span class="line"></span><br><span class="line">MUL	oprd	;完成两个操作数相乘（AX内容乘oprd），存入AX，在指令中隐含AL或AX，oprd不能是立即数</span><br><span class="line"></span><br><span class="line">IMUL	oprd	;带符号数乘法指令（AX内容乘oprd），存入AX，oprd不能是立即数</span><br><span class="line"></span><br><span class="line">AAM	;非压缩BCD数乘法结果校正</span><br><span class="line"></span><br><span class="line">DIV	oprd	;完成AX ÷ 操作数，存入AX，oprd不能是立即数</span><br><span class="line"></span><br><span class="line">IDIV	oprd	;带符号数除法指令，完成AX ÷ 操作数，存入AX</span><br><span class="line"></span><br><span class="line">CBW	;带符号数 字节扩展指令，将AL的8位拓展为16位</span><br><span class="line"></span><br><span class="line">CWD	;带符号数 字扩展指令，将AX的16位拓展为32位</span><br><span class="line"></span><br><span class="line">AAD	;非压缩BCD数除法结果校正</span><br><span class="line"></span><br><span class="line">;*********************************************************************************</span><br><span class="line"></span><br><span class="line">NOT	oprd	;将8位、16位寄存器或存储器内容求反</span><br><span class="line"></span><br><span class="line">AND	目的操作数,	源操作数	;目的操作数 ←- 目的操作数 与 源操作数</span><br><span class="line"></span><br><span class="line">OR	目的操作数,	源操作数	;目的操作数 ←- 目的操作数 或 源操作数</span><br><span class="line"></span><br><span class="line">XOR	目的操作数,	源操作数	;目的操作数 ←- 目的操作数 异或 源操作数</span><br><span class="line"></span><br><span class="line">TEST	目的操作数,	源操作数	;目的操作数 与 源操作数，但不会改变操作数的值，只会改ZF</span><br><span class="line"></span><br><span class="line">;*********************************************************************************</span><br><span class="line"></span><br><span class="line">;*****	S为Shift，非循环移位	*****</span><br><span class="line"></span><br><span class="line">SAL	oprd,	1	;算术左移1位，补0</span><br><span class="line">SAL	oprd,	CL	;算术左移多位，用CL控制次数，补0</span><br><span class="line"></span><br><span class="line">SAR	oprd,	1	;算术右移1位，算数右移补符号位</span><br><span class="line">SAR	oprd,	CL	;算术右移多位，用CL控制次数，算数右移补符号位</span><br><span class="line"></span><br><span class="line">SHL	oprd,	1	;逻辑左移1位，补0</span><br><span class="line">SHL	oprd,	CL	;逻辑左移多位，用CL控制次数，补0</span><br><span class="line"></span><br><span class="line">SHR	oprd,	1	;逻辑右移1位，逻辑右移补0</span><br><span class="line">SHR	oprd,	CL	;逻辑右移多位，用CL控制次数，逻辑右移补0</span><br><span class="line"></span><br><span class="line">;*****	R为Rotate，循环移位	*****</span><br><span class="line"></span><br><span class="line">ROL	oprd,	1	;将操作数oprd所有位都向左移，最高位复制到CF和最低位</span><br><span class="line">ROL	oprd,	CL	;将操作数oprd所有位都向左移CL指定的位数，最高位复制到CF和最低位</span><br><span class="line"></span><br><span class="line">ROR	oprd,	1	;将操作数oprd所有位都向右移，最低位移入最高位</span><br><span class="line">ROR	oprd,	CL	;将操作数oprd所有位都向右移CL指定的位数，最低位移入最高位</span><br><span class="line"></span><br><span class="line">RCL	oprd,	1	;把操作数oprd的每一位都向左移，CF复制到最低位，而最高位复制到CF</span><br><span class="line">RCL	oprd,	CL	;把操作数oprd的每一位都向左移CL指定的位数，CF复制到最低位，而最高位复制到CF</span><br><span class="line"></span><br><span class="line">RCR	oprd,	1	;把操作数oprd的每一位都向右移，CF复制到最高位，而最低位复制到CF</span><br><span class="line">RCR	oprd,	CL	;把操作数oprd的每一位都向右移CL指定的位数，CF复制到最高位，而最低位复制到CF</span><br><span class="line"></span><br><span class="line">;*********************************************************************************</span><br><span class="line"></span><br><span class="line">;*****	串处理指令用到的标志控制指令	*****</span><br><span class="line"></span><br><span class="line">CLD	;将方向标志位DF清零，即从低地址到高地址</span><br><span class="line"></span><br><span class="line">STD	;将方向标志位DF置1，即从高地址到低地址</span><br><span class="line"></span><br><span class="line">;*****	串处理指令	*****</span><br><span class="line">;*****	源操作数的逻辑地址由DS : SI给出	*****</span><br><span class="line">;*****	目的操作数的逻辑地址由ES : DI给出	*****</span><br><span class="line"></span><br><span class="line">MOVSB	;B为Byte，传输一个字节，目的操作数 ←- 源操作数</span><br><span class="line">MOVSW	;W为Word，传输一个字，目的操作数 ←- 源操作数</span><br><span class="line"></span><br><span class="line">CMPSB	;目的操作数 - 源操作数，与CMP指令类似，不会产生结果，只会影响ZF位</span><br><span class="line">CMPSW	;目的操作数 - 源操作数，与CMP指令类似，不会产生结果，只会影响ZF位</span><br><span class="line"></span><br><span class="line">SCASB	;AL - 目的操作数，用于在串中查找指定的信息，要搜索的关键字放在AL(字节)或AX(字)中</span><br><span class="line">SCASW	;AX - 目的操作数，用于在串中查找指定的信息，要搜索的关键字放在AL(字节)或AX(字)中</span><br><span class="line"></span><br><span class="line">LODSB	;AL ←- 源操作数，每执行一次，将存储单元的内容写入累加器</span><br><span class="line">LODSW	;AX ←- 源操作数，每执行一次，将存储单元的内容写入累加器</span><br><span class="line"></span><br><span class="line">STOSB	;目的操作数 ←- AL，每执行一次，将累加器的内容写入存储单元</span><br><span class="line">STOSW	;目的操作数 ←- AX，每执行一次，将累加器的内容写入存储单元</span><br><span class="line"></span><br><span class="line">;*********************************************************************************</span><br><span class="line"></span><br><span class="line">REPZ	CMPS	;可以用于判断两个串数据是否相等</span><br><span class="line"></span><br><span class="line">REPNZ	SCASB	;可以用于判断是否找到AX里的值</span><br><span class="line"></span><br><span class="line">;*********************************************************************************</span><br><span class="line"></span><br><span class="line">JMP	NEAR PTR	目标地址	;直接转移</span><br><span class="line">JMP	CX	;间接转移</span><br><span class="line">JMP	WORD PTR	[BX]	;间接转移</span><br><span class="line"></span><br><span class="line">;*****	LOOP, CALL, RET	*****</span><br><span class="line">C_16	PROC	NEAR		;标准C，16分音符</span><br><span class="line">	MOV		CX,	29</span><br><span class="line">	C_LOOP_16:</span><br><span class="line">		CALL	Music_C</span><br><span class="line">		LOOP	C_LOOP_16</span><br><span class="line">	RET</span><br><span class="line">C_16	ENDP</span><br><span class="line"></span><br><span class="line">STC	;使CF置1</span><br><span class="line">CLC	;使CF清0</span><br><span class="line">CMC	;使CF取反</span><br><span class="line"></span><br><span class="line">STD	;使DF置1</span><br><span class="line">CLD	;使DF清0</span><br><span class="line"></span><br><span class="line">STI	;使IF置1</span><br><span class="line">CLI	;使IF清0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="能用立即数的指令">能用立即数的指令</h3>
<p><code>MOV</code>可以立即数，<code>PUSH, POP, XCHG</code>不行</p>
<p><code>LEA</code>可以立即数，<code>LDS, LES</code>不行</p>
<p>加减法可以立即数，乘除法不行</p>
<p><code>ADD, ADC</code>可以立即数，<code>INC</code>不行</p>
<p><code>SUB, SBB</code>可以立即数，<code>DEC</code>不行</p>
<p><code>CMP</code>可以立即数，<code>NEG</code>不行</p>
<p><code>AND, OR, XOR, TEST</code>可以立即数，<code>NOT</code>不行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MOV</span><br><span class="line">IN		;立即数用来指明端口</span><br><span class="line">OUT		;立即数用来指明端口</span><br><span class="line">LEA		;立即数用来指定地址</span><br><span class="line">ADD</span><br><span class="line">ADC</span><br><span class="line">SUB</span><br><span class="line">SBB</span><br><span class="line">CMP</span><br><span class="line">AND</span><br><span class="line">OR</span><br><span class="line">XOR</span><br><span class="line">TEST</span><br></pre></td></tr></table></figure>
<h3 id="不能用立即数的指令">不能用立即数的指令</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PUSH</span><br><span class="line">POP</span><br><span class="line">XCHG</span><br><span class="line">LDS</span><br><span class="line">LES</span><br><span class="line">INC</span><br><span class="line">DEC</span><br><span class="line">NEG</span><br><span class="line">MUL</span><br><span class="line">IMUL</span><br><span class="line">DIV</span><br><span class="line">IDIV</span><br><span class="line">NOT</span><br><span class="line">SAL		;这些位移指令，可以移动1次，这里1应该不算立即数</span><br><span class="line">SAR		;把这些位移指令放在“不能立即数”，是因为oprd不能是立即数寻址</span><br><span class="line">SHL</span><br><span class="line">SHR</span><br><span class="line">ROL</span><br><span class="line">ROR</span><br><span class="line">RCL</span><br><span class="line">RCR</span><br></pre></td></tr></table></figure>
<h3 id="隐含没有操作数的指令">隐含/没有操作数的指令</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">XLAT	;隐含操作数，涉及的寄存器有AL和BX</span><br><span class="line">LAHF</span><br><span class="line">SAHF</span><br><span class="line">PUSHF</span><br><span class="line">POPF	;上面几个都是操作标志寄存器的，隐含操作数</span><br><span class="line">DAA		;没有操作数</span><br><span class="line">AAA		;没有操作数</span><br><span class="line">DAS		;没有操作数</span><br><span class="line">AAS		;没有操作数</span><br><span class="line">AAM		;没有操作数</span><br><span class="line">CBW</span><br><span class="line">CWD</span><br><span class="line">AAD</span><br><span class="line">CLD</span><br><span class="line">STD</span><br><span class="line">MOVSB</span><br><span class="line">MOVSW</span><br><span class="line">CMPSB</span><br><span class="line">CMPSW</span><br><span class="line">SCASB</span><br><span class="line">SCASW</span><br><span class="line">LODSB</span><br><span class="line">LODSW</span><br><span class="line">STOSB</span><br><span class="line">STOSW</span><br></pre></td></tr></table></figure>
<h2 id="作业-1">作业</h2>
<p>分别指出下列指令中的源操作数和目的操作数的寻址方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MOV		AX, [SI]			;1</span><br><span class="line">MOV		DI, 100				;2</span><br><span class="line">MOV		[BX], AL			;3</span><br><span class="line">MOV		[BX][SI], CX		;4</span><br><span class="line">ADD		AX, 106H[SI]		;5</span><br><span class="line">PUSH	AX					;6</span><br><span class="line">AND		DS:[BP], AX			;7</span><br><span class="line">OR		AX, DX				;8</span><br></pre></td></tr></table></figure>
<p>答：</p>
<p>目的操作数寻址方式 源操作数寻址方式</p>
<p>（1） 寄存器 寄存器间接</p>
<p>（2） 寄存器 立即</p>
<p>（3） 寄存器间接 寄存器</p>
<p>（4） 基址+变址 寄存器</p>
<p>（5） 寄存器 变址</p>
<p>（6） 寄存器间接 寄存器</p>
<p>（7） 带段超越的寄存器间接 寄存器</p>
<p>（8） 寄存器 寄存器</p>
<p>注：</p>
<p><code>PUSH</code>指令目的操作数是隐藏的，目的操作数为[SP]，因此寻址方式是<strong>寄存器间接</strong></p>
<p><br></p>
<p>形如<code>106H[SI]</code>这样的写法：</p>
<p>当使用寄存器BX或BP(Base
Pointer，基址指针，通常与SS搭配)时，称为“<strong>基址寻址</strong>”</p>
<p>当使用寄存器SI或DI时，称为“<strong>变址寻址</strong>”</p>
<p><br></p>
<p><code>[BX][SI]</code>这样的是基址+变址</p>
<p><br></p>
<p><code>DS:[BP]</code>这样的，指定一个非默认的段，这种方式是段超越</p>
<p>因为BP默认是跟SS搭配的，这里指明了DS段，所以是非默认段，就是段超越</p>
<p>同时也是寄存器间接</p>
<p><br></p>
<p><br></p>
<p>已知寄存器（DS）=2000H，（SS）=1500H，（ES）=3200H，（SI）=0A0H，（BX）=100H，（BP）=10H</p>
<p>数据段中变量VAL的偏移地址值为50H</p>
<p>试指出下列各条指令中源操作数的寻址方式是什么？对于存储器操作数，其物理地址是多少？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MOV		AX, [100H]</span><br><span class="line"></span><br><span class="line">MOV		CX, ES:[BX]</span><br><span class="line"></span><br><span class="line">MOV		DX, [BX][SI]</span><br><span class="line"></span><br><span class="line">MOV		AX, VAL[SI]</span><br><span class="line"></span><br><span class="line">MOV		BX, 1234[BX]</span><br><span class="line"></span><br><span class="line">MOV		AX, [BP]</span><br></pre></td></tr></table></figure>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231225180947727.png" class title="image-20231225180947727">
<p>注意BP与SS搭配</p>
<p><br></p>
<p><br></p>
<p>指令理解题：判断下列指令有无错误，若有，则改正</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">（1）PUSH       CL				;错：堆栈指令都是16位，CL只有8位</span><br><span class="line">（2）ADC        AX, 0ABH			;对</span><br><span class="line">（3）OUT        3EBH, AX			;错，3EBH这个地址超过8位，要用DX间接寻址</span><br><span class="line">（4）MUL        AL, CL			;错，MUL指令的AL应该是隐藏的</span><br><span class="line">（5）MUL        AX, 25			;错，除了AX隐藏以外，MUL指令也不能用立即数</span><br><span class="line">（6）ROL        DX, 5				;错，位移指令的次数应该用CL控制</span><br><span class="line">（7）CALL       FAR SUM			;对</span><br><span class="line">（8）POP        FR				;错，FR寄存器出栈用POPF</span><br><span class="line">（9）MOV       234H, BX			;错，MOV指令的目的操作数应该给地址，应该是[234H]</span><br><span class="line">（10）INC       [SI]				;错，要加BYTE PTR或WORD PTR，因为汇编器无法确定要操作的是一个8位的字节还是一个16位的字</span><br><span class="line">（11）ADD      [BX], 456H			;错，跟上一句一样的错误，要加BYTE PTR或WORD PTR</span><br><span class="line">（12）INT       0					;错，没有中断0这条指令</span><br><span class="line">（13）DIV       AX, BX			;错，DIV隐藏AX这个操作数</span><br><span class="line">（14）DEC       [BP]				;错，跟10一样的错，要加BYTE PTR或WORD PTR</span><br><span class="line">（15）XLAT       BX				;错，XLAT不需要操作数</span><br><span class="line">（16）ADD       CX+1				;错，加法指令应该是两个操作数</span><br><span class="line">（17）DAA       AX				;错，DAA不需要操作数</span><br></pre></td></tr></table></figure>
<p>答：</p>
<p>（1）有错。对<strong>堆栈操作总是16位的</strong>。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH	CX</span><br></pre></td></tr></table></figure>
<p>（2）无错。只是CF的值是不确定的，可能是1，也可能是0</p>
<p>（3）有错。输出设备的端口地址若是超过8位，应使用DX间接寻址。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		DX,	3EBH</span><br><span class="line">OUT		DX,	AX</span><br></pre></td></tr></table></figure>
<p>（4）有错。乘法指令中有AX或AL寄存器是隐含的，故指令中仅出现第二个操作数，若为AL×CL，则改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL	CL</span><br></pre></td></tr></table></figure>
<p>（5）有错。与题（4）有类似错误，即乘法指令其中一个数隐含在AX或AL；同时还有一处错误：<strong>乘法指令中不能用立即数</strong>。改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV   BX, 25</span><br><span class="line">MUL   BX</span><br></pre></td></tr></table></figure>
<p>（6）有错。8086指令系统中，<strong>移位的次数由CL寄存器控制</strong>。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV	CL, 5</span><br><span class="line">ROL	DX, CL</span><br></pre></td></tr></table></figure>
<p>（7）无错。在CALL指令中提供子程序的属性（FAR或NEAR），使汇编程序在汇编过程中更快</p>
<p>（8）有错。寄存器FR是不能单独操作的。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POPF</span><br></pre></td></tr></table></figure>
<p>（9）有错。立即数不能作为目的操作数，因为它不可能存放任何信息。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV	BX,	234H</span><br><span class="line">或</span><br><span class="line">MOV	[234H],	BX</span><br></pre></td></tr></table></figure>
<p>（10）有错。该错误主要是针对汇编程序的，由于翻译这条指令时，不知是8位的还是16位的目标码，故要加入宏汇编的综合运算符PTR。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INC   BYTE PTR [SI]</span><br><span class="line">或</span><br><span class="line">INC   WORD PTR [SI]</span><br></pre></td></tr></table></figure>
<p>（11）有错。与第（10）题有同样的错，因为该指令中没有限定翻译成8位的还是16位的目标码。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD  WORD PTR [BX],	456H</span><br><span class="line">或</span><br><span class="line">ADD  BYTE PTR [BX],	456H</span><br></pre></td></tr></table></figure>
<p>（12）有错。这条指令是没有的，因为被零除一旦产生，自动转去执行中断</p>
<p>（13）有错。除法指令和乘法指令类似，AX是隐含的，指令中不出现。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DIV  BX</span><br></pre></td></tr></table></figure>
<p>（14）有错。除与第（10）题有类似的错误外，还要注意，用BP寄存器间接寻址形成物理地址时，段寄存器是SS而不是DS。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEC   WORD PTR [BP]</span><br><span class="line">或</span><br><span class="line">DEC   WORD PTR DS:[BP]</span><br></pre></td></tr></table></figure>
<p>（15）有错。XLAT的操作数是隐含的，它是一条复合指令，在执行该指令之前，将BX指向表的首地址，AL中存入被转换的码，然后才执行该指令。如果用户不按此操作，将得不到希望的结果</p>
<p>（16）有错。加法指令应该是2个操作数。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INC	CX</span><br><span class="line">或</span><br><span class="line">ADD	CX, 1</span><br></pre></td></tr></table></figure>
<p>（17）有错。调整指令是专门针对AL寄存器的内容进行调整的，故指令中操作数隐含。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DAA</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<p>选择题：</p>
<p>（1）带符号数<code>-86</code>在微机中所表示的二进制数值是（）。</p>
<p>A. 10101010B B. 01100101B</p>
<p>C. 10011101B D. 11001011B</p>
<p>答案：A</p>
<p>86的二进制为<code>101_0110B</code></p>
<p>负数在计算机中存的补码：逐位取反加1（或者从右往左数到第一个1，这个1右边的值不变，左边全部取反），按这个计算得<code>010_1010</code></p>
<p>最后在前面加上符号位<code>1</code></p>
<p><code>-86</code>的补码就是<code>1010_1010B</code></p>
<p><br></p>
<p>（2）执行“<code>MOV DL, 2AH</code>”和“<code>SHR DL, 1</code>”两条指令后，DL寄存器与CF标志分别为（）。</p>
<p>A. DL=10110110B CF=1 B. DL=00110101B CF=0</p>
<p>C. DL=00110100B CF=1 D. DL=00010101B CF=0</p>
<p>答案：D</p>
<p>DL一开始是<code>0010_1010B</code></p>
<p><code>SHR DL, 1</code>这条指令是逻辑右移，移出来的位进入CF，补0</p>
<p>移出0进入CF，移位完是<code>0001_0101B</code></p>
<p><br></p>
<p>（3）可将AX寄存器中D0、D5、D8和D11位求反，其余位不变的指令是（）。</p>
<ol type="A">
<li><p><code>AND AX，921H</code> B. <code>OR    AX，910H</code></p></li>
<li><p><code>XOR AX，0921H</code> D.
<code>XOR  AX，0110H</code></p></li>
</ol>
<p>答案：C</p>
<p><code>XOR</code>：异或0，不变；异或1，取反</p>
<p><code>XOR    AX, 0000_1001_0010_0001B</code></p>
<p><br></p>
<p>（4）某存储单元的物理地址为3B4FEH，其段地址和偏移地址可分别选为（）。</p>
<p>A. 3B4FH和104EH B. 3B40H和00FEH</p>
<p>C. 2A00H和114FEH D. 3B4FEH和0</p>
<p>答案：B</p>
<p><code>3B4FEH = 3B40H * 10H + 00FEH</code></p>
<p><br></p>
<p>（5）两个8位二进制数00110101及10110110做“异或”操作后，寄存器FR的下面3个状态标志分别是（）。</p>
<p>A. PF=1，SF=0，ZF=0 B. PF=0，SF=1，ZF=1</p>
<p>C. PF=0，SF=1，ZF=0 D. PF=1，SF=1，ZF=1</p>
<p>答案：C</p>
<p>异或结果为：<code>1000_0011B</code></p>
<p>最高位符号位为1，则SF=1</p>
<p>结果不为0，ZF=0</p>
<p>PF（Parity
Flag）为奇偶标志位，低8位如果有偶数个1，则PF置1；奇数个1，则PF置0</p>
<p>3个1，奇数，PF=0</p>
<p><br></p>
<p>（6）当执行存储器写指令时，如“<code>MOV [SI], AX</code>”，则CPU的外部管脚状态是（）。</p>
<ol type="A">
<li><p>~ WR=1，~ RD=1，M / ~ IO=0 B. ~ WR=0，~ RD=1，M / ~ IO=0</p></li>
<li><p>~ WR=1，~ RD=0，M / ~ IO=1 D. ~ WR=0，~ RD=1，M / ~ IO=1</p></li>
</ol>
<p>答案：D</p>
<p>“存储器写”就得出答案：</p>
<p>对存储器操作，M / ~ IO=1（谁有效就操作谁）</p>
<p>写指令，~ WR=0，~ RD=1</p>
<h1 id="计时器定时器芯片">8253计时器/定时器芯片</h1>
<p>可编程计数器核心电路就是一个事先可以设置计数常数的计数器，其记录脉冲方式和记满“溢出”方式都可以通过程序设定</p>
<h2 id="如何实现定时">如何实现定时</h2>
<p><strong>软件方法</strong>：用一段程序实现延时</p>
<p>利用程序循环延迟指定时间</p>
<p>缺点：延时精度，降低了CPU利用率</p>
<p><strong>硬件方法</strong>：设计定时/计数器电路</p>
<p>利用脉冲计数在设定的时间输出定时信号</p>
<h2 id="概况">8253概况</h2>
<p>内部有3个独立的16位的定时/计数器（通道），可对3个外设实现定时或计数</p>
<p>每个通道6种工作方式</p>
<p>24引脚双列直插式</p>
<p>最高计数频率2MHz</p>
<p>TTL电平兼容</p>
<p>单电源+5V供电</p>
<h2 id="引线图">8253引线图</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218164333705.png" class title="image-20231218164333705">
<p>具体引脚如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218164310827.png" class title="image-20231218164310827">
<p>~CS为片选信号</p>
<p>9,10,11为通道0，同理13,14,15为通道1，16,17,18为通道3</p>
<h3 id="连接至系统端的主要引线">连接至系统端的主要引线</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218164511901.png" class title="image-20231218164511901">
<h3 id="计数通道的主要引线">计数通道的主要引线</h3>
<p>每个通道均相同</p>
<p>CLK，时钟脉冲输入，计数器的计时基准</p>
<p>GATE，门控信号输入，控制计数器的启停（相当于让CLK信号进入计数器的开关）</p>
<p>OUT，计数器输出信号，不同工作方式下产生不同波形</p>
<h2 id="内部结构">8253内部结构</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218164102679.png" class title="image-20231218164102679">
<p>厂家把计数器电路集成在“通道”中，计数器012就是这3个通道</p>
<p><br></p>
<p>程序员视点：</p>
<p>计数器有3个，每一个计数器内部包括16位初值寄存器，16为计数寄存器（减法计数器）</p>
<p>控制寄存器有1个，存放控制命令字，<strong>仅写</strong>不能读</p>
<p>占用4个地址——3个计数器，1个控制寄存器</p>
<p><br></p>
<p>数据总线缓冲器是CPU与8253交换信息的必经之路</p>
<h2 id="定时计数工作过程">8253定时/计数工作过程</h2>
<h3 id="工作过程">工作过程</h3>
<p>1.设置8253的工作方式</p>
<p>2.设置计数初值到初值寄存器</p>
<p>3.<strong>第一个CLK信号</strong>使初值寄存器的内容置入计数寄存器</p>
<p>4.以后每来一个<strong>CLK</strong>信号，计数寄存器减1</p>
<p>5.减到0时，<strong>OUT</strong>端输出一特殊波形的信号</p>
<p>注：以上计数过程中还受到<strong>GATE</strong>信号的控制</p>
<p><br></p>
<p>首先，外电路的脉冲信号通过CLK进入通道，如果GATE有效，使CLK上的脉冲信号进入计数器计数，8253计数器工作在减1状态，每输入一个计数脉冲，计数器的值减1</p>
<p>当计数器计数到0的时候，OUT信号有效，通知外设计数器产生溢出</p>
<p>在通道工作过程中，CPU可以随时通过对端口的读/写，读取计数器的数据</p>
<h3 id="通道内部">通道内部</h3>
<p>在8253中，每个通道内部设置一个16位计数器，可进行二进制或BCD码计数</p>
<p>采用二进制计数时，最大计数值为0FFFFH</p>
<p>采用BCD码计数时，最大计数值为9999</p>
<p>与此计数器相对应，每个通道内部设置一个16位计数值锁存器，必要时用于锁存计数值</p>
<p>每一个计数器内部如图：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218170911203.png" class title="image-20231218170911203">
<h3 id="计数值的设置">计数值的设置</h3>
<p>当一个通道用作计数器时，应将要计数的次数预置到该通道的计数器中</p>
<p>当用作定时器时，从CLK输入一固定频率的时钟脉冲，再根据要求定时的时间算出定时所需计数值（时间常数），并预置到计数器中</p>
<p>计数值与定时时间、CLK端时钟脉冲信号周期的关系如下： <span class="math display">\[
计数值=\frac{定时时间}{时钟脉冲周期}
\]</span></p>
<p>比如我现在输入8253的时钟频率是2MHZ（<span class="math inline">\(2\times10^6\)</span>HZ）</p>
<p>时钟脉冲周期就是<span class="math inline">\(\dfrac{1}{2\times10^6HZ}=0.5\times10^{-6}s=0.5\mu
s\)</span></p>
<p>我需要随便一个计数器，启动计数10ms后OUT输出高电平</p>
<p>单位换算：<span class="math inline">\(1s=1\times10^{3}ms=1\times10^{6}\mu
s=1\times10^{9}ns\)</span> <span class="math display">\[
计数值=\frac{10ms}{0.5\mu s}=20000
\]</span>
所以就给计数器赋值20000即可，至于工作方式的选择，下面再细讲</p>
<h2 id="计数启动方式">计数启动方式</h2>
<p>程序指令启动——软件启动</p>
<p>外部电路信号启动——硬件启动</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218172704311.png" class title="image-20231218172704311">
<p>软件启动的GATE<strong>保持高电平</strong>，<strong>写入计数初值</strong>后的<strong>第2个</strong>CLK脉冲的<strong>下降沿</strong>开始计数</p>
<p>注：软件启动时GATE保持高电平，如果之后工作过程中GATE变成低电平，则说明计数暂停</p>
<p><br></p>
<p>硬件启动的GATE会有<strong>上升沿</strong>，<strong>对应</strong>CLK脉冲的<strong>下降沿</strong>开始计数</p>
<p>这些与8253的工作方式有关</p>
<h2 id="工作方式">8253工作方式</h2>
<p>总共6种工作方式</p>
<p>编号从0到5</p>
<p>0,4是软件启动</p>
<p>1,5是硬件启动</p>
<p>2,3是软件硬件启动</p>
<p>只有方式2和3自动重复计数</p>
<h3 id="方式0计数结束中断">方式0——计数结束中断</h3>
<p>方式0的作用就是用户可以在设定时间上产生中断信号</p>
<p><strong>软件</strong>启动，不自动重复计数（计数初值一次性使用有效）</p>
<p>控制字写入控制寄存器后，OUT端变低电平（一直保持低信号）</p>
<p>计数初值再写入通道后计数器就开始工作</p>
<p>计数结束OUT输出高电平</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218180112248.png" class title="image-20231218180112248">
<p>可见，方式0的GATE要一直为1才能正常工作，不然就暂停</p>
<h3 id="方式1可重复触发的单稳态触发器">方式1——可重复触发的单稳态触发器</h3>
<p>所谓单稳电路，就是在输入的激励下产生固定宽度的脉冲电路</p>
<p>硬件启动，不自动重复计数（如果再给一个GATE上升沿，会重新计数）</p>
<p>控制字写入控制寄存器后，OUT端变高电平</p>
<p>初始计数值写入通道后并不开始计数工作，而是等触发信号到来，即GATE上升沿</p>
<p>计数开始OUT端变为低电平</p>
<p>计数结束后又变高（类似一个低脉冲的效果）</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218181522702.png" class title="image-20231218181522702">
<p>如图，计数已结束，但是再来一个GATE上升沿仍会重新计数</p>
<p>如图，计数未结束时再来一个GATE上升沿，则会重新计数</p>
<h3 id="方式2频率发生器">方式2——频率发生器</h3>
<p>软、硬件启动，<strong>自动重复计数</strong></p>
<p>装入初值后OUT端变高电平，计数到最后一个CLK时（即计数到1）OUT输出一个CLK时钟的负脉冲，并<strong>连续重复此过程</strong></p>
<p>输入信号是周期性脉冲信号，输出信号也是周期性脉冲信号，从OUT输出</p>
<p>方式2实际上是一个可编程的分频电路，把输入信号分频后以脉冲的形式输出，分频系数是用户事先对通道计数器写入的初始计数值</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218182327100.png" class title="image-20231218182327100">
<h3 id="方式3方波发生器">方式3——方波发生器</h3>
<p>软、硬件启动，<strong>自动重复计数</strong></p>
<p>装入初值后OUT端变高电平</p>
<p>然后OUT连续输出对称方波，即同一周期内，前一半为高电平，后一半为低电平</p>
<p>如果计数初始值N为奇数，则前<span class="math inline">\(\dfrac{N+1}{2}\)</span>个CLK里OUT为高，后<span class="math inline">\(\dfrac{N-1}{2}\)</span>个CLK里OUT为低</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218182702598.png" class title="image-20231218182702598">
<h3 id="方式4软件触发选通">方式4——软件触发选通</h3>
<p>软件出发实际上就是CPU通过指令触发一个选通信号给外设，选通信号在触发后<strong>设定时间点</strong>上发出</p>
<p>软件启动，不自动重复计数</p>
<p>装入初值后输出端维持高电平</p>
<p>计数结束输出<strong>一个CLK宽度</strong>的负脉冲</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218183537455.png" class title="image-20231218183537455">
<h3 id="方式5硬件触发选通">方式5——硬件触发选通</h3>
<p>硬件启动，不自动重复计数</p>
<p>OUT端波形与方式4相同</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218183646824.png" class title="image-20231218183646824">
<h3 id="各种工作方式总结">各种工作方式总结</h3>
<h4 id="方式0计数结束中断-1">方式0（计数结束中断）</h4>
<p>计数过程中，GATE端应保持<strong>高电平</strong></p>
<p>每写入一次初值计数一个周期，然后停止计数</p>
<p>OUT端输出是一个约(N+1)TCLK宽度的负脉冲（写入控制字时变低，直到计数为0时升高，从头到尾算是一个负脉冲）</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095341089.png" class title="image-20231219095341089">
<p>计数过程中可随时修改初值重新开始计数</p>
<h4 id="方式1单稳态触发器">方式1（单稳态触发器）</h4>
<p>门控信号GATE端的跳变触发计数，可重复触发</p>
<p>若下一次GATE上升沿提前到达，则OUT端负脉冲拉宽为两次计数过程之和</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095419928.png" class title="image-20231219095419928">
<p>计数过程中写入新初值不影响本次计数</p>
<h4 id="方式2频率发生器-1">方式2（频率发生器）</h4>
<p>GATE为计数的控制信号：GATE变低计数停止，再变高时的下一个CLK下降沿，从初值开始重新计数</p>
<p>每个计数周期结束时（<strong>减到1时</strong>），OUT端输出一个TCLK宽度的负脉冲</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095500010.png" class title="image-20231219095500010">
<p>计数过程<strong>自动重复</strong>进行</p>
<p>计数过程中修改初值不影响本轮计数过程</p>
<h4 id="方式3方波发生器-1">方式3（方波发生器）</h4>
<p>OUT输出方波，前半周期为高，后半周期为低，一半一半</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095518357.png" class title="image-20231219095518357">
<p>计数过程中修改初值不影响<strong>本半轮</strong>计数过程</p>
<p>其余的与方式2类似</p>
<h4 id="方式4软件触发选通-1">方式4（软件触发选通）</h4>
<p>计数过程中，GATE端应保持<strong>高电平</strong></p>
<p>每写入一次初值，计数一个周期，然后停止计数</p>
<p>每个计数周期结束时（减到0时），OUT端输出一个TCLK宽度的负脉冲</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095544309.png" class title="image-20231219095544309">
<p>计数过程中修改初值不影响本轮计数过程</p>
<h4 id="方式5硬件触发选通-1">方式5（硬件触发选通）</h4>
<p>写入初值时，GATE端应保持<strong>低电平</strong></p>
<p>GATE每出现一次正脉冲，计数一个周期，然后停止计数</p>
<p>每个计数周期结束时（减到0时），OUT端输出一个TCLK宽度的负脉冲</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095544309.png" class title="image-20231219095544309">
<p>计数过程中修改初值不影响本轮计数过程</p>
<h3 id="gate信号功能表">GATE信号功能表</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218184150817.png" class title="image-20231218184150817">
<h2 id="控制字">8253控制字</h2>
<p>用于确定各计数器的工作方式</p>
<p>8253必须先初始化才能正常工作</p>
<p>每个计数器都必须初始化一次</p>
<p>CPU通过OUT指令把控制字写入<strong>控制寄存器</strong></p>
<h3 id="控制字格式">控制字格式</h3>
<p>8位控制字</p>
<p>控制字包括：指定计数器，对通道计数器的读写方式，指定通道工作方式，通道计数器计数时采用的数制信息（BCD或二进制）</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218184439221.png" class title="image-20231218184439221">
<p>每个寄存器都要记住</p>
<p>从高到底分别为：</p>
<p>SC1, SC0, RL1, RL0, M2, M1, M0, BCD</p>
<p>前两个SC选择了计数器</p>
<p>两个RL用于确定读/写操作的方式，同时也是计数长度的选择，00锁存，01低8位，10高8位，11先低后高两个字节，即计数值为16位</p>
<p>M2M1M0指定工作方式，其中方式2和3的编码很特殊，不考虑M2位</p>
<p>最低位的BCD指定是否BCD计数</p>
<h2 id="初始化顺序">8253初始化顺序</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218185220397.png" class title="image-20231218185220397">
<p>先写方式控制字，按012的顺序</p>
<p>写计数值低8位后紧接着写同一个计数器的计数值高8位</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218185724423.png" class title="image-20231218185724423">
<h2 id="与系统的连接图">8253与系统的连接图</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218203805355.png" class title="image-20231218203805355">
<h2 id="如何读出当前计数值">如何读出当前计数值</h2>
<p>第1种方法——在计数过程中读计数值</p>
<p>先锁存当前计数值，再用两条输入指令将16位计数值读出</p>
<p><br></p>
<p>第2种方法——停止计数器再读</p>
<p>用GATE信号使计数器停止，再规定RL1和RL0的读写格式，然后读出</p>
<h2 id="扩展定时计数范围">扩展定时/计数范围</h2>
<p>当定时长度不够时，可把2个或3个计数通道串联起来使用，甚至可把多个8253串联起来使用</p>
<p>例如：CLK频率为1MHz，要求在OUT1端产生频率1Hz的脉冲</p>
<p>这时可将计数器0、1串联，工作方式都均为方式3，计数初值均为1000</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218225423320.png" class title="image-20231218225423320">
<h2 id="作业-2">8253作业</h2>
<p>别急</p>
<h1 id="并行可编程接口芯片">8255并行可编程接口芯片</h1>
<p>其实CPU可以直接和外设相连，不用8255也可以</p>
<p>但是CPU只是发送信号，驱动能力很低（电流很低），接很多外设CPU扛不住</p>
<p>于是可以在CPU和外设之间加一块8255，既可以传信号，也可以增加驱动能力，还可以可靠传输</p>
<h2 id="概况-1">8255概况</h2>
<p>8255A是一种通用的可编程并行I/O接口芯片，具有3个独立的带锁存或缓存的数据端口，<strong>可与外设并行进行数据交换</strong></p>
<p>用户可以用程序选择多种操作方式，可为CPU与外设之间提供并行输入/出通道</p>
<p>各端口内具有中断控制逻辑，在外设与CPU之间可用中断方式进行信息交换，使用条件传输方式时可用“联络”线进行控制</p>
<p>可通过编程设置各端口工作方式和数据传送方向（入/出/双向）</p>
<p>并行数据宽度为8位</p>
<h2 id="引线图-1">8255引线图</h2>
<p>共40个引脚</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218203116142.png" class title="image-20231218203116142">
<h3 id="连接至系统端的主要引线-1">连接至系统端的主要引线</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218203215422.png" class title="image-20231218203215422">
<h3 id="连接外设端的引脚">连接外设端的引脚</h3>
<p>PA0-PA7</p>
<p>PB0-PB7</p>
<p>PC0-PC7</p>
<p>对应了A, B, C三个8位输入/输出端口</p>
<p>三个端口可通过<strong>编程</strong>分别指定为输入或输出口</p>
<p>其中，C口即可用作独立的输入/输出口，也可用作A、B口的<strong>控制信号输出</strong>或<strong>状态信号输入</strong></p>
<h2 id="内部结构-1">8255内部结构</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218203534742.png" class title="image-20231218203534742">
<p>厂家除了把输入/输出接口电路集成在一块芯片中，还包括控制这些接口电路的控制部分，以及与CPU接口的总线接口部分</p>
<p><br></p>
<p>8255A芯片中包含3个8位端口：A口，B口，C口</p>
<p>这三个端口均可以作为CPU与外设通信时的缓冲器或锁存器</p>
<p>一般来说，它们做缓冲器使用时，是输入接口；作为锁存器使用时，是输出接口</p>
<p><br></p>
<h3 id="c口可作为ab两端口的信号输入输出">C口可作为AB两端口的信号输入输出</h3>
<p>条件传输方式需要“状态”或“联络”信号</p>
<p>中断传输方式需要“中断”信号</p>
<p>由于8255没有预先从芯片引脚上给出这些信号，因此在用户选择这两种工作方式时，8255A将从C口的8位I/O线中提取若干根线作为“状态”“联络”或“中断”线；在这种状态下，C口剩余的线依然可以作为I/O线</p>
<p>也就是说C口相当于“握手协议”，维持传输的稳定</p>
<p>3个端口通过各自的I/O线与外设联系</p>
<h3 id="ab端口控制">AB端口控制</h3>
<p>8255A有3个端口，但不是每个端口都有自己独立的控制部件，只有两个控制部件</p>
<p>只有A组和B组有控制部件，这样3个端口就会分为2组</p>
<p>A组由A口和C口的高4位组成</p>
<p>B组由B口和C口的低4位组成</p>
<p>A组和B组有自己的控制部件，可同时接受来自读/写控制电路的命令和CPU送来的控制字，并且根据这些来定义各个端口的操作方式</p>
<h3 id="数据总线缓冲器">数据总线缓冲器</h3>
<p>数据总线缓冲器是CPU与8255A交换信息的必经之路</p>
<h2 id="与系统的连接图-1">8255与系统的连接图</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218203732822.png" class title="image-20231218203732822">
<h2 id="工作方式-1">8255工作方式</h2>
<p>总共3种工作方式</p>
<p>编号是0，1，2</p>
<h3 id="方式0基本输入输出方式">方式0：基本输入/输出方式</h3>
<p>方式0主要工作在无条件的输入/输出方式下，不需要“联络”信号</p>
<p>A口，B口，C口均可工作在此方式下，C口只能工作在方式0下</p>
<p>在这种方式下，CPU与端口之间交换数据可以直接由CPU执行IN或OUT指令完成，不需要检测状态线</p>
<p>由于在方式0下，3个端口可以分别定义为输入或输出端口，于是3个端口就会有下图16种输入/输出组合：</p>
<p>16的原因：C口可以分为两个4位的独立端口</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218220935091.png" class title="image-20231218220935091">
<p><br></p>
<p>8255在方式0相当于三个独立的8位简单接口</p>
<p>各端口既可设置为输入口，也可设置为输出口，但<strong>不能同时</strong>实现输入及输出</p>
<p>C端口即可以是一个8位的简单接口，也可以分为<strong>两个独立的</strong>4位端口</p>
<p>设置为输出口时有锁存能力，设置为输入口时无锁存能力</p>
<p><br></p>
<h4 id="方式0的应用">方式0的应用</h4>
<p>用于连接简单外设</p>
<p>适用于：</p>
<p>无条件输入输出方式</p>
<p>查询输入输出方式：把A、B口作为8位数据的输入或输出口，C口的高/低4位分别定义为A、B口的控制位和状态位</p>
<h3 id="方式1选通输入输出方式">方式1：选通输入/输出方式</h3>
<p>方式1主要工作在异步或条件传输方式下</p>
<p>在方式1下，数据的输入、输出操作要在选通信号控制下完成，适合条件传输（必须先检查状态，然后才能传输数据）</p>
<p>仅有A口和B口可工作在此方式下，因为C口的部分位固定用作A、B口的选通控制信号（联络线），相当于握手协议</p>
<p>工作在方式1下的A口和B口可以作为输入接口，也可以作为输出接口</p>
<p>由于输入接口和输出接口所需要的选通控制不同，“联络线”的定义和功能也不同，需要分别介绍</p>
<h4 id="选通输入方式">选通输入方式</h4>
<p>AB口均为输入</p>
<p>在这种方式下，A口或B口需有C口3根线作为联络线</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219091555181.png" class title="image-20231219091555181">
<p>PC3, PC4, PC5作为A口的联络线，PC0, PC1, PC2作为B口的联络线</p>
<h5 id="信号功能">信号功能</h5>
<p>~STBA：A口的选通信号（外设发出，低电平有效），当其有效时，外设把数据输入A口的输入缓冲器</p>
<p>IBFA：A口的输入缓冲器“满”信号，当其有效时，表示A口的输入缓冲器已暂存一个有效数据，是输出信号；此信号由STB的<strong>前沿</strong>产生</p>
<p>INTRA：A口的中断请求信号，当其有效时，8255的A口向CPU申请中断，要求CPU从A口取数，是输出信号；此信号由STB的<strong>后沿</strong>产生</p>
<p>在这种方式下，A口的逻辑电路有一个INTEA信号，称为中断允许信号，这个信号为高时，与门导通，INTEA就可以作为INTRA中断信号输出了。INTEA对应C口输出锁存器的第4位，即通过对C口PC4的置位/复位就可以设置INTEA</p>
<p>即：INTEA =1和IBFA为高电平时，允许发出INTRA请求</p>
<h5 id="发送数据过程">发送数据过程</h5>
<p>在方式1下，外设把一个数据通过A口送给CPU的过程如下：</p>
<p>1.外设把数据送到A口的数据线PA7-PA0后，使选通信号~STBA有效，数据进入A口的输入缓冲区</p>
<p>2.A口的IBFA有效，通知外设或CPU，表示A口接收了一个有效数据</p>
<p>3.A口的INTRA有效，以中断方式通知CPU取走A口的数据</p>
<p>4.CPU读A口，数据进入CPU</p>
<p>5.IBFA和INTRA转为无效</p>
<p>方式1数据输入的时序图如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219093233107.png" class title="image-20231219093233107">
<p><br></p>
<p>可见，当A口接收外部数据以后，会有IBFA和INTRA的输出，对应了两种方式通知CPU取数：</p>
<p>条件查询方式，通过查询缓冲器是否“满”，即IBFA是否为高电平来取数</p>
<p>中断方式，先用控制字把C口的INTEA置位1，当IBFA=1时，这两个高电平通过与门产生高电平INTRA；若CPU允许中断，则中断当前执行的程序，转到对A口读数的中断服务子程序</p>
<h5 id="握手信号">握手信号</h5>
<p>在条件传输中，一般需要有“握手”信号来协调数据的传输</p>
<p>“握手”信号至少要有两位信号线，其中一位由接口电路发给外设，另一位是外设发给接口</p>
<p>在选通方式中，~STBA和IBFA是一对“握手”信号</p>
<p>~STBA是外设发给接口，有效时通知A口，外设传递进来一个数据</p>
<p>IBFA是接口发给外设，有效时通知外设，A口已经接收这个数据</p>
<h5 id="此时的状态字">此时的状态字</h5>
<p>从C口读出的8位数据各位的意义如下</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219101522618.png" class title="image-20231219101522618">
<h4 id="选通输出方式">选通输出方式</h4>
<p>AB口均为输出</p>
<p>在这种方式下，A口或B口需有C口3根线作为联络线</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219101654339.png" class title="image-20231219101654339">
<p>PC3, PC6, PC7作为A口的联络线，PC0, PC1,
PC2作为B口的联络线（与选通输入有点不同：A口的联络线变成了PC3, PC6,
PC7）</p>
<h5 id="信号功能-1">信号功能</h5>
<p>~OBFA：A口输出缓冲区“满”信号，有效时表示A口输出缓冲器已经暂存一个有效数据，通知外设取数据</p>
<p>~ACKA：外设应答信号，由外设发出，低电平有效时表示外设<strong>已经接收</strong>数据</p>
<p>INTRA：A口的中断请求信号，当其有效时，A口向CPU申请中断，要求CPU送数据给A口，由~ACKA上升沿产生（通常接到8259）</p>
<h5 id="发送数据过程-1">发送数据过程</h5>
<p>在方式1输出方式下，CPU把数据通过A口送给外设的过程如下：</p>
<p>1.CPU执行OUT指令，把数据写入A口的输出缓冲器</p>
<p>2.当有效数据进入A口的数据线PA7-PA0时，~OBFA有效通知外设：CPU已把一个有效数据输出到A口，外设可以从A口取数据了</p>
<p>3.外设取走数据时，发~ACKA信号给8255，告诉A口外设已经取完数据</p>
<p>4.A口~OBFA无效，表示A口数据已经被外设取走</p>
<p>5.INTRA有效，以中断的方式通知CPU再输出数据给A口</p>
<p>方式1数据输出的时序图如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219103820080.png" class title="image-20231219103820080">
<p><br></p>
<p>同样，当A口的输出缓冲器数据被外设取走后，有两种方式通知CPU再对A口写入数据：</p>
<p>条件查询方式，查询输出缓冲器是否为“空”，即~OBFA是否为高电平决定CPU是否转向对A口输出数据的程序</p>
<p>中断方式，先用控制字置A口的INTEA位为“1”，若外设取走A口的数据，应答信号~
ACKA有效，使~ OBFA为高电平；~
OBFA和INTEA都为高电平，通过与门产生INTRA中断信号，若CPU允许中断，则中断当前执行的程序，转到对A口写数的中断服务子程序</p>
<h5 id="握手信号-1">握手信号</h5>
<p>在这种方式下，~ ACKA和~ OBFA是一对握手信号</p>
<p>~OBFA是接口发给外设，通知外设A口有了一个新数据</p>
<p>~ACKA是外设发给接口，通知接口外设已经把数据取走</p>
<h5 id="此时状态字">此时状态字</h5>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219105111892.png" class title="image-20231219105111892">
<h4 id="方式1的应用">方式1的应用</h4>
<p>主要用于中断控制方式下的输入输出</p>
<p>C口除部分位用作选通信号外，其余位可工作在方式0下，作为输入或输出线</p>
<p>特别是A、B均为方式1时仅使用C口的6条线，余下二条线可作为单独的输入输出线，用程序指定其数据传送方向</p>
<h3 id="方式2双向传输方式仅a口">方式2：双向传输方式（仅A口）</h3>
<p>双向方式——既是输入口，又是输出口</p>
<p>利用C口的5条线提供传输联络信号</p>
<p>类似于A口方式1下输入和输出的组合</p>
<p>只有A口可工作在方式2下</p>
<h2 id="控制字-1">8255控制字</h2>
<h3 id="控制字格式-1">控制字格式</h3>
<p>8位控制字</p>
<p>有3种控制字：方式控制字，C口置1清0控制字，读入状态字</p>
<p>要记住所有寄存器</p>
<p>D7为1时，是选择工作方式控制字</p>
<p>D7为0时，是C口置位/复位控制字</p>
<p><br></p>
<h3 id="方式控制字">方式控制字</h3>
<p>控制字包括1位的功能控制，4位的A组控制，3位的B组控制</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218213154942.png" class title="image-20231218213154942">
<p>从高位到低位分别是：</p>
<p>D7功能控制，区分出来两种控制字：<strong>选择工作方式控制字</strong>和<strong>C口置位/复位控制字</strong></p>
<p>D7为1时，是选择工作方式控制字</p>
<p>D7为0时，是C口置位/复位控制字</p>
<p><br></p>
<p>D6, D5, D4, D3是A组控制</p>
<p>其中D6和D5选择工作方式（仅有A口能用方式2）</p>
<p>D4是A口的输入、输出选择</p>
<p>D3为C口高4位的输入、输出选择</p>
<p><br></p>
<p>D2, D1, D0是B组控制</p>
<p>D2为B口的方式选择</p>
<p>D1是B口的输入、输出选择</p>
<p>D0为C口低4位的输入、输出选择</p>
<h3 id="c口置位复位控制字">C口置位/复位控制字</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218215033167.png" class title="image-20231218215033167">
<p>也就是可以直接操作C口的位</p>
<p>用D3，D2，D1指定PC0-PC7</p>
<p>然后再用D0选择这个口现在的信息</p>
<h3 id="读入状态字">读入状态字</h3>
<p>当8255A工作在方式1或方式2时，C口会根据不同情况产生或接收“联络”信号</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219101327421.png" class title="image-20231219101327421">
<h1 id="中断">中断</h1>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/">复习整理</a><a class="post-meta__tags" href="/tags/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/">接口技术</a><a class="post-meta__tags" href="/tags/8086/">8086</a><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">汇编语言</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/20/hexo%E7%9B%B8%E5%85%B3/Hexo_Nunjucks_Error%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" title="Hexo Nunjucks Error解决方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hexo Nunjucks Error解决方法</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/06/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/OOAD%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="OOAD复习整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">OOAD复习整理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/12/06/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/OOAD%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="OOAD复习整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-06</div><div class="title">OOAD复习整理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/WinkySpeed%20SP%20-%20Repaired.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">WinkySpeed</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">44</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WinkySpeed"><i class="fab fa-github"></i><span>GitHub</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">接口技术复习整理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">2.</span> <span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9C%A8%E5%B7%A5%E4%B8%9A%E7%94%9F%E4%BA%A7%E8%BF%87%E7%A8%8B%E7%9A%84%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">计算机在工业生产过程的闭环控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">总线分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu"><span class="toc-number">2.3.</span> <span class="toc-text">CPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.</span> <span class="toc-text">I&#x2F;O接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%AE%BE%E9%80%9A%E8%BF%87io%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%80%BB%E7%BA%BF%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.4.1.</span> <span class="toc-text">外设通过I&#x2F;O接口与总线连接的原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA"><span class="toc-number">2.5.</span> <span class="toc-text">微机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.5.1.</span> <span class="toc-text">微机基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">微机工作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA%E5%88%86%E7%B1%BB"><span class="toc-number">2.5.3.</span> <span class="toc-text">微机分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA%E7%BB%84%E6%88%90"><span class="toc-number">2.5.4.</span> <span class="toc-text">微机组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.5.</span> <span class="toc-text">微机工作原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">8086系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">8086CPU结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE"><span class="toc-number">3.1.1.</span> <span class="toc-text">8086CPU内部结构框图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E6%8E%A5%E5%8F%A3%E9%83%A8%E4%BB%B6biubus-interfaceunit"><span class="toc-number">3.1.2.</span> <span class="toc-text">总线接口部件BIU(Bus
InterfaceUnit)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#biu%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">BIU功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#biu%E7%BB%84%E6%88%90"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">BIU组成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E6%AE%B5%E5%9F%BA%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.2.2.1.</span> <span class="toc-text">段寄存器（段基址寄存器）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.2.2.2.</span> <span class="toc-text">指令指针寄存器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%8A%A0%E6%B3%95%E5%99%A8"><span class="toc-number">3.1.2.2.3.</span> <span class="toc-text">物理地址加法器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%98%9F%E5%88%97"><span class="toc-number">3.1.2.2.4.</span> <span class="toc-text">指令队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E6%8E%A7%E5%88%B6%E9%83%A8%E4%BB%B6"><span class="toc-number">3.1.2.2.5.</span> <span class="toc-text">总线控制部件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#biu%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">BIU工作过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%83%A8%E4%BB%B6euexecution-unit"><span class="toc-number">3.1.3.</span> <span class="toc-text">指令执行部件EU(Execution
Unit)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#eu%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">EU功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eu%E7%BB%84%E6%88%90"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">EU组成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E9%80%BB%E8%BE%91%E9%83%A8%E4%BB%B6alu"><span class="toc-number">3.1.3.2.1.</span> <span class="toc-text">算术运算逻辑部件ALU</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8frflag-register"><span class="toc-number">3.1.3.2.2.</span> <span class="toc-text">标志寄存器FR（Flag Register）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A0%87%E5%BF%97"><span class="toc-number">3.1.3.2.2.1.</span> <span class="toc-text">状态标志</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%A0%87%E5%BF%97"><span class="toc-number">3.1.3.2.2.2.</span> <span class="toc-text">控制标志</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.3.2.3.</span> <span class="toc-text">通用寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.3.2.3.1.</span> <span class="toc-text">数据寄存器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.3.2.3.2.</span> <span class="toc-text">指针变址寄存器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#eu%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">3.1.3.2.4.</span> <span class="toc-text">EU控制器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eu%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">EU的工作过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu%E5%BC%95%E8%84%9A"><span class="toc-number">3.2.</span> <span class="toc-text">8086CPU引脚</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E8088%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">3.3.</span> <span class="toc-text">8086与8088不同之处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87"><span class="toc-number">3.4.</span> <span class="toc-text">8086存储器组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BC%96%E5%9D%80"><span class="toc-number">3.4.1.</span> <span class="toc-text">线性编址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">3.4.2.</span> <span class="toc-text">数据存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%8A%80%E6%9C%AF"><span class="toc-number">3.4.3.</span> <span class="toc-text">分段技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E6%AE%B5"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">存储空间的分段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%A2%E6%88%90"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">物理地址的形成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%9A%84%E6%9D%A5%E6%BA%90%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E6%AE%B5%E5%86%85%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8%E6%90%AD%E9%85%8D%E4%BD%BF%E7%94%A8"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">逻辑地址的来源（段寄存器与段内指针寄存器搭配使用）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.4.</span> <span class="toc-text">分体结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E9%82%BB%E4%B8%A4%E4%B8%AA%E5%8D%95%E5%85%83%E5%AD%97%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">相邻两个单元（字）的读写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%B6%E5%9C%B0%E5%9D%80%E4%B8%BA%E4%BD%8E%E5%AD%97%E8%8A%82%E7%9A%84%E5%AD%97%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">3.4.4.1.1.</span> <span class="toc-text">偶地址为低字节的字的读写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A5%87%E5%9C%B0%E5%9D%80%E4%B8%BA%E4%BD%8E%E5%AD%97%E8%8A%82%E7%9A%84%E5%AD%97%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">3.4.4.1.2.</span> <span class="toc-text">奇地址为低字节的字的读写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%A0%88"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">堆栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A"><span class="toc-number">3.5.</span> <span class="toc-text">作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">8086指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.</span> <span class="toc-text">8086指令的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%81%B5%E6%B4%BB%E7%9A%84%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.灵活的指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%BD%A2%E5%BC%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">2.指令格式的一对多形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%83%E5%BC%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">4.1.3.</span> <span class="toc-text">3.较强的运算指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%9C%89%E6%9E%81%E5%BC%BA%E7%9A%84%E5%AF%BB%E5%9D%80%E8%83%BD%E5%8A%9B"><span class="toc-number">4.1.4.</span> <span class="toc-text">4.指令有极强的寻址能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%9C%89%E5%A4%84%E7%90%86%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="toc-number">4.1.5.</span> <span class="toc-text">5.指令有处理多种数据的能力</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">8086指令寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">立即寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">寄存器寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">直接寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.1.4.</span> <span class="toc-text">寄存器间接寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.1.5.</span> <span class="toc-text">基址&#x2F;变址寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80-1"><span class="toc-number">4.2.1.6.</span> <span class="toc-text">基址+变址寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.1.7.</span> <span class="toc-text">串寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io%E7%AB%AF%E5%8F%A3%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.1.8.</span> <span class="toc-text">I&#x2F;O端口寻址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">8086指令格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">8086数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">4.5.</span> <span class="toc-text">8086指令集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.1.</span> <span class="toc-text">数据传输指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4%E5%85%B1%E5%90%8C%E7%89%B9%E7%82%B9"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">数据传输指令共同特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.1.2.</span> <span class="toc-text">通用数据传输指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4mov"><span class="toc-number">4.5.1.2.1.</span> <span class="toc-text">传送指令MOV</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#mov%E6%8C%87%E4%BB%A4%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F"><span class="toc-number">4.5.1.2.1.1.</span> <span class="toc-text">MOV指令需要注意</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4push"><span class="toc-number">4.5.1.2.2.</span> <span class="toc-text">入栈指令PUSH</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BA%E6%A0%88%E6%8C%87%E4%BB%A4pop"><span class="toc-number">4.5.1.2.3.</span> <span class="toc-text">出栈指令POP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8C%87%E4%BB%A4xchg"><span class="toc-number">4.5.1.2.4.</span> <span class="toc-text">交换指令XCHG</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%AF%E5%8A%A0%E5%99%A8%E4%B8%93%E7%94%A8%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.1.3.</span> <span class="toc-text">累加器专用传输指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8C%87%E4%BB%A4in"><span class="toc-number">4.5.1.3.1.</span> <span class="toc-text">输入指令IN</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%8C%87%E4%BB%A4out"><span class="toc-number">4.5.1.3.2.</span> <span class="toc-text">输出指令OUT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8D%A2%E7%A0%81%E6%8C%87%E4%BB%A4xlat"><span class="toc-number">4.5.1.3.3.</span> <span class="toc-text">换码指令XLAT</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%9C%B0%E5%9D%80%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.1.4.</span> <span class="toc-text">目标地址传输指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#lea%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80%E4%BC%A0%E8%BE%93%E5%88%B0%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.5.1.4.1.</span> <span class="toc-text">LEA（有效地址传输到寄存器）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#lds%E8%A3%85%E5%85%A5%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">4.5.1.4.2.</span> <span class="toc-text">LDS（装入一个新的物理地址）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#les%E8%A3%85%E5%85%A5%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">4.5.1.4.3.</span> <span class="toc-text">LES（装入一个新的物理地址）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.1.5.</span> <span class="toc-text">标志寄存器传送指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.2.</span> <span class="toc-text">算术运算指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">算数运算指令的共同点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%8A%A0%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.2.2.</span> <span class="toc-text">算术加法指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%8A%A0%E6%B3%95add"><span class="toc-number">4.5.2.2.1.</span> <span class="toc-text">算术加法ADD</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E8%BF%9B%E4%BD%8D%E7%AE%97%E6%9C%AF%E5%8A%A0%E6%B3%95adc"><span class="toc-number">4.5.2.2.2.</span> <span class="toc-text">带进位算术加法ADC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A01%E6%8C%87%E4%BB%A4inc"><span class="toc-number">4.5.2.2.3.</span> <span class="toc-text">加1指令INC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E5%8E%8B%E7%BC%A9bcd%E6%95%B0%E5%8A%A0%E6%B3%95%E6%93%8D%E4%BD%9C%E7%9A%84%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E6%A0%A1%E6%AD%A3daa"><span class="toc-number">4.5.2.2.4.</span> <span class="toc-text">对压缩BCD数加法操作的结果进行校正DAA</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E9%9D%9E%E5%8E%8B%E7%BC%A9bcd%E6%95%B0%E5%8A%A0%E6%B3%95%E6%93%8D%E4%BD%9C%E7%9A%84%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E6%A0%A1%E6%AD%A3aaa"><span class="toc-number">4.5.2.2.5.</span> <span class="toc-text">对非压缩BCD数加法操作的结果进行校正AAA</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%87%8F%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.2.3.</span> <span class="toc-text">算术减法指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%87%8F%E6%B3%95sub"><span class="toc-number">4.5.2.3.1.</span> <span class="toc-text">算术减法SUB</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E8%BF%9B%E4%BD%8D%E7%AE%97%E6%9C%AF%E5%87%8F%E6%B3%95sbb"><span class="toc-number">4.5.2.3.2.</span> <span class="toc-text">带进位算术减法SBB</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F1%E6%8C%87%E4%BB%A4dec"><span class="toc-number">4.5.2.3.3.</span> <span class="toc-text">减1指令DEC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E5%8E%8B%E7%BC%A9bcd%E6%95%B0%E5%87%8F%E6%B3%95%E6%93%8D%E4%BD%9C%E7%9A%84%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E6%A0%A1%E6%AD%A3das"><span class="toc-number">4.5.2.3.4.</span> <span class="toc-text">对压缩BCD数减法操作的结果进行校正DAS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E9%9D%9E%E5%8E%8B%E7%BC%A9bcd%E6%95%B0%E5%87%8F%E6%B3%95%E6%93%8D%E4%BD%9C%E7%9A%84%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E6%A0%A1%E6%AD%A3aas"><span class="toc-number">4.5.2.3.5.</span> <span class="toc-text">对非压缩BCD数减法操作的结果进行校正AAS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4cmp"><span class="toc-number">4.5.2.3.6.</span> <span class="toc-text">比较指令CMP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%96%E8%A1%A5%E6%8C%87%E4%BB%A4neg"><span class="toc-number">4.5.2.3.7.</span> <span class="toc-text">取补指令NEG</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.2.4.</span> <span class="toc-text">算术乘法指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4mul"><span class="toc-number">4.5.2.4.1.</span> <span class="toc-text">无符号数乘法指令MUL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4imul"><span class="toc-number">4.5.2.4.2.</span> <span class="toc-text">带符号数乘法指令IMUL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%8E%8B%E7%BC%A9bcd%E6%95%B0%E4%B9%98%E6%B3%95%E7%BB%93%E6%9E%9C%E6%A0%A1%E6%AD%A3aam"><span class="toc-number">4.5.2.4.3.</span> <span class="toc-text">非压缩BCD数乘法结果校正AAM</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E9%99%A4%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.2.5.</span> <span class="toc-text">算术除法指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%99%A4%E6%B3%95%E6%8C%87%E4%BB%A4div"><span class="toc-number">4.5.2.5.1.</span> <span class="toc-text">无符号数除法指令DIV</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%99%A4%E6%B3%95%E6%8C%87%E4%BB%A4idiv"><span class="toc-number">4.5.2.5.2.</span> <span class="toc-text">带符号数除法指令IDIV</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%AD%97%E8%8A%82%E6%89%A9%E5%B1%95%E6%8C%87%E4%BB%A4cbw"><span class="toc-number">4.5.2.5.3.</span> <span class="toc-text">带符号数字节扩展指令CBW</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%AD%97%E6%89%A9%E5%B1%95%E6%8C%87%E4%BB%A4cwd"><span class="toc-number">4.5.2.5.4.</span> <span class="toc-text">带符号数字扩展指令CWD</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%8E%8B%E7%BC%A9bcd%E6%95%B0%E9%99%A4%E6%B3%95%E7%BB%93%E6%9E%9C%E6%A0%A1%E6%AD%A3aad"><span class="toc-number">4.5.2.5.5.</span> <span class="toc-text">非压缩BCD数除法结果校正AAD</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.3.</span> <span class="toc-text">位操作指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E5%85%B1%E5%90%8C%E7%89%B9%E7%82%B9"><span class="toc-number">4.5.3.1.</span> <span class="toc-text">位操作指令共同特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.3.2.</span> <span class="toc-text">逻辑运算指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E9%9D%9E%E6%8C%87%E4%BB%A4not"><span class="toc-number">4.5.3.2.1.</span> <span class="toc-text">逻辑非指令NOT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%B8%8E%E6%8C%87%E4%BB%A4and"><span class="toc-number">4.5.3.2.2.</span> <span class="toc-text">逻辑与指令AND</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%88%96%E6%8C%87%E4%BB%A4or"><span class="toc-number">4.5.3.2.3.</span> <span class="toc-text">逻辑或指令OR</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96%E6%8C%87%E4%BB%A4xor"><span class="toc-number">4.5.3.2.4.</span> <span class="toc-text">逻辑异或指令XOR</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%8C%87%E4%BB%A4test"><span class="toc-number">4.5.3.2.5.</span> <span class="toc-text">测试指令TEST</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.3.3.</span> <span class="toc-text">逻辑移位指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.3.3.1.</span> <span class="toc-text">非循环移位指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.3.3.2.</span> <span class="toc-text">循环移位指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.4.</span> <span class="toc-text">串处理指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">4.5.4.1.</span> <span class="toc-text">串处理指令共同点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E6%8C%87%E4%BB%A4%E4%BD%BF%E7%94%A8%E4%B8%80%E8%88%AC%E6%96%B9%E6%B3%95"><span class="toc-number">4.5.4.2.</span> <span class="toc-text">串指令使用一般方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cld%E5%92%8Cstd%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.4.3.</span> <span class="toc-text">CLD和STD指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4movsb%E6%88%96movsw"><span class="toc-number">4.5.4.4.</span> <span class="toc-text">串传输指令MOVSB或MOVSW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4cmpsb%E6%88%96cmpsw"><span class="toc-number">4.5.4.5.</span> <span class="toc-text">串比较指令CMPSB或CMPSW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E6%90%9C%E7%B4%A2%E6%8C%87%E4%BB%A4scasb%E6%88%96scasw"><span class="toc-number">4.5.4.6.</span> <span class="toc-text">串搜索指令SCASB或SCASW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E8%A3%85%E5%85%A5%E6%8C%87%E4%BB%A4lodsb%E6%88%96lodsw"><span class="toc-number">4.5.4.7.</span> <span class="toc-text">串装入指令LODSB或LODSW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4stosb%E6%88%96stosw"><span class="toc-number">4.5.4.8.</span> <span class="toc-text">串存储指令STOSB或STOSW</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%89%8D%E7%BC%80"><span class="toc-number">4.5.5.</span> <span class="toc-text">指令前缀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rep%E5%89%8D%E7%BC%80"><span class="toc-number">4.5.5.1.</span> <span class="toc-text">REP前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repzrepe%E5%89%8D%E7%BC%80"><span class="toc-number">4.5.5.2.</span> <span class="toc-text">REPZ&#x2F;REPE前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repnzrepne%E5%89%8D%E7%BC%80"><span class="toc-number">4.5.5.3.</span> <span class="toc-text">REPNZ&#x2F;REPNE前缀</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.6.</span> <span class="toc-text">程序控制转移指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BBjmp"><span class="toc-number">4.5.6.1.</span> <span class="toc-text">无条件转移JMP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E5%86%85%E8%BD%AC%E7%A7%BB"><span class="toc-number">4.5.6.1.1.</span> <span class="toc-text">段内转移</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E9%97%B4%E8%BD%AC%E7%A7%BB"><span class="toc-number">4.5.6.1.2.</span> <span class="toc-text">段间转移</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB"><span class="toc-number">4.5.6.2.</span> <span class="toc-text">条件转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.6.3.</span> <span class="toc-text">循环控制指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#loop"><span class="toc-number">4.5.6.3.1.</span> <span class="toc-text">LOOP</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E5%92%8C%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.6.4.</span> <span class="toc-text">子程序调用和返回指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8call"><span class="toc-number">4.5.6.4.1.</span> <span class="toc-text">子程序调用CALL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9Eret"><span class="toc-number">4.5.6.4.2.</span> <span class="toc-text">子程序返回RET</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8C%87%E4%BB%A4%E5%92%8C%E4%B8%AD%E6%96%AD%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.6.5.</span> <span class="toc-text">中断指令和中断返回指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.7.</span> <span class="toc-text">处理器控制指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86%E6%80%BB%E7%BB%93"><span class="toc-number">4.6.</span> <span class="toc-text">8086指令集总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E5%88%B0%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">4.6.1.</span> <span class="toc-text">用到的指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E7%94%A8%E7%AB%8B%E5%8D%B3%E6%95%B0%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">4.6.2.</span> <span class="toc-text">能用立即数的指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E7%94%A8%E7%AB%8B%E5%8D%B3%E6%95%B0%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">4.6.3.</span> <span class="toc-text">不能用立即数的指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%90%AB%E6%B2%A1%E6%9C%89%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">4.6.4.</span> <span class="toc-text">隐含&#x2F;没有操作数的指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A-1"><span class="toc-number">4.7.</span> <span class="toc-text">作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%8A%AF%E7%89%87"><span class="toc-number">5.</span> <span class="toc-text">8253计时器&#x2F;定时器芯片</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6"><span class="toc-number">5.1.</span> <span class="toc-text">如何实现定时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%86%B5"><span class="toc-number">5.2.</span> <span class="toc-text">8253概况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%BA%BF%E5%9B%BE"><span class="toc-number">5.3.</span> <span class="toc-text">8253引线图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E8%87%B3%E7%B3%BB%E7%BB%9F%E7%AB%AF%E7%9A%84%E4%B8%BB%E8%A6%81%E5%BC%95%E7%BA%BF"><span class="toc-number">5.3.1.</span> <span class="toc-text">连接至系统端的主要引线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E9%80%9A%E9%81%93%E7%9A%84%E4%B8%BB%E8%A6%81%E5%BC%95%E7%BA%BF"><span class="toc-number">5.3.2.</span> <span class="toc-text">计数通道的主要引线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.</span> <span class="toc-text">8253内部结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E8%AE%A1%E6%95%B0%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">5.5.</span> <span class="toc-text">8253定时&#x2F;计数工作过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">5.5.1.</span> <span class="toc-text">工作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E5%86%85%E9%83%A8"><span class="toc-number">5.5.2.</span> <span class="toc-text">通道内部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%80%BC%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">5.5.3.</span> <span class="toc-text">计数值的设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">5.6.</span> <span class="toc-text">计数启动方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">5.7.</span> <span class="toc-text">8253工作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F0%E8%AE%A1%E6%95%B0%E7%BB%93%E6%9D%9F%E4%B8%AD%E6%96%AD"><span class="toc-number">5.7.1.</span> <span class="toc-text">方式0——计数结束中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%A7%A6%E5%8F%91%E7%9A%84%E5%8D%95%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">5.7.2.</span> <span class="toc-text">方式1——可重复触发的单稳态触发器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F2%E9%A2%91%E7%8E%87%E5%8F%91%E7%94%9F%E5%99%A8"><span class="toc-number">5.7.3.</span> <span class="toc-text">方式2——频率发生器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F3%E6%96%B9%E6%B3%A2%E5%8F%91%E7%94%9F%E5%99%A8"><span class="toc-number">5.7.4.</span> <span class="toc-text">方式3——方波发生器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F4%E8%BD%AF%E4%BB%B6%E8%A7%A6%E5%8F%91%E9%80%89%E9%80%9A"><span class="toc-number">5.7.5.</span> <span class="toc-text">方式4——软件触发选通</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F5%E7%A1%AC%E4%BB%B6%E8%A7%A6%E5%8F%91%E9%80%89%E9%80%9A"><span class="toc-number">5.7.6.</span> <span class="toc-text">方式5——硬件触发选通</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-number">5.7.7.</span> <span class="toc-text">各种工作方式总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F0%E8%AE%A1%E6%95%B0%E7%BB%93%E6%9D%9F%E4%B8%AD%E6%96%AD-1"><span class="toc-number">5.7.7.1.</span> <span class="toc-text">方式0（计数结束中断）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1%E5%8D%95%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">5.7.7.2.</span> <span class="toc-text">方式1（单稳态触发器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F2%E9%A2%91%E7%8E%87%E5%8F%91%E7%94%9F%E5%99%A8-1"><span class="toc-number">5.7.7.3.</span> <span class="toc-text">方式2（频率发生器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F3%E6%96%B9%E6%B3%A2%E5%8F%91%E7%94%9F%E5%99%A8-1"><span class="toc-number">5.7.7.4.</span> <span class="toc-text">方式3（方波发生器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F4%E8%BD%AF%E4%BB%B6%E8%A7%A6%E5%8F%91%E9%80%89%E9%80%9A-1"><span class="toc-number">5.7.7.5.</span> <span class="toc-text">方式4（软件触发选通）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F5%E7%A1%AC%E4%BB%B6%E8%A7%A6%E5%8F%91%E9%80%89%E9%80%9A-1"><span class="toc-number">5.7.7.6.</span> <span class="toc-text">方式5（硬件触发选通）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gate%E4%BF%A1%E5%8F%B7%E5%8A%9F%E8%83%BD%E8%A1%A8"><span class="toc-number">5.7.8.</span> <span class="toc-text">GATE信号功能表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AD%97"><span class="toc-number">5.8.</span> <span class="toc-text">8253控制字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AD%97%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.8.1.</span> <span class="toc-text">控制字格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.9.</span> <span class="toc-text">8253初始化顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%9B%BE"><span class="toc-number">5.10.</span> <span class="toc-text">8253与系统的连接图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%BB%E5%87%BA%E5%BD%93%E5%89%8D%E8%AE%A1%E6%95%B0%E5%80%BC"><span class="toc-number">5.11.</span> <span class="toc-text">如何读出当前计数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%AE%9A%E6%97%B6%E8%AE%A1%E6%95%B0%E8%8C%83%E5%9B%B4"><span class="toc-number">5.12.</span> <span class="toc-text">扩展定时&#x2F;计数范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A-2"><span class="toc-number">5.13.</span> <span class="toc-text">8253作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%8F%AF%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E8%8A%AF%E7%89%87"><span class="toc-number">6.</span> <span class="toc-text">8255并行可编程接口芯片</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%86%B5-1"><span class="toc-number">6.1.</span> <span class="toc-text">8255概况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%BA%BF%E5%9B%BE-1"><span class="toc-number">6.2.</span> <span class="toc-text">8255引线图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E8%87%B3%E7%B3%BB%E7%BB%9F%E7%AB%AF%E7%9A%84%E4%B8%BB%E8%A6%81%E5%BC%95%E7%BA%BF-1"><span class="toc-number">6.2.1.</span> <span class="toc-text">连接至系统端的主要引线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%A4%96%E8%AE%BE%E7%AB%AF%E7%9A%84%E5%BC%95%E8%84%9A"><span class="toc-number">6.2.2.</span> <span class="toc-text">连接外设端的引脚</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-1"><span class="toc-number">6.3.</span> <span class="toc-text">8255内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E5%8F%A3%E5%8F%AF%E4%BD%9C%E4%B8%BAab%E4%B8%A4%E7%AB%AF%E5%8F%A3%E7%9A%84%E4%BF%A1%E5%8F%B7%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">6.3.1.</span> <span class="toc-text">C口可作为AB两端口的信号输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ab%E7%AB%AF%E5%8F%A3%E6%8E%A7%E5%88%B6"><span class="toc-number">6.3.2.</span> <span class="toc-text">AB端口控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF%E7%BC%93%E5%86%B2%E5%99%A8"><span class="toc-number">6.3.3.</span> <span class="toc-text">数据总线缓冲器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%9B%BE-1"><span class="toc-number">6.4.</span> <span class="toc-text">8255与系统的连接图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F-1"><span class="toc-number">6.5.</span> <span class="toc-text">8255工作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F0%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">6.5.1.</span> <span class="toc-text">方式0：基本输入&#x2F;输出方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F0%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">6.5.1.1.</span> <span class="toc-text">方式0的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1%E9%80%89%E9%80%9A%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">6.5.2.</span> <span class="toc-text">方式1：选通输入&#x2F;输出方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E9%80%9A%E8%BE%93%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">6.5.2.1.</span> <span class="toc-text">选通输入方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%8A%9F%E8%83%BD"><span class="toc-number">6.5.2.1.1.</span> <span class="toc-text">信号功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B"><span class="toc-number">6.5.2.1.2.</span> <span class="toc-text">发送数据过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%A1%E6%89%8B%E4%BF%A1%E5%8F%B7"><span class="toc-number">6.5.2.1.3.</span> <span class="toc-text">握手信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A4%E6%97%B6%E7%9A%84%E7%8A%B6%E6%80%81%E5%AD%97"><span class="toc-number">6.5.2.1.4.</span> <span class="toc-text">此时的状态字</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E9%80%9A%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">6.5.2.2.</span> <span class="toc-text">选通输出方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%8A%9F%E8%83%BD-1"><span class="toc-number">6.5.2.2.1.</span> <span class="toc-text">信号功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B-1"><span class="toc-number">6.5.2.2.2.</span> <span class="toc-text">发送数据过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%A1%E6%89%8B%E4%BF%A1%E5%8F%B7-1"><span class="toc-number">6.5.2.2.3.</span> <span class="toc-text">握手信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A4%E6%97%B6%E7%8A%B6%E6%80%81%E5%AD%97"><span class="toc-number">6.5.2.2.4.</span> <span class="toc-text">此时状态字</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">6.5.2.3.</span> <span class="toc-text">方式1的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F2%E5%8F%8C%E5%90%91%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F%E4%BB%85a%E5%8F%A3"><span class="toc-number">6.5.3.</span> <span class="toc-text">方式2：双向传输方式（仅A口）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AD%97-1"><span class="toc-number">6.6.</span> <span class="toc-text">8255控制字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AD%97%E6%A0%BC%E5%BC%8F-1"><span class="toc-number">6.6.1.</span> <span class="toc-text">控制字格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E6%8E%A7%E5%88%B6%E5%AD%97"><span class="toc-number">6.6.2.</span> <span class="toc-text">方式控制字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E5%8F%A3%E7%BD%AE%E4%BD%8D%E5%A4%8D%E4%BD%8D%E6%8E%A7%E5%88%B6%E5%AD%97"><span class="toc-number">6.6.3.</span> <span class="toc-text">C口置位&#x2F;复位控制字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%85%A5%E7%8A%B6%E6%80%81%E5%AD%97"><span class="toc-number">6.6.4.</span> <span class="toc-text">读入状态字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">7.</span> <span class="toc-text">中断</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/20/hexo%E7%9B%B8%E5%85%B3/Hexo_Nunjucks_Error%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" title="Hexo Nunjucks Error解决方法">Hexo Nunjucks Error解决方法</a><time datetime="2023-12-20T10:55:45.000Z" title="发表于 2023-12-20 18:55:45">2023-12-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="接口技术复习整理">接口技术复习整理</a><time datetime="2023-12-12T02:56:09.000Z" title="发表于 2023-12-12 10:56:09">2023-12-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/06/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/OOAD%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="OOAD复习整理">OOAD复习整理</a><time datetime="2023-12-06T13:07:25.000Z" title="发表于 2023-12-06 21:07:25">2023-12-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/09/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Raycasting%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="Raycasting学习记录">Raycasting学习记录</a><time datetime="2023-11-09T01:47:32.000Z" title="发表于 2023-11-09 09:47:32">2023-11-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/28/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%A4%A7%E4%B8%89%E4%B8%93%E4%B8%9A%E8%AF%BE%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/" title="大三专业课上机实验碰到的问题合集">大三专业课上机实验碰到的问题合集</a><time datetime="2023-10-28T09:30:26.000Z" title="发表于 2023-10-28 17:30:26">2023-10-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By WinkySpeed</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2d-widget/autoload.js"></script></body></html>