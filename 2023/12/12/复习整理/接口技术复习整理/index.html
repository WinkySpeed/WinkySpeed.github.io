<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>接口技术复习整理 | WinkySpeed's Blog</title><meta name="author" content="WinkySpeed"><meta name="copyright" content="WinkySpeed"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="接口技术复习整理 引言 本课程主要用于计算机控制 计算机控制的实质是不同信号的不同处理过程，一般经过“数据采集过程”和“过程控制”2个阶段  计算机在工业生产过程的闭环控制  总线分类 地址总线AB：用来传送CPU输出的地址信号，确定被访问的存储单元、I&#x2F;O端口。地址线的根数决定了CPU的寻址范围 CPU的寻址范围 &#x3D; \(2^n\)， n：地址线根数 数据总线DB：在CPU">
<meta property="og:type" content="article">
<meta property="og:title" content="接口技术复习整理">
<meta property="og:url" content="http://example.com/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="WinkySpeed&#39;s Blog">
<meta property="og:description" content="接口技术复习整理 引言 本课程主要用于计算机控制 计算机控制的实质是不同信号的不同处理过程，一般经过“数据采集过程”和“过程控制”2个阶段  计算机在工业生产过程的闭环控制  总线分类 地址总线AB：用来传送CPU输出的地址信号，确定被访问的存储单元、I&#x2F;O端口。地址线的根数决定了CPU的寻址范围 CPU的寻址范围 &#x3D; \(2^n\)， n：地址线根数 数据总线DB：在CPU">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/WinkySpeed%20SP%20-%20Repaired.jpg">
<meta property="article:published_time" content="2023-12-12T02:56:09.000Z">
<meta property="article:modified_time" content="2024-01-05T05:16:48.115Z">
<meta property="article:author" content="WinkySpeed">
<meta property="article:tag" content="复习整理">
<meta property="article:tag" content="接口技术">
<meta property="article:tag" content="8086">
<meta property="article:tag" content="汇编语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/WinkySpeed%20SP%20-%20Repaired.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '接口技术复习整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-05 13:16:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/WinkySpeed%20SP%20-%20Repaired.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/33703665_p0.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="WinkySpeed's Blog"><span class="site-name">WinkySpeed's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">接口技术复习整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-12T02:56:09.000Z" title="发表于 2023-12-12 10:56:09">2023-12-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-05T05:16:48.115Z" title="更新于 2024-01-05 13:16:48">2024-01-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="接口技术复习整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="接口技术复习整理">接口技术复习整理</h1>
<h1 id="引言">引言</h1>
<p>本课程主要用于计算机控制</p>
<p>计算机控制的实质是不同信号的不同处理过程，一般经过“<strong>数据采集过程</strong>”和“<strong>过程控制</strong>”2个阶段</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231213162326913.png" class title="image-20231213162326913">
<h2 id="计算机在工业生产过程的闭环控制">计算机在工业生产过程的闭环控制</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231213162408785.png" class title="image-20231213162408785">
<h2 id="总线分类">总线分类</h2>
<p>地址总线AB：用来传送CPU输出的地址信号，确定被访问的存储单元、I/O端口。地址线的根数决定了CPU的寻址范围</p>
<p>CPU的寻址范围 = <span class="math inline">\(2^n\)</span>，
n：地址线根数</p>
<p>数据总线DB：在CPU与存储器、I/O接口之间数据传送的公共通路。数据总线的条数决定CPU一次最多可以传送的数据宽度</p>
<p>控制总线CB：用来传送各种控制信号</p>
<h2 id="cpu">CPU</h2>
<p>计算机的运算中心和控制中心，提供运算、判断能力</p>
<p>构成：运算器ALU、控制器CU、寄存器组</p>
<h2 id="io接口">I/O接口</h2>
<p>输入/输出接口，简写为I/O接口，是CPU与外部设备间的桥梁，外设通过I/O接口与主机连接，与CPU实现信息传送</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231213162933839.png" class title="image-20231213162933839">
<h3 id="外设通过io接口与总线连接的原因">外设通过I/O接口与总线连接的原因</h3>
<p>CPU、内存能直接连接到总线，外设需要用I/O接口</p>
<p>一般的输入/输出设备都是机械的或机电相结合的产物，它们相对于高速的中央处理器来说，速度要<strong>慢</strong>得多</p>
<p>此外，不同外设的<strong>信号形式、数据格式</strong>也各不相同</p>
<p>因此，外部设备不能与CPU直接相连，需要通过相应的电路来完成它们之间的速度匹配、信号转换，并完成某些控制功能</p>
<h2 id="微机">微机</h2>
<h3 id="微机基本概念">微机基本概念</h3>
<p><strong>微处理器</strong>即CPU,是微型机的主要核心部件，微机和其它大、中、小型计算机的根本区别：微机的CPU由运算器和控制器<strong>集成</strong>而成</p>
<p><strong>微型计算机</strong>由微处理器、接口、I/O设备通过总线连接而成</p>
<p><strong>微型计算机系统</strong>由硬件和软件构成，硬件由微处理器、接口、I/O设备通过总线连接而成；软件由系统软件和应用软件构成。硬件是基础，软件是灵魂，计算机的功能只有在硬件基础上通过软件才能发挥</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231213163340357.png" class title="image-20231213163340357">
<h3 id="微机工作过程">微机工作过程</h3>
<p>①微机上运行高级语言程序，先须经过编译、链接生成机器语言可执行程序才能直接运行</p>
<p>②机器语言程序是按照算法运算顺序由许多机器指令按一定顺序组成的程序，即程序是由多条有逻辑关系的指令组成</p>
<p>③数据和程序均以二进制代码的形式不加区别地存放在存储器中，存放位置由二进制地址指定</p>
<p>④由控制器控制整个机器语言程序和数据的存取以及程序的执行。而指令执行由运算器完成</p>
<p><br></p>
<p>为实现自动连续地执行程序，控制器设置一<strong>程序计数器PC</strong>，它可根据指令的长度自动增量（总是指向下一条指令）</p>
<p>只要给出程序中第一条指令的地址，控制器就可依据存储程序中的指令顺序周而复始地取指令、译码、执行，直到完成全部指令操作为止，即控制器通过<strong>指令流的串行驱动</strong>实现程序控制</p>
<h3 id="微机分类">微机分类</h3>
<p>按照组装形式和系统规模，可以把微型计算机划分为单片机、单板机和个人计算机</p>
<p><strong>单片机</strong>：将CPU、部分存储器、部分I/O接口集成在一个<strong>芯片</strong>上</p>
<p><strong>单板机</strong>：将CPU、存储器、I/O接口及部分I/O设备安装在一个<strong>印刷线路板</strong>上</p>
<p><strong>个人计算机PC</strong>：在主板上连接CPU、存储器、I/O接口，再配置上外设而成</p>
<h3 id="微机组成">微机组成</h3>
<p>微机<strong>原理</strong>组成：运算器、控制器、存储器、输入设备、输出设备</p>
<p>微机<strong>物理结构（实际）</strong>组成：主机（主板、CPU、内存条、硬盘、软驱、光驱、显卡、声卡、网卡等）、外设（显示器、打印机、键盘、鼠标等）</p>
<p>微机<strong>概念</strong>组成：在总线上直接挂接上CPU、内存、I/O接口，外设通过I/O接口实现与计算机连接</p>
<h3 id="微机工作原理">微机工作原理</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231213201627715.png" class title="image-20231213201627715">
<p>运算器部件是计算机中进行数据加工的部件</p>
<p>ALU运算需２个操作数，分别来自ACC和X寄存器，运算结果保存到ACC及MQ寄存器</p>
<p><br></p>
<p>控制器完成一条指令的“取指、分析、执行”</p>
<p>控制器由控制单元CU、指令部件、时序部件、PC（Program
Counter）、IR等组成</p>
<p>指令部件由指令寄存器IR、程序计数器PC、指令译码器ID组成</p>
<p>PC存放当前欲执行指令的地址，具有计数功能</p>
<p>IR存放当前欲执行的指令</p>
<p><br></p>
<p>存储器完成程序、数据、地址码的存储，具有读出和写入两种操作</p>
<p>存储器由地址寄存器MAR、数据缓冲寄存器MDR和存储阵列组成</p>
<p>MAR存放CPU要访问的内存地址，CPU对内存单元的读写都要经过MDR传送</p>
<p><br></p>
<p>I/O系统由I/O接口和I/O设备组成</p>
<p>I/O设备完成程序、数据的I/O操作</p>
<p>I/O接口是I/O设备完成程序、数据I/O操作的中转站</p>
<p>CPU通过对I/O接口<strong>状态寄存器</strong>的读取，来了解外设的工作状态</p>
<p>I/O设备通过I/O接口接受CU发出的各种控制命令完成相应的I/O操作</p>
<h1 id="系统结构">8086系统结构</h1>
<p>在传统的CPU中，采用串行工作方式，总是先从存储器中取出下一条指令，读出一个操作数，然后执行指令，即：</p>
<p>取指→执指→取指→执指→取指→执指</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214210233323.png" class title="image-20231214210233323">
<p>CPU访问存储器(存取数据或指令)时要等待总线操作的完成</p>
<p>CPU执行指令时总线处于空闲状态</p>
<p>缺点：CPU无法全速运行</p>
<p>解决：总线空闲时预取指令，使CPU需要指令时能立刻得到</p>
<p><br></p>
<p>在8086中，这些步骤被分配给两个独立的处理单元执行：</p>
<p>指令执行部件（<strong>EU</strong>）负责执行指令</p>
<p>总线接口部件（<strong>BIU</strong>）负责取指、读出操作数和写入结果</p>
<p>这两个单元可以独立工作，大多数情况下取指令执行指令重叠进行</p>
<p>即取指过程中，指令执行部件也在工作，加快系统运算速率</p>
<p>这种方式是<strong>流水线工作方式</strong></p>
<p><br></p>
<p>EU在执行指令时不需要访存取指令，只需要从指令队列取指，并分析执行</p>
<p>如果指令执行中需要访存或I/O端口，则EU向BIU发送访存的<strong>逻辑</strong>地址，BIU根据要求形成访存<strong>物理</strong>地址，然后访问存储器或I/O端口，取得操作数后送到EU参加运算，必要时再将运算结果写会存储器</p>
<p>EU实际不与外界打交道，所有与外部有关的操作都在BIU控制下完成</p>
<h2 id="cpu结构">8086CPU结构</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214191858981.png" class title="image-20231214191858981">
<p>地址总线是20位</p>
<h3 id="cpu内部结构框图">8086CPU内部结构框图</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214191946410.png" class title="image-20231214191946410">
<h3 id="总线接口部件biubus-interfaceunit">总线接口部件BIU(Bus
InterfaceUnit)</h3>
<p>提供与外部的接口</p>
<p>数据总线 ：<strong>双向</strong>三态，16位</p>
<p>地址总线 ：<strong>单向</strong>三态，20位</p>
<h4 id="biu功能">BIU功能</h4>
<p>地址形成</p>
<p>访存并取指令</p>
<p>指令排队</p>
<p>读/写操作数</p>
<p>总线控制</p>
<h4 id="biu组成">BIU组成</h4>
<h5 id="段寄存器段基址寄存器">段寄存器（段基址寄存器）</h5>
<p>段寄存器都是16位</p>
<p>CS（Code Segment）：代码段寄存器，存放程序代码段起始地址的高16位</p>
<p>DS（Data Segment）：数据段寄存器，存放数据段起始地址的高16位</p>
<p>SS（Stack Segment）：堆栈段寄存器，存放堆栈段起始地址的高16位</p>
<p>ES（Extended
Segment）：扩展段寄存器，存放扩展数据段起始地址的高16位</p>
<h5 id="指令指针寄存器">指令指针寄存器</h5>
<p>IP（Instruction
Pointer）：指令指针寄存器，存指令在代码段中的偏移量，16位</p>
<h5 id="物理地址加法器">物理地址加法器</h5>
<p><span class="math display">\[
物理地址=段基址\times16+偏移地址
\]</span></p>
<p>乘16在二进制数的表现为左移4位</p>
<p>即相当于在16位的段基址最低位后添加4个0，再与偏移地址相加，得到20位的地址</p>
<p>例如：</p>
<p>CS=2000H，IP=003AH
则物理地址<code>CS : IP</code>就为<code>CS x 16 + IP</code>，即2003AH</p>
<p>注意：2000H，003AH，2003AH都为16进制，最后的结果2003AH换算为二进制就是5x4=20位，符合20位物理地址</p>
<p><br></p>
<p>关于<code>CS : IP</code>的解释：</p>
<p>在8086微处理器中，冒号（:）用于连接段寄存器和偏移寄存器，以形成一个完整的内存地址</p>
<p>冒号前面的部分（如CS，DS，SS，ES等）是段寄存器，它存放的是基地址</p>
<p>这个基地址需要乘以16（或者说，向左移动4位），以将它转换为20位的物理地址</p>
<p>然后，将冒号后面的部分（如IP，BX，SI，DI等）加到这个物理地址上，就得到了最终的物理地址</p>
<h5 id="指令队列">指令队列</h5>
<p>存放指令，算是缓冲的作用</p>
<p>空间为6个字节</p>
<p>但不代表只能存6条指令，因为有的指令可能不止1个字节</p>
<p>这些指令队列寄存器通过总线接口单元BIU将后继要执行的指令提前由内存提前调入其内，以加快指令读取速度</p>
<p>利用指令队列寄存器可以构成指令流水线，以提高CPU工作效率</p>
<h5 id="总线控制部件">总线控制部件</h5>
<p>主要功能是产生总线控制信号，如访问存储器或者I/O端口的读写信号等</p>
<p>总线控制逻辑部件负责对CPU全部外部引脚的操作，核心功能是控制系统总线</p>
<p>当执行单元（EU）需要与I/O设备、存储器进行数据交换时，总线控制逻辑部件会协助EU完成数据交换</p>
<h4 id="biu工作过程">BIU工作过程</h4>
<p>CS和IP形成20位地址，送地址总线、送出MEM读信号、取指令到指令队列待用（6字节）</p>
<p>当EU取走指令，则自动调整指针并补充读入，如队列满，则空闲</p>
<p>如指令中需访问MEM或IO，则BIU根据EU给出的逻辑地址形成20位物理地址，由BIU负责读/写</p>
<p>IP寄存器，如CALL指令，则把当前指令的下一条指令的IP入栈，并清队列，根据新地址取6个字节待用，JMP相类似</p>
<p>总线控制部件发出总线控制信号，完成MEM或IO的读写</p>
<h3 id="指令执行部件euexecution-unit">指令执行部件EU(Execution
Unit)</h3>
<p>提供通用寄存器阵列，都为16位</p>
<p>运算器，16位</p>
<h4 id="eu功能">EU功能</h4>
<p>译码</p>
<p>执行</p>
<h4 id="eu组成">EU组成</h4>
<h5 id="算术运算逻辑部件alu">算术运算逻辑部件ALU</h5>
<h5 id="标志寄存器frflag-register">标志寄存器FR（Flag Register）</h5>
<p>标志寄存器16位</p>
<p>标志寄存器里存的信息被称为程序状态字（Program Status Word，PSW）</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214222135576.png" class title="image-20231214222135576">
<p>9个标志位</p>
<h6 id="状态标志">状态标志</h6>
<p>CF（Carry Flag）：进位标志位</p>
<p>CF=1，则本次运算最高位（<span class="math inline">\(D_{15}\)</span>或<span class="math inline">\(D_{7}\)</span>）有进位（加法运算时）或有借位（减法运算时）</p>
<p><br></p>
<p>PF（Parity Flag）：奇偶校验标志位</p>
<p>PF=1，表示本次运算结果中有偶数个“1”；PF=0表示本次运算结果中有奇数个“1”</p>
<p><br></p>
<p>AF（Auxiliary Carry Flag）：辅助进位标志位</p>
<p>AF=1，表示运算结果的8位数据中，低4位向高4位有进位（加法运算时）或有借位（减法运算时）</p>
<p>这个标志位<strong>仅在十进制数即BCD码运算</strong>中有效</p>
<p><br></p>
<p>ZF（Zero Flag）：零标志位</p>
<p>ZF=1，表示本次运算结果为0，ZF=0，运算结果非0</p>
<p><br></p>
<p>SF（Sign Flag）：符号标志位</p>
<p>SF=1，表示本次运算结果的最高位（<span class="math inline">\(D_{15}\)</span>或<span class="math inline">\(D_{7}\)</span>）为“1”，即符号数运算结果为负，否则SF=0</p>
<p><br></p>
<p>OF（Overflow Flag）：溢出标志位</p>
<p>OF=1，表示本次算术运算结果溢出</p>
<p>溢出：字节运算的结果超出了-128 ~ 127；或者字运算超出了-32768 ~
32767</p>
<p>二进制表示：</p>
<p>字节运算的范围：10000000 ~ 01111111（8位）</p>
<p>字运算的范围：1000000000000000 ~ 0111111111111111（16位）</p>
<p><br></p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231215161907482.png" class title="image-20231215161907482">
<p>例子：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231215162403301.png" class title="image-20231215162403301">
<p>可见，超过范围OF置1，最高位为1时SF置1，产生进位CF置1</p>
<h6 id="控制标志">控制标志</h6>
<p>IF（Interrupt Flag）：中断标志位</p>
<p>IF=1，表示允许CPU响应可屏蔽中断</p>
<p>IF=0，表示CPU禁止中断</p>
<p><br></p>
<p>DF（Direction Flag）：方向标志位</p>
<p>串操作指令中，DF=0表示串操作指令地址指针自动增量，即串操作的地址由低地址向高地址进行</p>
<p>DF=1表示地址指针自动减量，即串操作的地址由高地址向低地址进行</p>
<p>DF=0，从低地址到高地址搜索</p>
<p>"串操作"是一种特殊的操作，它可以对在内存中连续存在的数据进行操作。这些操作通常是组合操作，能完成几条指令的功能</p>
<p>详情见“<a href="#explanation of String">串指令</a>”</p>
<p><br></p>
<p>TF（Trap Flag）：单步标志位</p>
<p>TF=1，表示控制CPU进入单步工作方式，这种工作方式，CPU每执行完一条指令就自动产生一次内部中断，在调试程序很有用</p>
<h5 id="通用寄存器">通用寄存器</h5>
<p>通用寄存器都是16位</p>
<p>分为两组：数据寄存器和指针变址寄存器</p>
<h6 id="数据寄存器">数据寄存器</h6>
<p>通用数据寄存器既可作为16位寄存器，也可作为8位寄存器，即把16位的寄存器分成高8位和低8位</p>
<p>低8位被命名为AL, BL, CL, DL</p>
<p>高8位被命名为AH, BH ,CH, DH</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214204202684.png" class title="image-20231214204202684">
<p><br></p>
<p>AX（Accumulator
Register）：累加器，用于存放参加运算的数据和结果，在乘、除法运算、I/O操作、BCD数运算中有着不可代替的作用</p>
<p>AX的特殊用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL		BL</span><br></pre></td></tr></table></figure>
<p>8位乘法指令，功能为寄存器<code>AL x BL</code></p>
<p>其中，一个乘数一定放在AL中，另一个乘数可以放在BL中，也可以放在BH,
CL等8位寄存器中，最后的乘积一定放在AX中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL		BX</span><br></pre></td></tr></table></figure>
<p>16位乘法指令，功能为寄存器<code>AX x BX</code></p>
<p>其中，一个乘数一定放在AX中，另一个乘数可以放在BX中，也可以放在CX,
DX等16位寄存器中，乘积一定放在DXAX中，其中DX保存高16位</p>
<p><br></p>
<p>BX（Base
Register）：基址寄存器，除了作为数据寄存器，还可存放<strong>内存的逻辑偏移地址</strong>，<strong>AX,
CX,
DX不能</strong>，即<code>[BX]</code>这个用法是合法的，但是不能用<code>[AX], [CX], [DX]</code>这样的写法</p>
<p><code>[ ]</code>这个符号给出了<strong>逻辑偏移地址</strong>，可以用来算出对应的物理地址，具体解释见“<a href="#examples of []"><code>[]</code>逻辑地址</a>”</p>
<p>BX的特殊用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV		AL,	[BX]</span><br></pre></td></tr></table></figure>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214211131144.png" class title="image-20231214211131144">
<blockquote>
<p>在汇编语言中，<code>[BX]</code>表示的是一个内存地址，这个地址的偏移量存储在BX寄存器中。例如，如果BX中存放的数是40F6H，那么<code>[BX]</code>就表示的是以“DS
* 16 + 40F6H”为地址的内存单元。</p>
<p>当我们在<strong>指令中</strong>使用<code>[BX]</code>时，我们实际上是在引用BX寄存器中存储的地址指向的内存单元的内容。例如，指令<code>MOV AX, [BX]</code>的功能是将BX中存放的数据作为一个<strong>偏移地址</strong>，段地址<strong>默认在DS中</strong>，将DS:BX处的数据送入AX中。</p>
<p>这段汇编代码<code>MOV AL, [BX]</code>的含义是将内存中的数据（以BX内容为地址）传送到AL寄存器里。也就是说，执行这条指令后，AL寄存器的内容会变得与内存
<code>[BX]</code>的内容一样。</p>
</blockquote>
<p><br></p>
<p>CX（Counter
Register）：数据寄存器，既可作为数据寄存器，又可在串指令和位移指令中计数用</p>
<p>比如C语言中的<code>for(int i=100; i &gt; 0; i--)</code>，每次循环<code>i</code>都会自减，执行100次后循环结束，在8086中称为“串操作”</p>
<p>CX的特殊用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV CX, 5    ; 设置循环次数为5</span><br><span class="line">MOV AX, 2    ; 初始化AX寄存器的值为2</span><br><span class="line"></span><br><span class="line">START_LOOP:</span><br><span class="line">    ADD AX, AX    ; 将AX寄存器的值加倍</span><br><span class="line">    LOOP START_LOOP    ; 如果CX不为0，减少CX的值并跳转到START_LOOP，否则继续执行下一条指令</span><br></pre></td></tr></table></figure>
<p><code>LOOP</code>指令对CX做减1操作，并将结果返回到CX中，再判断CX的内容，若CX不为0，则回到标号处重新执行，直到CX为0为止，执行后面的语句，相当于C语言循环控制变量<code>i--</code>到<code>0</code></p>
<p>关于汇编语言中循环控制的方法：</p>
<blockquote>
<p>在汇编语言中，循环的实现方式与C语言有所不同。在C语言中，我们可以使用各种循环结构（如for，while，do
while等）并且可以自由地增加或减少循环计数器。但在汇编语言中，循环通常是通过特定的循环指令和一个循环计数器（通常是CX或ECX寄存器）来实现的。</p>
<p>例如，汇编语言中的<code>LOOP</code>指令会自动将CX寄存器的值减1，然后检查CX是否为零。如果CX不为零，程序就会跳转到指定的位置继续执行；如果CX为零，<code>LOOP</code>指令就会结束，程序会继续执行<code>LOOP</code>指令后面的代码。因此，这种循环的行为类似于C语言中的<code>i--</code>。</p>
<p>但是，汇编语言还提供了其他的循环控制指令，如<code>LOOPE/LOOPZ</code>和<code>LOOPNE/LOOPNZ</code>，这些指令除了检查CX或ECX是否为零外，还会检查零标志（ZF）。这就为汇编语言的循环提供了更多的灵活性。</p>
<p>总的来说，虽然汇编语言的循环控制方式与C语言有所不同，但它们都提供了强大的循环控制能力。</p>
</blockquote>
<p><br></p>
<p>DX （Data
Register）：数据寄存器，除了可以作为通用数据寄存器，还在乘除法、带符号数扩展指令中有特殊作用</p>
<p>DX的特殊用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN		AL		DX</span><br></pre></td></tr></table></figure>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214215836066.png" class title="image-20231214215836066">
<p>DX存的内容可以作为端口的I/O地址，如图所示，若DX存的内容为0080H，则上述指令就是从编号为0080H的I/O端口输入一个8为数据给AL，这是常见的I/O操作，用于从外部设备读取数据</p>
<p>DX内容为<strong>I/O端口地址</strong>的功能是别的寄存器所不具备的</p>
<p><br></p>
<h6 id="指针变址寄存器">指针变址寄存器</h6>
<p>数据寄存器AX, BX, CX,
DX中，只有BX可以作为地址指针，考虑到实际编程中需要大量的地址指针，只有BX指示或寻址数组中的元素是不够的，于是8086引入了指针和变址寄存器，由SI,
DI, SP, BP组成，特殊功能是存放存储器地址</p>
<p><br></p>
<p>SI（Source
Index）：源变址寄存器，用于存放内存的逻辑偏移地址，也可存放数据</p>
<p>DI（Destination
Index）：目标变址寄存器，用于存放内存的逻辑偏移地址，也可存放数据</p>
<p>SP（Stack Pointer）：堆栈指针，用于存放栈顶的逻辑偏移地址</p>
<p>BP（Base
Pointer）：基址指针，用于存放内存的逻辑偏移地址，<strong>跟SS寄存器默认搭配</strong></p>
<p><br></p>
<p>SI, DI, BP与BX的功能差不多，但SP有明显差异，主要用于指示堆栈栈顶</p>
<h5 id="eu控制器">EU控制器</h5>
<p>取指控制及时序控制</p>
<h4 id="eu的工作过程">EU的工作过程</h4>
<p>发出控制信号，从指令队列中取出指令译码，完成执行</p>
<p>算术逻辑部件ALU完成算术运算和逻辑运算，改写PSW</p>
<p>BIU和EU可以并行工作，即流水线技术，但仅当CALL、RET及JMP等指令时，要<strong>改变执行顺序</strong>时，不能并行工作</p>
<h2 id="cpu引脚">8086CPU引脚</h2>
<p>8086CPU可以工作在最小模式和最大模式下</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231215171505623.png" class title="image-20231215171505623">
<p>由于受到当时制造工艺的限制，部分引脚采用分时复用</p>
<p>这里仅写我认为重要的，不看懂就无法理解8086工作原理的几个引脚，剩下的应该不是很重要，查手册就可以</p>
<p><br></p>
<p>AD15 - AD0（Address Data
Bus）：<strong>分时复用</strong>的地址、数据总线</p>
<p><br></p>
<p>A19/S6，A18/S5，A17/S4，A16/S3（Address/Status）：<strong>分时复用</strong>的地址、状态线</p>
<p>作为地址线用时，A19 - A16与AD15 - AD0一起构成了访存的20位地址线</p>
<p>CPU访问I/O端口时，A19 - A16保持低电平“0”</p>
<p>作为状态线用时，S6 -
S3用来输出状态信息，其中S3和S4表示当前正在使用的段寄存器名</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231215170527993.png" class title="image-20231215170527993">
<p>例如S4S3 =
10时，表示当前使用CS寄存器对存储器寻址，或当前正在对I/O端口或中断向量寻址</p>
<p>S5用来表示中断标志状态，与IF状态一致，即S5=0时禁止一切可屏蔽中断，S5=1时允许可屏蔽中断请求</p>
<p>8086工作在最小模式下时，S6恒为0</p>
<p><br></p>
<p>~BHE/S7（Bus High
Enable/Status）：总线高位有效信号（三态输出，低电平有效），表示当前高8位数据总线上的数据有效</p>
<p>低8位数据总线选通信号为AD0（偶地址）</p>
<p>~BHE/S7可以用来控制高八位的存储器或I/O接口芯片，以区分和控制存取的是一个字节还是一个字</p>
<p>例如，在偶数地址开始的一个字节存取时，~
BHE/S7为0，AD0为1（此时高8位数据总线上进行字节传送）；在奇数地址开始的一个字节存取时，~
BHE/S7为1，AD0为0（此时低8位数据总线上进行字节传送）</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217162843395.png" class title="image-20231217162843395">
<h2 id="与8088不同之处">8086与8088不同之处</h2>
<table>
<thead>
<tr class="header">
<th></th>
<th>8086</th>
<th>8088</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>外部数据总线</td>
<td>16位</td>
<td>8位</td>
</tr>
<tr class="even">
<td>指令队列</td>
<td>6字节</td>
<td>4字节</td>
</tr>
<tr class="odd">
<td>Memory和IO空间选择</td>
<td>M/IO</td>
<td>IO/M</td>
</tr>
</tbody>
</table>
<h2 id="存储器组织">8086存储器组织</h2>
<p>8086CPU的存储器是一个最多寻址1MB的存储空间，系统为每字节分配一个20位的物理地址（对应十六进制地址范围为00000H~FFFFFH）</p>
<p>存储器中，任何两个相邻的字节被定义为一个“字”</p>
<p>在一个字中，每字节都有一个地址，这两个地址中<strong>较小的一个</strong>被用来作为这个字的地址</p>
<h3 id="线性编址">线性编址</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217155444075.png" class title="image-20231217155444075">
<p>微型计算机的内存储器以<strong>字节</strong>为基本单位存储信息，每个字节占用一个存储单元，每个存储单元给定一个唯一的地址，这个地址称为物理地址，物理地址以二进制无符号整数形式从0开始编号，顺序增1</p>
<h3 id="数据存储">数据存储</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217160333677.png" class title="image-20231217160333677">
<p>一个字的起始地址可以从偶地址开始，如图里的6B07H</p>
<p>一个字的起始地址也可以从奇地址开始，如图里的3E60H</p>
<p><strong>较高地址</strong>的字节存的是该字的<strong>高8位</strong></p>
<p><strong>较低地址</strong>的字节存的是该字的<strong>低8位</strong></p>
<p>如00001H存的是6B07H的6B，00000H存的是07；00006H存的是3E60H的3E，00005H存的是60</p>
<p><br></p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217160608122.png" class title="image-20231217160608122">
<p>偶地址开始存储的是“规则字”</p>
<p>奇地址开始存储的是“非规则字”</p>
<p>对于这两种字的解释在“<a href="#explanation of two words">8086存储器组织-分体结构</a>”中有详细解释</p>
<p><br></p>
<p><strong>总结</strong>：</p>
<p>存储器中<strong>以字节为单位</strong>存储信息</p>
<p>每个存储单元有唯一的物理地址</p>
<p>存放顺序：低字节存放在低地址；高字节存放在高地址</p>
<h3 id="分段技术">分段技术</h3>
<h4 id="存储空间的分段">存储空间的分段</h4>
<p>8086系统把1MB的内存空间（地址线是20根，寻址空间为<span class="math inline">\(2^{20}=1MB\)</span>）分为若干个段，要求：</p>
<p>①每段的容量<strong>不超过64KB</strong>（寄存器只有16根数据线，可寻址<span class="math inline">\(2^{16}=64KB\)</span>）</p>
<p>②段内起始地址必须能被16整除</p>
<p>各段的功能因具体用途而定，可分为代码段、数据段、堆栈段、附加段（对应BIU内的CS,
DS, SS, ES段寄存器）</p>
<p>段内起始单元地址的高16位（<strong>低4位为0</strong>）称为段基址，段内某单元距首单元的位移量称为偏移地址/有效地址</p>
<p>例子：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217161201592.png" class title="image-20231217161201592">
<p>1234H作为段基址，则段内起始单元地址为“12340H”，多出来的低4位0可以保证段内起始单元地址能被16整除：
<span class="math display">\[
12340H = 0\times16^0+4\times16^1+3\times16^2+2\times16^3+1\times16^4
\]</span> 分段技术可以使每个存储单元都可以用两种地址表示：</p>
<p><strong>物理地址</strong>是内存中信息存储的实际地址</p>
<p><strong>逻辑地址</strong>（段基址 <code>:</code>
偏移地址）是允许在程序中编排的地址</p>
<p>CPU必须按照物理地址对对内存进行寻址，访存时首先把逻辑地址转换为物理地址，然后再对内存单元进行读/写</p>
<p><br></p>
<p>将段基址与偏移地址放入BIU的物理地址加法器就可以计算出实际物理地址</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217161803751.png" class title="image-20231217161803751">
<p><br></p>
<p>如每个段都是64K，则最多可分16个段：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217164130441.png" class title="image-20231217164130441">
<p><span class="math display">\[
1MB=2^{20}=2^{16}\times2^{4}=64KB\times16个
\]</span></p>
<p>段与段可以交差甚至重叠：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217164150131.png" class title="image-20231217164150131">
<h4 id="物理地址的形成">物理地址的形成</h4>
<p>BIU里有4个段寄存器：CS, DS, SS, ES</p>
<p>逻辑地址由段寄存器和段内偏移量寄存器组成 <span class="math display">\[
\begin{align*}
物理地址&amp;=段基址\times16+偏移地址\\
&amp;=段寄存器的值\times16+段内偏移量寄存器的值
\end{align*}
\]</span> <img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217164859557.png" class title="image-20231217164859557"></p>
<h4 id="逻辑地址的来源段寄存器与段内指针寄存器搭配使用">逻辑地址的来源（段寄存器与段内指针寄存器搭配使用）</h4>
<p><code>CS : IP</code>指向代码段（当前执行的代码的地址）</p>
<p><code>SS : SP</code>指向堆栈段（SS指向堆栈段首地址，SP指向堆栈段栈顶）</p>
<p><code>SS : BP</code>，因为后面“基址/变址寻址”用到了这个知识点，就补充在这里：BP默认是和SS搭配</p>
<p><code>DS : BX(SI, DI)</code>指向数据段（指向数据段中的特定位置）</p>
<p><code>ES : DI</code>（串操作）指向附加段</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217165722841.png" class title="image-20231217165722841">
<h3 id="分体结构">分体结构</h3>
<p>在8086系统中，存储器采用分体结构，即1MB的存储空间分为两个512KB的存储体，一个存储体中包含偶数地址，另一个存储体包含奇数地址</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217170434989.png" class title="image-20231217170434989">
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217162843395.png" class title="image-20231217162843395">
<p>可见，数据总线的高8位连接偶地址存储器，低8位连接奇地址存储器</p>
<p>地址线仅用到A19 - A1，原因是A0用于区分当前访问的是哪个存储体</p>
<p><br></p>
<p><a id="explanation of two words"></a></p>
<p>8086的有些指令是访问（读或写）字节的，有些指令是访问（读或写）字的</p>
<p>在同一时间，8086存储器中取出来的信息数量<strong>总是16位</strong>的，而且该16位数据是在存储器中以<strong>偶地址开头</strong>2字节的内容</p>
<p>当8086要访问字节时，在被读出的16位数据中，只要忽略高8位或者低8位就可以得到所需要的1字节信息，如下图(a)(b)所示：</p>
<p>当8086要访问1个字，而这个字是偶地址起始的，只需要使A0=0,
~BHE=0，就可以一次性访问到该字的内容，如下图(c)所示：</p>
<p>当8086要访问1个字，而这个字是奇地址起始的，情况就很复杂，必须对两个连续的偶地址字做<strong>两次</strong>存储器访问，每次访问<strong>忽略不要的1字节</strong>，保留剩余的1字节，然后变换得到一个完整的字信息，如下图(d)所示：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217203850572.png" class title="image-20231217203850572">
<p>8086编程并不涉及这些细节，一条指令只是访问一个特定的字节或字，细节操作是在处理器的控制下自动实现的</p>
<p>综上，在字访问的情况下，对奇地址存放的字需要进行两次读/写操作，对偶地址存放的字仅需一次读/写操作</p>
<p>为了加快程序的运行速度，希望被访问的存储器的字地址为偶地址，所以偶地址起始的字称为“对准字”或“规则字”，奇地址起始的字称为“非对准字”或“非规则字”</p>
<h4 id="相邻两个单元字的读写">相邻两个单元（字）的读写</h4>
<h5 id="偶地址为低字节的字的读写">偶地址为低字节的字的读写</h5>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217211531747.png" class title="image-20231217211531747">
<p>奇偶存储体都是低电平有效</p>
<p>A0=0, ~BHE=0使得奇偶存储体都有效，再根据A19 - A1获取相应地址</p>
<p>这样数据总线可以一次从奇偶两个存储体读/写16位数据，即一次访存读/写一整个字</p>
<h5 id="奇地址为低字节的字的读写">奇地址为低字节的字的读写</h5>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217212242001.png" class title="image-20231217212242001">
<p>可见奇地址为低字节的两个连续字节形成的字，物理地址最后几位不像偶地址低字节一样仅差一位，奇地址低字节物理地址后三位有差别，所以不能在一次访存中获取这两个字节</p>
<p>于是就需要两次访存，第一次拿出8位的奇字节，第二次拿出8位的偶字节，这样才能拼出完整的字</p>
<p>一次访存是操作16位的数据，所以每次都会舍弃8位不需要的数据</p>
<h4 id="堆栈">堆栈</h4>
<p>SS指向堆栈段首地址</p>
<p>SP指向当前栈顶</p>
<p>8086的堆栈是“向下增长”的，具体来说，栈的空间是从<code>SS : SP</code>指向的地址开始，向低地址方向延伸</p>
<p>举个例子：假设栈初始化为这样：SS=1000H，SP=0100H</p>
<p>假设这个时候栈为空，什么都没存，则说明这个堆栈段最大就只能存0100H个字节，即从<code>SS : SP</code>开始延伸，最大延伸到<code>SS : 0000H</code></p>
<p>在8086中，<code>PUSH</code>和<code>POP</code>指令都是对16位寄存器或存储器两单元的操作数来操作的，但是内存空间（包括栈空间）是以字节（8位）为单位进行存储的，所以无论进栈或出栈，都要使用栈空间的<strong>两个字节</strong>；同时也要注意高地址放高字节，低地址放低字节</p>
<p>此时对栈进行压栈操作，SP的值会减少2个字节，即<code>0100H - 2H = 00FEH</code></p>
<p>同理，出栈操作，SP的值会增加2个字节，即<code>00FEH + 2H = 0100H</code></p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217225714156.png" class title="image-20231217225714156">
<p>工作过程图解：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219110742329.png" class title="image-20231219110742329">
<h2 id="作业">8086作业</h2>
<p>在某系统中，已知当前（SS）=2360H，（SP）=0800H，请说明该堆栈段在存储器中的物理地址范围。若往堆栈中存放20字节数据，那么SP的内容为什么值？</p>
<p><strong>答</strong>：（SS）&lt;&lt;
4＋（SP）＝23600H＋0800H＝23E00H（见图2-10），堆栈段在存储器中的物理地址范围是23600H～23E00H。若往堆栈中存入20个字节数据，那么SP的内容为0800H－14H＝07ECH。（20的十六进制为14H）</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231223194725025.png" class title="image-20231223194725025">
<p><br></p>
<p>已知当前数据段位于存储器的B4000H~C3FFFH范围内，则DS段寄存器的内容为多少？</p>
<p><strong>答</strong>：段寄存器DS的内容为B400H</p>
<p><br></p>
<p>若已知当前（DS）=7F06H，在偏移地址为0075H开始的存储器中连续存放6字节的数据，分别为11H、22H、33H、44H、55H和66H。请指出这些数据在存储器中的物理地址。如果要从存储器中读出这些数据，需要访问几次存储器？各读出哪些数据？</p>
<p><strong>答</strong>：物理地址：7F06H&lt;&lt;4＋0075H＝7F0D5H（见图2-10），故从7F0D5H起６个地址数据在存储器中的地址为：</p>
<p>7F0D5H：11H</p>
<p>7F0D6H：22H</p>
<p>7F0D7H：33H</p>
<p>7F0D8H：44H</p>
<p>7F0D9H：55H</p>
<p>7F0DAH：66H</p>
<p>由于是从奇地址（7F0D5H）开始存放，至少需要4次读存储器操作，分别是：读出11H，3322H，5544H和66H。（注意：数据的低位在低地址存储，数据的高位在高地址存储。）</p>
<p>具体过程参考“<a href="#explanation of two words">8086存储器组织-分体结构</a>”里面“访问一个字”的说明</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231223194827690.png" class title="image-20231223194827690">
<h1 id="指令系统">8086指令系统</h1>
<h2 id="指令的特点">8086指令的特点</h2>
<h3 id="灵活的指令格式">1.灵活的指令格式</h3>
<p>指令由<strong>操作码</strong>和<strong>操作数</strong>组成</p>
<p>操作码一般有1~2字节</p>
<p>操作数：参加操作的数或者数<strong>所在位置（地址码）</strong></p>
<p>操作数部分一般有0~4字节</p>
<h3 id="指令格式的一对多形式">2.指令格式的一对多形式</h3>
<p>例如JE/JZ 都表示ZF=1时转移</p>
<h3 id="较强的运算指令">3.较强的运算指令</h3>
<p>有专用的乘法、除法指令</p>
<h3 id="指令有极强的寻址能力">4.指令有极强的寻址能力</h3>
<p>寻址方式有多种</p>
<h3 id="指令有处理多种数据的能力">5.指令有处理多种数据的能力</h3>
<p>处理8位/16位、带符号数/无符号数以及压缩BCD数/非压缩BCD数</p>
<h2 id="指令寻址方式">8086指令寻址方式</h2>
<p>“寻址方式”是<strong>指令寻找操作数</strong>的方法</p>
<p>8086CPU指令中的操作数有一个或两个，个别还有三个</p>
<p>操作数分为分为<strong>源操作数</strong>和<strong>目的操作数</strong></p>
<p>比如数据传输指令：<code>MOV  目的操作数, 源操作数</code></p>
<p>目的操作数不允许立即寻址（立即数）</p>
<h3 id="寻址方式">寻址方式</h3>
<p>总共八种寻址方式：</p>
<p>立即寻址</p>
<p>寄存器寻址</p>
<p>直接寻址</p>
<p>寄存器间接寻址</p>
<p>基址/变址寻址</p>
<p>基址+变址寻址</p>
<p>串寻址</p>
<p>I/O端口寻址</p>
<h4 id="立即寻址">立即寻址</h4>
<p>立即寻址，<strong>操作数就在指令中</strong>，紧跟着操作码后面，作为指令的一部分存放在内存的代码中，这种操作数被称为“立即数”</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV    AX, 34EAH</span><br><span class="line">MOV    BL, 20</span><br></pre></td></tr></table></figure>
<p>第一句是把16位的十六进制源操作数34EAH存入AX中</p>
<p>第二句是把8位的十进制数20存入BL中（具体几位得看对应的寄存器位数）</p>
<p>注意区分进制，二进制会在末尾写B，八进制会在末尾写O，十六进制会在末尾写H</p>
<p>十进制一般末尾就没有字母</p>
<h4 id="寄存器寻址">寄存器寻址</h4>
<p>如果<strong>操作数在寄存器中</strong>，指令中源操作数和目的操作数就可以用寄存器寻址</p>
<p>16位的操作数，寄存器可以是AX, BX, CX, DX, SI, DI, SP,
BP这些16位的通用寄存器</p>
<p>8位的操作数，寄存器可以是AL, BL, CL, DL, AH, BH, CH,
DH这些8位的通用寄存器</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV     BP,	SP</span><br></pre></td></tr></table></figure>
<p>这一句会把寄存器SP的值存入寄存器BP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV   	AX,	1234H</span><br><span class="line">MOV  	AL,	AH</span><br></pre></td></tr></table></figure>
<p>这两句会把16位的1234H存入AX，再把高8位AH的内容存入低八位AL</p>
<p>也就是说最后AX的内容是1212H</p>
<h4 id="直接寻址">直接寻址</h4>
<p><a id="examples of []"></a></p>
<p>当<strong>操作数在内存单元里</strong>时，在指令中必须给出被访问内存单元的逻辑地址，再被8086转化为物理地址，才能对选中的内存单元读或写</p>
<p>指令中的源操作数或目的操作数采用“<strong>直接给出被访问内存单元的逻辑地址</strong>”这种方式时，被称为“直接寻址”</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV   AX, [3E4CH]</span><br></pre></td></tr></table></figure>
<p>源操作数采用直接寻址方式，指令中用“<code>[ ]</code>”内给出来的内容是被访问内存单元的<strong>逻辑偏移地址</strong>，逻辑段地址隐含在DS寄存器内</p>
<p>也就是说，这段指令实现的功能是：取出物理地址为“DS * 10H +
3E4CH”内存单元里的数据，存入AX寄存器中</p>
<p>又比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV  [1234H], BL</span><br></pre></td></tr></table></figure>
<p>目的操作数采用直接寻址方式</p>
<p>将寄存器BL里的8位数据传递到逻辑地址1234H，物理地址为“DS * 10H
+1234H”的内存单元中</p>
<p>又比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV  ES:[1234H], BL</span><br></pre></td></tr></table></figure>
<p>给出了ES寄存器，所以目的操作数的物理地址就是“ES * 10H +1234H”</p>
<p>指定一个非默认的段，这种方式叫“<strong>段超越</strong>”</p>
<p><br></p>
<p>以上例子中，指令的直接地址是用十六进制数形式给出的，但实际编程中，一般用符号地址，即实现定义好的符号表示逻辑偏移地址（相当于一个存了逻辑偏移地址的变量）</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		AX, BUFF</span><br><span class="line">MOV		ES:BUFF, BL</span><br></pre></td></tr></table></figure>
<p>功能和上面一样，只是偏移地址用了<code>BUFF</code>这个变量表示</p>
<p><br></p>
<p>默认关系：CS:IP、SS:SP、DS:BX、DS:SI、DS:DI、DS和直接偏移</p>
<h4 id="寄存器间接寻址">寄存器间接寻址</h4>
<p>当<strong>操作数在内存单元里</strong>时，可以使用这种方式</p>
<p>与直接寻址不同的是：内存单元的逻辑偏移地址通过间接的方式给出，即先将被访问内存单元的逻辑偏移地址<strong>传送给寄存器</strong>，在指令中再由<strong>寄存器给出被访问的内存单元的逻辑偏移地址</strong></p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV   SI, 61A8H</span><br><span class="line">MOV   DX, [SI]</span><br></pre></td></tr></table></figure>
<p>先把61A8H这个16位数给SI寄存器</p>
<p>再用<code>[]</code>给出逻辑偏移地址，即把SI寄存器里存的61A8H当做偏移地址</p>
<p>也就是说，这段指令的作用是把物理地址“DS * 16 +
61A8H”的内容送入DX寄存器中</p>
<p>注：AX、CX、DX不能在寄存器间接寻址中使用，也就是说不能用<code>[AX], [CX], [DX]</code>这样的写法</p>
<h4 id="基址变址寻址">基址/变址寻址</h4>
<p>方便<strong>一维表格数据</strong></p>
<p>基址/变址方式提出了“<strong>位移量</strong>”的概念，即在寄存器间接寻址给出的地址信息上再加一个相对位移量，也称为“<strong>相对寻址</strong>”</p>
<p>位移量是一个带符号的16位十六进制数</p>
<p>当使用寄存器BX或BP(Base
Pointer，基址指针，通常与SS搭配)时，称为“<strong>基址寻址</strong>”</p>
<p>当使用寄存器SI或DI时，称为“<strong>变址寻址</strong>”</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV   CX, 36H[BX]		;基址寻址</span><br></pre></td></tr></table></figure>
<p>这一句也可以写成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV   CX, [BX+36H]		;基址寻址</span><br></pre></td></tr></table></figure>
<p>所以，源操作数对应的物理地址为“DS * 10H + BX + 36H”</p>
<p>又比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV   -20[BP], AL		;基址寻址</span><br></pre></td></tr></table></figure>
<p>注意：<code>BP</code>寄存器默认和<strong>SS</strong>寄存器搭配，并且给的是20，是十进制</p>
<p>所以这里的物理地址计算为：“SS * 10H + BP - 14H”</p>
<h4 id="基址变址寻址-1">基址+变址寻址</h4>
<p>可以使用<strong>段超越</strong>，适用于<strong>二维表</strong></p>
<p>有效地址由三部分组成：“基址寄存器BX” 或 “BP”的内容 +
变址寄存器SI或DI的内容 + 位移量</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV   AX,	8AH[BX][SI]  </span><br><span class="line">MOV   AX,	[BX+SI+8AH]    </span><br></pre></td></tr></table></figure>
<p>以上两句等价</p>
<p>物理地址为：“DS * 10H + BX + SI + 8AH”</p>
<h4 id="串寻址">串寻址</h4>
<p>串寻址仅在8086串指令中用</p>
<p>串指令的操作数由其他指令提供，且操作数在内存单元中</p>
<p>源操作数逻辑地址DS : SI，目的操作数的逻辑地址ES : DI</p>
<p>由DF（方向标志），自动调整SI和DI</p>
<h4 id="io端口寻址">I/O端口寻址</h4>
<p>当操作数在外部设备时使用I/O指令</p>
<p>外部设备的地址叫做<strong>端口地址</strong></p>
<p>当外部设备地址用<strong>8位</strong>寻址时，<strong>直接端口寻址</strong>方式，这种寻址方式I/O地址仅有256个（00H
- FFH，高8位全为0）</p>
<p>当外部设备地址用<strong>16位</strong>寻址时，<strong>寄存器（DX）间接寻址</strong>方式</p>
<p><br></p>
<p>由于外部设备的数据宽度不同，输入指令中目的操作数可以为AL（8位）或AX（16位），输出指令同理</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN    AL, 25H</span><br></pre></td></tr></table></figure>
<p>将端口地址为25H的输入设备中8位数据送到AL中</p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		DX, 3E4H</span><br><span class="line">OUT  	DX, AL</span><br></pre></td></tr></table></figure>
<p>先把03E4H写进DX（用作间接寻址寄存器），再把AL寄存器的内容输出到端口地址为3E4H的外设</p>
<h2 id="指令格式">8086指令格式</h2>
<p>单操作数指令</p>
<p>双操作数指令</p>
<p>三操作数指令（其中一个操作数隐藏在操作码中）</p>
<p>三操作数指令如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC		AX, BX</span><br></pre></td></tr></table></figure>
<p>该指令完成操作数AX, BX和CF位（进位Flag，被隐藏）相加</p>
<p>又比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDS		SI, [BX]</span><br></pre></td></tr></table></figure>
<p>源操作数<code>DS:[BX]</code>组成的物理地址的连续4个字节分别存入SI和DS（被隐藏）中</p>
<h2 id="数据类型">8086数据类型</h2>
<p>(1)无符号数：8位和16位</p>
<p>(2)带符号数：8位和16位</p>
<p>(3)ASCII：在程序中用单引号括起来</p>
<p>(4)BCD数：压缩BCD和非压缩BCD</p>
<p>压缩BCD码：一个字节表示<strong>两位</strong>十进制数，如56的压缩BCD就是<code>0101_0110B</code></p>
<p>非压缩BCD码：一个字节表示<strong>一位</strong>十进制数，其中高4位为0，低4位存放个位，比如5的非压缩BCD就是<code>0000_0101B</code></p>
<h2 id="指令集">8086指令集</h2>
<p>按功能分为六种：数据传输类、算术运算类、逻辑运算类（位操作）、串操作类、程序控制类（CS：IP）、处理机控制类</p>
<h3 id="数据传输指令">数据传输指令</h3>
<p>数据传输指令实现存储器和寄存器、寄存器和寄存器、AX或AL寄存器与I/O端口之间的字节型或字型数据的传输</p>
<h4 id="数据传输指令共同特点">数据传输指令共同特点</h4>
<p>除了<code>POPF</code>和<code>SAHF</code>指令，这类指令的操作结果<strong>不会影响FR寄存器中的标志</strong></p>
<p>指令中有两个操作数，目的操作数和源操作数，执行过程为：源操作数→目的操作数；当指令中仅存在一个操作数时，另一个操作数为隐含</p>
<h4 id="通用数据传输指令">通用数据传输指令</h4>
<p>8086有4个通用数据传输指令：<code>MOV, PUSH, POP, XCHG</code>，除了<code>XCHG</code>，都可以以段寄存器为操作数，这是其他类型指令无法实现的</p>
<h5 id="传送指令mov">传送指令<code>MOV</code></h5>
<p>指令格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV		目的操作数,	源操作数</span><br></pre></td></tr></table></figure>
<p><code>MOV</code>指令有三种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV		Register, oprd		;以寄存器r为目的操作数</span><br><span class="line"></span><br><span class="line">MOV		mem, oprd			;以存储器mem为目的操作数</span><br><span class="line"></span><br><span class="line">MOV		seg, oprd			;以段寄存器seg为目的操作数</span><br></pre></td></tr></table></figure>
<p>具体过程如下图：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231224092706350.png" class title="image-20231224092706350">
<p>以寄存器r为目的操作数时，源操作数可以是：寄存器r、存储器mem、段寄存器seg、立即数im（通用寄存器可以从通用寄存器里拿数据）</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV 	CL, AH			;源操作数为寄存器r</span><br><span class="line">MOV 	AL, 12H			;源操作数为立即数im</span><br><span class="line">MOV 	AX, [BX+1]		;源操作数为存储器mem</span><br><span class="line">MOV 	BX, DS			;源操作数为段寄存器seg</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>以存储器mem为目的操作数时，源操作数可以是：寄存器r、段寄存器seg、立即数im（<strong>没有mem</strong>，图上mem不能指向自己，也就是说存储器mem不能从mem拿数据）</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV		[BX], 1234H			;源操作数为立即数im</span><br><span class="line">MOV 	[SI+5], BL			;源操作数为寄存器r</span><br><span class="line">MOV 	[BX+SI+10], DS		;源操作数为段寄存器seg</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>以段寄存器seg为目的操作数时，源操作数可以是：寄存器r、存储器mem（<strong>没有立即数im和段寄存器seg</strong>）</p>
<p>这里的seg<strong>不包括代码段段寄存器CS</strong></p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV DS, AX		;源操作数为寄存器r</span><br><span class="line">MOV ES, [SI+5]	;源操作数为存储器mem</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>编程时尽量采用寄存器变量</p>
<p><br></p>
<h6 id="mov指令需要注意"><code>MOV</code>指令需要注意</h6>
<p>寄存器<strong>不包括IP</strong></p>
<p>目的操作数<strong>不允许使用段寄存器CS</strong>（指令涉及CS时要小心，执行这条语句后会改变CS的值，使一个新的段成为代码段，但此时IP的值还是没变，所以在改变CS的同时也应该改变IP的值）</p>
<p>目的操作数<strong>不能是立即数</strong>（只有变量才能被赋值）</p>
<p>立即数<strong>不能直接送到段寄存器</strong>，如果需要，就通过其他寄存器传送</p>
<p>源操作数和目的操作数的数据类型<strong>必须相同</strong>：比如指令<code>MOV    AL, BX</code>就是错误的，BX是16位，AL只有8位；又比如，指令<code>MOV   [BX], 12H</code>也是错误的，因为立即数<code>12H</code>可能是8位，也可能是16位，在<code>MOV   [BX], 12H</code>时没有进行说明（用<code>byte ptr</code>或<code>word ptr</code>）</p>
<p>不允许在两个存储单元中直接传送数据，如果需要，就要通过寄存器传输</p>
<p>源操作数和目的操作数不可同时为段寄存器</p>
<p><br></p>
<p>为了说明数据是8位的，可用下面的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		[BX],	byte ptr 12H</span><br><span class="line">MOV		byte ptr [BX],	12H</span><br></pre></td></tr></table></figure>
<p><code>byte ptr</code>说明后面的对象是8位操作数</p>
<p><br></p>
<p>为了说明数据是16位的，可用下面的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		[BX],	word ptr 12H</span><br><span class="line">MOV		word ptr [BX],	12H</span><br></pre></td></tr></table></figure>
<p><code>word ptr</code>说明后面的对象是16位操作数，此时<code>word ptr 12H</code>就是<code>0012H</code></p>
<h5 id="入栈指令push">入栈指令<code>PUSH</code></h5>
<p>指令格式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH	oprd</span><br></pre></td></tr></table></figure>
<p>堆栈操作总是对<strong>16位数据</strong>进行，指令中目的操作数隐含为堆栈</p>
<p>进栈操作把数据传输到以SS为段基址、SP为偏移地址的栈中，具体过程如下：</p>
<ol type="1">
<li><p>SP先减2，指向新的栈顶</p></li>
<li><p>oprd存入<code>SS : SP</code>指向的栈顶，完成进栈操作</p></li>
</ol>
<p><code>PUSH</code>的源操作数oprd，可以是<strong>除了立即数以外的变量</strong>，即通用寄存器r，存储器mem，段寄存器seg</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH	BX</span><br><span class="line">PUSH 	[BX]</span><br><span class="line">PUSH 	DS   </span><br></pre></td></tr></table></figure>
<h5 id="出栈指令pop">出栈指令<code>POP</code></h5>
<p>指令格式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POP		oprd</span><br></pre></td></tr></table></figure>
<p>目的操作数隐含为堆栈</p>
<p>出栈操作把以SS为段基址、SP为偏移地址的栈顶内容传输到目的操作数中，具体过程如下：</p>
<ol type="1">
<li><p>将<code>SS : SP</code>指示的栈顶2字节内容传输到目的操作数中</p></li>
<li><p>SP加2，指向新栈顶，完成出栈</p></li>
</ol>
<p><code>POP</code>的源操作数oprd，可以是<strong>除了立即数以外的变量</strong>，即通用寄存器r，存储器mem，段寄存器seg（也不能是CS）</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POP		AX</span><br><span class="line">POP		[BX+SI+100H]</span><br><span class="line">POP		ES   </span><br></pre></td></tr></table></figure>
<h5 id="交换指令xchg">交换指令<code>XCHG</code></h5>
<p>XCHG（Exchange）</p>
<p>指令格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XCHG	r, oprd</span><br></pre></td></tr></table></figure>
<p>完成目的操作数和源操作数的内容互换</p>
<p>上述指令执行时数据交换，属于变量赋值所以oprd可以是通用寄存器r，存储器mem，操作数不能是立即数</p>
<p>源操作数和目的操作数不能同时为mem</p>
<p>段寄存器seg不能作为操作数</p>
<p><br></p>
<p>如果需要将字型数据偏移地址为2040H单元和2050单元的内容交换：</p>
<p>方案一：<code>MOV</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, [2040H]   </span><br><span class="line">MOV	BX,	[2050H]</span><br><span class="line">MOV [2050H], AX</span><br><span class="line">MOV [2040H], BX</span><br></pre></td></tr></table></figure>
<p>方案二：<code>XCHG</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, [2040H]   </span><br><span class="line">XCHG AX, [2050H]</span><br><span class="line">MOV [2040H], AX</span><br></pre></td></tr></table></figure>
<p>方案三：<code>PUSH, POP</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUSH [2040H]</span><br><span class="line">PUSH [2050H]</span><br><span class="line">POP  [2040H]</span><br><span class="line">POP  [2050H]</span><br></pre></td></tr></table></figure>
<h4 id="累加器专用传输指令">累加器专用传输指令</h4>
<p>8086与外部设备交换数据，必须通过累加器AX或AL传输给I/O端口，外设从输出端口取数据，完成数据输出</p>
<p>反之，则外设需要将数据传到I/O端口，CPU从端口中取数据到AX,
AL中，完成数据输入</p>
<h5 id="输入指令in">输入指令<code>IN</code></h5>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN	a, oprd</span><br></pre></td></tr></table></figure>
<p><code>IN</code>指令把oprd指示的端口内容传输到累加器a</p>
<p>目的操作数为累加器a，代表16位的AX和8位的AL，源操作数是I/O端口地址</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IN  AL, 80H      ;0080H作为地址，不需要加[]表示地址</span><br><span class="line">IN  AL, DX</span><br><span class="line">IN  AX, 80H</span><br><span class="line">IN  AX, DX</span><br></pre></td></tr></table></figure>
<p>注意：在<code>MOV</code>指令中，表示地址的一般都用<code>[ ]</code>表示逻辑地址，比如<code>[0080H]</code>，因为在<code>MOV</code>指令中的<code>0080H</code>作为立即数，所以需要加<code>[ ]</code>表明是地址；而<code>IN</code>指令中，源操作数已经被指定为地址，所以就不需要加<code>[ ]</code>强调地址了</p>
<p>即：<code>IN  AL, 80H</code>这句表示的是从端口地址为<code>80H</code>的接口输入数据给AL，采用直接寻址</p>
<p>端口地址若是超过8位，应使用DX间接寻址</p>
<h5 id="输出指令out">输出指令<code>OUT</code></h5>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OUT		oprd, a</span><br></pre></td></tr></table></figure>
<p><code>OUT</code>指令把累加器a的内容传送到oprd指定的端口，目的操作数是I/O端口地址</p>
<p>输出设备的端口地址若是<strong>超过8位，应使用DX间接寻址</strong></p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OUT		3EBH, AX	;错的</span><br></pre></td></tr></table></figure>
<p>这里端口地址为3EBH，超过8位，应该换DX间接寻址</p>
<p>修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		DX,	3E8H</span><br><span class="line">OUT		DX,	AX</span><br></pre></td></tr></table></figure>
<h5 id="换码指令xlat">换码指令<code>XLAT</code></h5>
<p>XLAT（Translate）</p>
<p>指令格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XLAT</span><br></pre></td></tr></table></figure>
<p>这个指令没有明显的操作数，因此是隐含寻址，涉及的寄存器有AL和BX</p>
<p>其功能为：以BX的内容加AL的内容构成数据段中的一个地址（<code>[BX + AL]</code>），然后从这个地址中取数给AL</p>
<p>所谓“换码”，是指令能够完成1字节的查表转换</p>
<p>有时需要将一种代码换成另一种代码，或在实际问题中采用映射关系来实现转换</p>
<p><br></p>
<p>因为涉及到BX和AL两个寄存器，所以这条指令执行前，需要改变BX,
AL两个寄存器的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		BX,	表的偏移首地址</span><br><span class="line">MOV		AL,	被转换码</span><br></pre></td></tr></table></figure>
<p><code>XLAT</code>指令不能单独执行，所以有时被称为“复合指令”</p>
<p><br></p>
<p>例如：建立一个0~9的平方表，求5的平方值</p>
<p>将0~9的平方表建立在偏移地址为2000H的内存中</p>
<p>完成求5的平方指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV		BX,	2000H	;指向平方表首地址</span><br><span class="line">MOV		AL,	5		;把5放入AL</span><br><span class="line">XLAT				;执行换码指令，先求BX + AL得到5平方对应的地址，再把这个地址存的数据放入AL</span><br></pre></td></tr></table></figure>
<p>这个例子仅仅为<code>XLAT</code>指令设计</p>
<h4 id="目标地址传输指令">目标地址传输指令</h4>
<p>目标地址传输指令是计算有效地址的指令，有效地址是指存储器地址</p>
<p>因此在这类指令中，源操作数必须是存储器</p>
<h5 id="lea有效地址传输到寄存器"><code>LEA</code>（有效地址传输到寄存器）</h5>
<p>LEA（Load Effective Address）</p>
<p>指令格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEA		r,	mem</span><br></pre></td></tr></table></figure>
<p>指令的功能是：取mem指示的地址（这里就是偏移地址）送寄存器r</p>
<p>注意：r是16位</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEA		SI, [2040H]</span><br></pre></td></tr></table></figure>
<p>指令执行后，SI的内容为2040H，也就是取了这个偏移地址，存到SI寄存器中</p>
<p>对比：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV		SI, [2040H]</span><br></pre></td></tr></table></figure>
<p><code>MOV</code>指令执行后，SI内容为偏移地址2040H内存单元存的内容，而不2040H这个值</p>
<p><br></p>
<p>也就是说，<code>LEA</code>这个指令用于取mem的偏移地址，然后存入r中</p>
<p><br></p>
<p><strong>基本上从<code>DATA</code>段拿数组都是<code>LEA</code></strong></p>
<p><br></p>
<h5 id="lds装入一个新的物理地址"><code>LDS</code>（装入一个新的物理地址）</h5>
<p>LDS（Load DS）</p>
<p>指令格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDS		r,	mem</span><br></pre></td></tr></table></figure>
<p><code>LDS</code>指令是三操作数指令，其中有两个目的操作数</p>
<p>功能是：将源操作数指示的偏移地址开始的<strong>4个连续字节</strong>的内容传输到<strong>目的寄存器r</strong>和<strong>数据段寄存器DS</strong>中</p>
<p>r是16位</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV  BX, 2080H     ;用BX间接寻址</span><br><span class="line">LDS  SI, [BX]      ;SI←[2080H], DS←[2082H]</span><br><span class="line">MOV  AL, [SI]      ; AL = 88H </span><br></pre></td></tr></table></figure>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231224113311006.png" class title="image-20231224113311006">
<p>如图，先从“DS * 10H + 2080H”的物理地址中取出内容给SI</p>
<p>再从“DS * 10H + 2082H”的物理地址中取出内容给DS（即更新了DS）</p>
<p>于是再用<code>MOV  AL, [SI]</code>时，就是从新的DS开始计算物理地址“DS
* 10H + 001EH”，内容为88H，就存入AL</p>
<h5 id="les装入一个新的物理地址"><code>LES</code>（装入一个新的物理地址）</h5>
<p>LES（Load ES）</p>
<p>与<code>LDS</code>指令类似，只是段寄存器为ES而不是DS</p>
<h4 id="标志寄存器传送指令">标志寄存器传送指令</h4>
<p>FR寄存器是个特殊的寄存器，虽然是16位，但8086中只用了9位</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214222135576.png" class title="image-20231214222135576">
<p>对FR的操作与其他寄存器不一样，指令形式特点为：操作数都是隐含的</p>
<p>其中8位的传输是对SF, ZF, AF, PF和CF操作</p>
<p><code>LAHF</code>：FR寄存器的低8位存入AH</p>
<p><code>SAHF</code>：AH存入FR寄存器的低8位</p>
<p><code>PUSHF</code>：FR寄存器内容入栈</p>
<p><code>POPF</code>：从栈顶弹出内容存入FR寄存器</p>
<p><br></p>
<p>利用标志寄存器传送指令，特别是入栈、出栈指令，可以实现对FR寄存器的一些特殊操作要求</p>
<p>比如：对FR寄存器中的TF标志位（第9位）置1，其他位不变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUSHF				;FR寄存器内容入栈</span><br><span class="line">POP		AX			;FR寄存器内容存入AX</span><br><span class="line">OR		AX,	0200H	;或操作，实现第九位（0000_0010_0000_0000B）置1，然后存入AX中</span><br><span class="line">PUSH	AX			;更新完的AX入栈</span><br><span class="line">POPF				;更新的AX出栈，弹出到FR寄存器，完成操作</span><br></pre></td></tr></table></figure>
<h3 id="算术运算指令">算术运算指令</h3>
<h4 id="算数运算指令的共同点">算数运算指令的共同点</h4>
<p>运算指令<strong>影响状态标志</strong></p>
<p>参加运算的数可以是无符号整型数、带符号整型数、压缩BCD数和非压缩BCD数</p>
<p>乘法/除法指令中，乘数、被乘数以及除数、被除数、商和余数的存放位置有规定</p>
<p>乘法和除法指令的书写形式有要求</p>
<h4 id="算术加法指令">算术加法指令</h4>
<h5 id="算术加法add">算术加法<code>ADD</code></h5>
<p>指令功能：<code>目的操作数 ←- 目的操作数 + 源操作数</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD		目的操作数,	源操作数</span><br></pre></td></tr></table></figure>
<p>这个格式可以展开两种加法指令：</p>
<p>以通用寄存器r为目的操作数，源操作数可以是通用寄存器r，存储器mem，立即数im</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD  AX, BX</span><br><span class="line">ADD  BX, [BP+SI+1000H]</span><br><span class="line">ADD  AL, 12H</span><br></pre></td></tr></table></figure>
<p>以存储器mem为目的操作数，源操作数可以是通用寄存器r，立即数im</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD  WORD PTR[BX],	5B28H</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><code>ADD</code>指令说明：</p>
<ol type="1">
<li>指令的目的操作数不能是立即寻址</li>
<li>两个操作数不能同时为存储器变量</li>
<li>加法操作中产生的进位影响CF标志</li>
<li>带符号数相加要考虑溢出</li>
</ol>
<h5 id="带进位算术加法adc">带进位算术加法<code>ADC</code></h5>
<p>ADC（Add with Carry）</p>
<p>指令功能：<code>目的操作数 ←- 目的操作数 + 源操作数 + CF</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC		目的操作数,	源操作数</span><br></pre></td></tr></table></figure>
<p>这个格式可以展开两种加法指令：</p>
<p>以通用寄存器r为目的操作数，源操作数可以是通用寄存器r，存储器mem，立即数im</p>
<p>以存储器mem为目的操作数，源操作数可以是通用寄存器r，存储器mem</p>
<p><br></p>
<p><code>ADC</code>指令说明：</p>
<ol type="1">
<li>指令中有3个操作数，其中CF是本指令<strong>执行前的状态</strong></li>
<li>需要完成多字节数（如4字节的32位数或更多字节）相加时可以用该指令</li>
<li>指令的目的操作数不能是立即寻址</li>
<li>加法操作中产生的进位进入CF标志位</li>
<li>带符号操作数相加要考虑溢出</li>
</ol>
<p>例如：完成无符号数 5B68F271H 和 0AC6D5698H 加法操作</p>
<p>操作数为32位，8086寄存器只有16位，所以分两次：先<code>ADD</code>算低16位，产生的进位再跟高16位<code>ADC</code>计算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV   AX, F271H		;加数的低16位</span><br><span class="line">ADD   AX, 5698H 	;与被加数的低16位相加，结果存在AX，进位影响CF</span><br><span class="line">MOV   DX, 5B68H 	;加数的高16位</span><br><span class="line">ADC   DX, AC6DH 	;与被加数的高16位和CF相加，运算结果存在DX，进位影响CF</span><br></pre></td></tr></table></figure>
<h5 id="加1指令inc">加1指令<code>INC</code></h5>
<p>指令功能：<code>目的操作数 ←- 目的操作数 + 1</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INC		oprd</span><br></pre></td></tr></table></figure>
<p>根据指令的功能，oprd只能是变量，因此可选：通用寄存器r，存储器mem</p>
<p>注：立即数不是变量，所以操作数不能是立即寻址</p>
<p>该指令<strong>不影响CF标志</strong></p>
<p>操作数为内存寻址时，因为无法确定是8位还是16位变量，所以需要指明字节型（<code>BYTE PTR</code>）或字型（<code>WORD PTR</code>）</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INC  BYTE PTR [BX]  ;BYTE PTR指明字节型</span><br><span class="line">INC  AX</span><br></pre></td></tr></table></figure>
<p>很显然，<code>INC  AX</code>可以由<code>ADD    AX, 1</code>代替，但是<code>ADD</code>指令会影响CF标志位，<code>INC</code>不影响CF标志位，这是主要区别</p>
<h5 id="对压缩bcd数加法操作的结果进行校正daa">对压缩BCD数加法操作的结果进行校正<code>DAA</code></h5>
<p>指令功能：对<strong>AL寄存器</strong>的内容进行十进制数调整，仅修改AL，如果位数过多需要交换再修正</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DAA</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV    AL, 0001_0101B	;15的BCD表示</span><br><span class="line">ADD    AL, 0001_0110B	;16的BCD表示</span><br><span class="line">DAA</span><br></pre></td></tr></table></figure>
<p><code>DAA</code>这个指令就是用于BCD码运算后<strong>结果处理</strong>的</p>
<p>比如这个例子，我给AL先传入的是15的BCD码<code>0001_0101B</code>，换成16进制就是<code>15H</code></p>
<p>然后再用<code>ADD</code>指令，把16的BCD码<code>0001_0110B</code>（换成16进制就是<code>16H</code>）与AL内容相加，得到的结果为<code>0001_0101B + 0001_0110B = 0010_1011B</code>，换算成十六进制就是<code>15H + 16H = 2BH</code></p>
<p>很显然，15+16的结果应该是31，如果写成BCD码应该是<code>0011_0001B</code>，换成16进制为<code>31H</code></p>
<p>现在AL寄存器的内容为<code>2BH</code>，很明显不是我们要的BCD运算结果</p>
<p>这时就可以用<code>DAA</code>指令，就会将AL中的<code>2BH</code>修正为<code>31H</code>，这就是<code>DAA</code>指令的作用</p>
<p>可以看到，一个数的BCD表示写成十六进制和它的十进制<strong>完全相同</strong>，比如15的BCD码<code>0001_0101B</code>，换成16进制就是<code>15H</code></p>
<p><br></p>
<p>经过这个例子的讲解，<code>DAA</code>指令的功能已经很明确了，再来看书上讲的啥b例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV    AL, 85H</span><br><span class="line">ADD    AL, 96H</span><br><span class="line">DAA</span><br></pre></td></tr></table></figure>
<p>这里的<code>85H</code>和<code>96H</code>都是BCD码，分别代表了十进制的85和96，而不是普通的十六进制133（85H）和150（96H）</p>
<p>85+96=1<strong>81</strong>（81就是最后AL里应该存的值），但是在<code>ADD</code>运算后，AL里存的是<code>1BH</code>（普通十六进制加法：<code>85H + 96H = 11BH</code>，但AL只有8位，所以只能存<code>1BH</code>，并且产生进位，CF=1）</p>
<p>所以<code>DAA</code>这一步处理，就是把AL里的<code>1BH</code>修正为<code>81H</code>（8位的BCD最多表示到99，所以还是产生进位，CF仍旧为1）</p>
<p><code>DAA</code>指令说明：</p>
<ol type="1">
<li>要求操作的数<strong>必须是BCD数</strong>，即存在AL的数必须是BCD数</li>
<li>该指令用在<strong>压缩BCD数加法操作后</strong>，操作数隐含在AL中</li>
</ol>
<p><br></p>
<p>注意：<code>DAA</code>指令<strong>仅修改AL</strong>，如果位数过多需要交换再修正</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADD	AL,	[BX]	;AL+一个数值元素→AL</span><br><span class="line">DAA				;十进制调整</span><br><span class="line">XCHG	AL,	AH	;因为DAA只修正AL的值，所以对进位CF的处理需要对AH加法，将AL与AH交换</span><br><span class="line">ADC	AL,	0		;AL+CF→AL</span><br><span class="line">DAA				;十进制调整</span><br><span class="line">XCHG	AH,	AL	;AL与AH交换</span><br></pre></td></tr></table></figure>
<p>就用BDC码运算<code>46H + 56H = 102H</code>来解释</p>
<p>AX现在值是<code>0046H</code>，[BX]存的是<code>0056H</code>，经过<code>ADD</code>指令，AL存的就是<code>46H + 56H = 9CH</code></p>
<p>紧接着就是一次<code>DAA</code>修正，会把<code>9CH</code>修正为<code>102H</code>，但是AL只有8位，所以AL新的值就是<code>02H</code>，产生CF=1的进位</p>
<p>这时AX的值就是<code>0002H</code>，但我们想让这个进位加到高位AH上</p>
<p>于是就产生了<code>XCHG AL, AH</code>这句指令，把AH和AL交换，AX现在的值就是<code>0200H</code></p>
<p>再进行带进位的加法<code>ADC</code>指令，AX的值就是<code>0201H</code></p>
<p>对这个值再进行BCD修正，这个虽然例子体现不出来</p>
<p>最后把AH和AL再交换一次，AX的值就是<code>0102H</code>，就满足了<code>46H + 56H = 102H</code></p>
<p><br></p>
<h5 id="对非压缩bcd数加法操作的结果进行校正aaa">对非压缩BCD数加法操作的结果进行校正<code>AAA</code></h5>
<p>压缩BCD码：一个字节表示<strong>两位</strong>十进制数，如56的压缩BCD就是<code>0101_0110B</code></p>
<p>非压缩BCD码：一个字节表示<strong>一位</strong>十进制数，其中高4位为0，低4位存放个位，比如5的非压缩BCD就是<code>0000_0101B</code></p>
<p>指令功能：对AL寄存器的内容进行十进制数调整</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAA</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV    AX, 09H	;AH清零，AL中为加数</span><br><span class="line">ADD    AL, 07</span><br><span class="line">AAA				;结果在AX中为0106</span><br></pre></td></tr></table></figure>
<p><code>AAA</code>指令说明：</p>
<ol type="1">
<li>要求参加操作的数必须是非压缩BCD数</li>
<li>该指令用在<strong>非压缩BCD数加法操作后</strong>，操作数隐含在AL中</li>
<li>该指令使用了AH寄存器，所以事先应该将AH内容清零</li>
</ol>
<h4 id="算术减法指令">算术减法指令</h4>
<h5 id="算术减法sub">算术减法<code>SUB</code></h5>
<p>指令功能：<code>目的操作数 ←- 目的操作数 - 源操作数</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUB		目的操作数,	源操作数</span><br></pre></td></tr></table></figure>
<p>这个格式可以展开两种减法指令：</p>
<p>以通用寄存器r为目的操作数，源操作数可以是通用寄存器r，存储器mem，立即数im</p>
<p>以存储器mem为目的操作数，源操作数可以是通用寄存器r，立即数im</p>
<p><br></p>
<p><code>SUB</code>指令说明：</p>
<ol type="1">
<li>指令的目的操作数不能是立即寻址</li>
<li>两个操作数不能同时为存储器变量</li>
<li>减法操作中产生的借位影响CF标志</li>
<li>无符号操作数相减，若CF=1，则结果为补码</li>
<li>带符号数相减要考虑溢出</li>
</ol>
<h5 id="带进位算术减法sbb">带进位算术减法<code>SBB</code></h5>
<p>SBB（Subtract with Borrow）</p>
<p>指令功能：<code>目的操作数 ←- 目的操作数 - 源操作数 - CF</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SBB		目的操作数,	源操作数</span><br></pre></td></tr></table></figure>
<p>这个格式可以展开两种减法指令：</p>
<p>以通用寄存器r为目的操作数，源操作数可以是通用寄存器r，存储器mem，立即数im</p>
<p>以存储器mem为目的操作数，源操作数可以是通用寄存器r，存储器mem</p>
<p><br></p>
<p><code>SBB</code>指令说明：</p>
<ol type="1">
<li>指令有3个操作数，CF是指令执行前的借位</li>
<li>需要完成多字节数（如4字节的32位数或更多字节）相减时可以用该指令</li>
<li>目的操作数不能是立即寻址</li>
<li>无符号操作数相减，若CF=1，则结果为补码</li>
<li>带符号数相减要考虑溢出</li>
</ol>
<p>例：完成无符号数 5B68F271H 和 0AC6D5698H 减法操作</p>
<p>操作数为32位，8086寄存器只有16位，所以分两次：先<code>SUB</code>算低16位，产生的借位再跟高16位<code>SBB</code>计算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV   AX, F271H		;被减数的低16位</span><br><span class="line">SUB   AX, 5698H 	;与减数的低16位相减，结果存在AX，借位影响CF</span><br><span class="line">MOV   DX, 5B68H 	;被减数的高16位</span><br><span class="line">SBB   DX, AC6DH 	;与减数的高16位和借位CF相减，运算结果存在DX，借位影响CF</span><br></pre></td></tr></table></figure>
<h5 id="减1指令dec">减1指令<code>DEC</code></h5>
<p>指令功能：<code>目的操作数 ←- 目的操作数 - 1</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEC		oprd</span><br></pre></td></tr></table></figure>
<p>根据指令的功能，oprd只能是变量，因此可选：通用寄存器r，存储器mem</p>
<p>注：立即数不是变量，所以操作数不能是立即寻址</p>
<p>该指令<strong>不影响CF标志</strong></p>
<p>操作数为内存寻址时，因为无法确定是8位还是16位变量，所以需要指明字节型（<code>BYTE PTR</code>）或字型（<code>WORD PTR</code>）</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEC		CX</span><br><span class="line">DEC		WORD PTR	[BX]</span><br></pre></td></tr></table></figure>
<h5 id="对压缩bcd数减法操作的结果进行校正das">对压缩BCD数减法操作的结果进行校正<code>DAS</code></h5>
<p>指令功能：对AL寄存器中的内容进行十进制数调整</p>
<h5 id="对非压缩bcd数减法操作的结果进行校正aas">对非压缩BCD数减法操作的结果进行校正<code>AAS</code></h5>
<p>指令功能：对AL寄存器中的内容进行十进制数调整</p>
<h5 id="比较指令cmp">比较指令<code>CMP</code></h5>
<p>指令功能：完成两个操作数相减</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMP		目的操作数,	源操作数</span><br></pre></td></tr></table></figure>
<p>执行<code>目的操作数 - 源操作数</code>，但是<strong>不保存结果</strong></p>
<p>如果结果为0，说明两个数相等，使ZF = 1</p>
<p>如果CF = 1，说明产生借位，则<code>目的操作数 &lt; 源操作数</code></p>
<p>如果CF =
0，说明没有产生借位，则<code>目的操作数 &gt;= 源操作数</code></p>
<h5 id="取补指令neg">取补指令<code>NEG</code></h5>
<p>指令功能：0 - 目的操作数</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NEG		oprd</span><br></pre></td></tr></table></figure>
<p>执行<code>0 - oprd -→ oprd</code></p>
<p><br></p>
<p>例如：把DX, AX组成的32位数取补，DX为高16位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NEG		DX		; 0 - DX → DX</span><br><span class="line">NEG		AX		; 0 - AX → AX</span><br><span class="line">SBB		DX,	0	; DX - 0 - CF → DX</span><br></pre></td></tr></table></figure>
<h4 id="算术乘法指令">算术乘法指令</h4>
<h5 id="无符号数乘法指令mul">无符号数乘法指令<code>MUL</code></h5>
<p>指令功能：完成两个操作数相乘，存入AX（32位时还用到了DX）</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL		oprd</span><br></pre></td></tr></table></figure>
<p>通用寄存器r或存储器mem，不能是立即数</p>
<p><code>MUL</code>指令说明：</p>
<ol type="1">
<li>8位×8位为16位，16位×16位为32位</li>
<li>乘数和被乘数都不能立即寻址</li>
<li>乘数或被乘数<strong>必须存放在AL或AX中</strong>，在指令中隐含AL或AX</li>
<li>16位运算结果<strong>在AX中存</strong>，32位运算结果在DX和AX中存</li>
</ol>
<p><br></p>
<p>例如：完成3EH×5DH的运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV		AL,	3EH</span><br><span class="line">MOV		BL,	5DH</span><br><span class="line">MUL		BL			;执行AL×BL存入AX</span><br></pre></td></tr></table></figure>
<h5 id="带符号数乘法指令imul">带符号数乘法指令<code>IMUL</code></h5>
<p>指令功能：完成两个操作数相乘，存入AX（32位时还用到了DX）</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMUL		oprd</span><br></pre></td></tr></table></figure>
<p>通用寄存器r或存储器mem，不能是立即数</p>
<p><code>IMUL</code>指令说明：</p>
<ol type="1">
<li>8位×8位为16位，16位×16位为32位</li>
<li>乘数和被乘数都不能立即寻址</li>
<li>乘数或被乘数<strong>必须存放在AL或AX中</strong>，在指令中隐含AL或AX</li>
<li>16位运算结果<strong>在AX中存</strong>，32位运算结果在DX和AX中存</li>
</ol>
<h5 id="非压缩bcd数乘法结果校正aam">非压缩BCD数乘法结果校正<code>AAM</code></h5>
<p>指令功能：完成两个非压缩BCD数乘法结果的十进制数调整</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAM</span><br></pre></td></tr></table></figure>
<h4 id="算术除法指令">算术除法指令</h4>
<h5 id="无符号数除法指令div">无符号数除法指令<code>DIV</code></h5>
<p>指令功能：完成<code>AX ÷ 操作数</code>，存入AX</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DIV		oprd</span><br></pre></td></tr></table></figure>
<p>通用寄存器r或存储器mem，不能是立即数</p>
<p><code>DIV</code>指令说明：</p>
<ol type="1">
<li>用16位除8位，32位除16位，如果被除数不够16位或32位，就进行扩展</li>
<li>除数和被除数都不能立即寻址</li>
<li>被除数<strong>必须存放在AX或DX:AX中</strong>，在指令中隐含</li>
<li>16位运算的商<strong>在AL中存</strong>，余数<strong>在AH中存</strong></li>
<li>32位运算的商<strong>在AX中存</strong>，余数<strong>在DX中存</strong></li>
</ol>
<p><br></p>
<p>例：完成无符号数3E2CH÷5BH运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV		AX,	3E2CH</span><br><span class="line">MOV		BL,	5BH</span><br><span class="line">DIV		BL</span><br></pre></td></tr></table></figure>
<h5 id="带符号数除法指令idiv">带符号数除法指令<code>IDIV</code></h5>
<p>指令功能：完成<code>AX ÷ 操作数</code>，存入AX</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDIV		oprd</span><br></pre></td></tr></table></figure>
<p>通用寄存器r或存储器mem，不能是立即数</p>
<h5 id="带符号数字节扩展指令cbw">带符号数字节扩展指令<code>CBW</code></h5>
<p>指令功能：将<strong>AL</strong>的8位拓展为16位</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CBW</span><br></pre></td></tr></table></figure>
<h5 id="带符号数字扩展指令cwd">带符号数字扩展指令<code>CWD</code></h5>
<p>指令功能：将<strong>AX</strong>的16位拓展为32位</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CWD</span><br></pre></td></tr></table></figure>
<h5 id="非压缩bcd数除法结果校正aad">非压缩BCD数除法结果校正<code>AAD</code></h5>
<p>指令功能：BCD校正</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAD</span><br></pre></td></tr></table></figure>
<h3 id="位操作指令">位操作指令</h3>
<h4 id="位操作指令共同特点">位操作指令共同特点</h4>
<p>可以按二进制位进行操作</p>
<p>逻辑运算指令按逻辑门电路运算规则</p>
<p>逻辑位移指令有左移右移，移出的位进入CF标志</p>
<p>因移空位的补充方式不同，有多种指令形式</p>
<p>逻辑移位指令中，移动超过1次，则用CL寄存器作为计数器</p>
<p>执行逻辑操作指令（不包括逻辑位移），CF均被清零</p>
<h4 id="逻辑运算指令">逻辑运算指令</h4>
<h5 id="逻辑非指令not">逻辑非指令<code>NOT</code></h5>
<p>指令功能：将8位、16位寄存器或存储器内容求反</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOT		oprd</span><br></pre></td></tr></table></figure>
<p>操作数可以是通用寄存器r，存储器mem</p>
<p><code>NOT</code>指令说明：</p>
<ol type="1">
<li>目的操作数不能为立即数寻址</li>
<li>对8位或16位一次性全部取反</li>
</ol>
<p><br></p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		AX,	1234H</span><br><span class="line">NOT		AX</span><br></pre></td></tr></table></figure>
<p>AX的内容为EDCBH</p>
<h5 id="逻辑与指令and">逻辑与指令<code>AND</code></h5>
<p>指令功能：将8位、16位寄存器或存储器内容和源操作数“与”</p>
<p><code>目的操作数 ←- 目的操作数 与 源操作数</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND		目的操作数, 源操作数</span><br></pre></td></tr></table></figure>
<p>目的操作数可以是通用寄存器r，也可以是存储器mem</p>
<p>当目的操作数为通用寄存器r时，操作数可以是通用寄存器r，存储器mem，立即数im</p>
<p>当目的操作数为存储器mem时，操作数可以是通用寄存器r，存储器mem</p>
<p><code>AND</code>指令说明：</p>
<ol type="1">
<li>目的操作数不能为立即数寻址</li>
<li>可由源操作数控制，对8位或16位数的某些位进行屏蔽或保留</li>
<li>目的操作数和源操作数不能同时为存储器mem</li>
</ol>
<p><br></p>
<p>例如：保留AL中的低4位，高4位清零</p>
<p>与，遇0出0，遇1不变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND		AL,	00001111B</span><br></pre></td></tr></table></figure>
<p>再例如：AL中有小写字符"a-z"其中之一的ASCII码，将其转换为大写</p>
<p>在ASCII码中，大写字母和小写字母的二进制表示只有第五位（从右往左数）不同。大写字母的第五位是0，而小写字母的第五位是1</p>
<p>比如：</p>
<p>大写A是65：<code>0100_0001B</code>；大写Z是90：<code>0101_1010B</code></p>
<p>小写a是97：<code>0110_0001B</code>；小写z是122：<code>0111_1010B</code></p>
<p>所以后5位保持不变，前2位保持不变，只把第五位从1变到0即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND		AL,	1101_1111B</span><br></pre></td></tr></table></figure>
<h5 id="逻辑或指令or">逻辑或指令<code>OR</code></h5>
<p>指令功能：将8位、16位寄存器或存储器内容和源操作数“或”</p>
<p><code>目的操作数 ←- 目的操作数 或 源操作数</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OR		目的操作数, 源操作数</span><br></pre></td></tr></table></figure>
<p>目的操作数可以是通用寄存器r，也可以是存储器mem</p>
<p>当目的操作数为通用寄存器r时，操作数可以是通用寄存器r，存储器mem，立即数im</p>
<p>当目的操作数为存储器mem时，操作数可以是通用寄存器r，存储器mem</p>
<p><code>OR</code>指令说明：</p>
<ol type="1">
<li>目的操作数不能为立即数寻址</li>
<li>可由源操作数控制，对8位或16位数的某些位进行置1或保留</li>
<li>目的操作数和源操作数不能同时为存储器mem</li>
</ol>
<p><br></p>
<p>例如：将DX的低八位置1：</p>
<p>或，遇1出1，遇0不变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OR		DX,	00FFH</span><br></pre></td></tr></table></figure>
<h5 id="逻辑异或指令xor">逻辑异或指令<code>XOR</code></h5>
<p>指令功能：将8位、16位寄存器或存储器内容和源操作数“异或”</p>
<p><code>目的操作数 ←- 目的操作数 异或 源操作数</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XOR		目的操作数, 源操作数</span><br></pre></td></tr></table></figure>
<p>目的操作数可以是通用寄存器r，也可以是存储器mem</p>
<p>当目的操作数为通用寄存器r时，操作数可以是通用寄存器r，存储器mem，立即数im</p>
<p>当目的操作数为存储器mem时，操作数可以是通用寄存器r，存储器mem</p>
<p><code>XOR</code>指令说明：</p>
<ol type="1">
<li>目的操作数不能为立即数寻址</li>
<li>可由源操作数控制，对8位或16位数的某些位进行求反或保留</li>
<li>目的操作数和源操作数不能同时为存储器mem</li>
</ol>
<p><br></p>
<p>例如：将AX的D1,D5,D6,D11和D15求反，其余位不变</p>
<p>异或0，则不变，异或1，则求反</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XOR		AX,	1000_1000_0110_0010B</span><br></pre></td></tr></table></figure>
<h5 id="测试指令test">测试指令<code>TEST</code></h5>
<p>这个指令还挺好用的，特别是搭配<code>JZ</code>指令，因为只涉及到ZF的值，不会改变目的操作数的值</p>
<p>这个在接口技术课设中用了特别多</p>
<p>指令功能：将8位、16位寄存器或存储器内容和源操作数“与”，但<strong>不会改变目的操作数的值</strong></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TEST	目的操作数, 源操作数</span><br></pre></td></tr></table></figure>
<p>目的操作数可以是通用寄存器r，也可以是存储器mem</p>
<p>当目的操作数为通用寄存器r时，操作数可以是通用寄存器r，存储器mem，立即数im</p>
<p>当目的操作数为存储器mem时，操作数可以是通用寄存器r，存储器mem</p>
<p><code>TEST</code>指令说明：</p>
<ol type="1">
<li>与<code>AND</code>指令寻址方式和运算规则相同，但<code>TEST</code>指令不产生运算结果，仅影响ZF</li>
<li>常用来判断某位是否是1或0</li>
</ol>
<p><br></p>
<p>例如：判断AX的D1是否为1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TEST	AX,	0002H</span><br></pre></td></tr></table></figure>
<p>检测ZF标志，如果为0，说明AX和0002H进行与操作最后的结果不是0，则说明D1确实为1；如果ZF为1，说明D1是0</p>
<p>举例来说：若AX为000FH，二进制就是<code>0000_0000_0000_1111B</code></p>
<p>这个值与<code>0000_0000_0000_0010B</code>做与操作，得到的是<code>0002H</code>，不是0，所以ZF标志位为0，所以D1确实为1</p>
<p>如果AX为0009H，即<code>0000_0000_0000_1001B</code>，与运算的结果就是<code>0000H</code>，结果为0，ZF置1，所以D1不是1</p>
<h4 id="逻辑移位指令">逻辑移位指令</h4>
<h5 id="非循环移位指令">非循环移位指令</h5>
<p>算术左移指令 <code>SAL</code>(Shift Arithmetic Left)</p>
<p>算术右移指令 <code>SAR</code>(Shift Arithmetic Right)</p>
<p>逻辑左移指令 <code>SHL</code>(Shift Left)</p>
<p>逻辑右移指令 <code>SHR</code>(Shift Right)</p>
<p>这四条指令格式相同，以<code>SAL</code>为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SAL		oprd,	1	;移动1位</span><br><span class="line">SAL		oprd,	CL	;移动多位，用CL控制次数</span><br></pre></td></tr></table></figure>
<p><code>SAL</code>指令说明：</p>
<ol type="1">
<li>移动1位，源操作数为1；移动超过1位，用CL寄存器控制移动次数</li>
<li>算术左移1位，原数据乘2</li>
<li>移空的位置补0</li>
</ol>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		DL,	0A5H</span><br><span class="line">SAL		DL,	1</span><br></pre></td></tr></table></figure>
<p>执行完后，DL存的就是4AH，最高位1移出去，让CF置1</p>
<p><br></p>
<p>移位指令执行的操作如图所示：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231224224907016.png" class title="image-20231224224907016">
<p>算术右移补的是<strong>符号位</strong></p>
<p>逻辑右移补的是0</p>
<h5 id="循环移位指令">循环移位指令</h5>
<p>不含进位位的循环左移指令 <code>ROL</code>（Rotate Left）</p>
<p>不含进位位的循环右移指令 <code>ROR</code>（Rotate Right）</p>
<p>含进位位的循环左移指令 <code>RCL</code>（Rotate through Carry
Left）</p>
<p>含进位位的循环右移指令 <code>RCR</code>（Rotate through Carry
Right）</p>
<p><br></p>
<p>R（Rotate）就是<strong>循环</strong>移位</p>
<p>S（Shift）就是<strong>非循环</strong>移位</p>
<p><br></p>
<p>格式同非循环移位指令</p>
<p>移位位数放在CL寄存器中，如果只移1位，也可以直接写在指令中</p>
<p>循环移位指令只影响标志位CF和OF</p>
<p>功能如图所示：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231225092923522.png" class title="image-20231225092923522">
<p>例如：将AL的高4位与低4位互换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		CL,	4</span><br><span class="line">ROL		AL,	CL</span><br></pre></td></tr></table></figure>
<h3 id="串处理指令">串处理指令</h3>
<p><a id="explanation of String"></a></p>
<p>串：顺序放在内存中的一组相同类型的数据</p>
<p>串操作：对串中的元素进行相同的操作</p>
<p>串处理指令是针对存储器的操作</p>
<h4 id="串处理指令共同点">串处理指令共同点</h4>
<ol type="1">
<li>指令特殊寻址方式：源操作数的逻辑地址由<code>DS : SI</code>给出，目的操作数的逻辑地址由<code>ES : DI</code>给出</li>
<li>存储单元由字型和字节型之分，所以指令助记符有W（Word）或B（Byte）之分</li>
<li>使用这类指令，存储单元的地址指针是<strong>自动移动</strong>的（串操作指令自动修改SI和DI，字节±1，字±2），用DF标志位控制指针移动方向：DF=0，地址往增大方向移动；DF=1，地址往减小方向移动</li>
<li><strong>串的长度由CX给定</strong></li>
<li>这类指令前面一般可以使用指令前缀（比如重复前缀<code>REP</code>和<code>REPNZ</code>），具体见“<a href="#explanation of Instruction Prefixes">指令前缀</a>”</li>
<li>这类指令后<strong>不带操作数</strong>，操作数隐含给定</li>
</ol>
<h4 id="串指令使用一般方法">串指令使用一般方法</h4>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231225095810612.png" class title="image-20231225095810612">
<h4 id="cld和std指令"><code>CLD</code>和<code>STD</code>指令</h4>
<p>因为串指令中使用DF位，所以把标志控制指令提前放在这里了</p>
<p><code>CLD</code>（Clear Direction
Flag）指令：将方向标志位DF清零，即从低地址到高地址</p>
<p><code>STD</code>（Set Direction
Flag）指令：将方向标志位DF置1，即从高地址到低地址</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLD</span><br><span class="line">STD</span><br></pre></td></tr></table></figure>
<h4 id="串传输指令movsb或movsw">串传输指令<code>MOVSB</code>或<code>MOVSW</code></h4>
<p>B指Byte</p>
<p>W指Word</p>
<p>指令功能：<code>目的操作数 ←- 源操作数</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVSB</span><br><span class="line">MOVSW</span><br></pre></td></tr></table></figure>
<p><strong>源操作数</strong>的逻辑地址由<code>DS : SI</code>给出，即操作<strong>SI</strong></p>
<p><strong>目的操作数</strong>的逻辑地址由<code>ES : DI</code>给出，即操作<strong>DI</strong></p>
<p>DF控制SI或DI是增大还是减小</p>
<p>B和W控制SI和DI是加减1还是加减2</p>
<p><strong>串的长度由CX给定</strong>（即数据区长度），但是指令执行一次，CX<strong>内容不变</strong>（所以要循环执行）</p>
<p><br></p>
<p>例如：用串传送指令，将偏移地址为BUFF1的内存区中200个字型数据，转移到偏移地址为BUFF2的内存区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LEA		SI,	BUFF1		;源操作数地址指针</span><br><span class="line">LEA		DI,	BUFF2		;目的操作数地址指针</span><br><span class="line">CLD						;DF=0</span><br><span class="line">MOV		CX,	200			;数据区长度</span><br><span class="line"></span><br><span class="line">;*******************************************************************</span><br><span class="line">;MOVSW	如果仅写一个MOVSW，这个操作只会被执行一次，所以需要加一个循环</span><br><span class="line">;*******************************************************************</span><br><span class="line"></span><br><span class="line">MOV_LOOP:				;循环MOVSW</span><br><span class="line">	MOVSW</span><br><span class="line">	LOOP	MOV_LOOP	;CX自减，直到CX为0</span><br></pre></td></tr></table></figure>
<p>注：如果仅写一个<code>MOVSW</code>，这个操作只会被执行一次（CX的值不会改变），所以需要加一个循环</p>
<p><br></p>
<p>指令也可写成：<code>MOVS  dest, src</code></p>
<p>但要求：</p>
<p>①<code>src</code>用<code>DS:SI</code>寻址,<code>dest</code>用<code>ES:DI</code>寻址</p>
<p>②传送是字节还是字，由操作数的类型决定</p>
<h4 id="串比较指令cmpsb或cmpsw">串比较指令<code>CMPSB</code>或<code>CMPSW</code></h4>
<p>指令功能：<code>目的操作数 - 源操作数</code>，与<code>CMP</code>指令类似，不会产生结果，只会影响ZF位</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMPSB</span><br><span class="line">CMPSW</span><br></pre></td></tr></table></figure>
<p><strong>源操作数</strong>的逻辑地址由<code>DS : SI</code>给出，即操作<strong>SI</strong></p>
<p><strong>目的操作数</strong>的逻辑地址由<code>ES : DI</code>给出，即操作<strong>DI</strong></p>
<p>指令也可写成：<code>CMPS  dest, src</code></p>
<h4 id="串搜索指令scasb或scasw">串搜索指令<code>SCASB</code>或<code>SCASW</code></h4>
<p><code>SCASB</code>（Scan String Byte）</p>
<p><code>SCASW</code>（Scan String Word）</p>
<p>指令功能：<code>AL/AX - 目的操作数</code></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCASB</span><br><span class="line">SCASW</span><br></pre></td></tr></table></figure>
<p><strong>源操作数</strong>的逻辑地址由<code>DS : SI</code>给出，即操作<strong>SI</strong></p>
<p><strong>目的操作数</strong>的逻辑地址由<code>ES : DI</code>给出，即操作<strong>DI</strong></p>
<p>本指令用于在串中查找指定的信息，要搜索的关键字放在AL(字节)或AX(字)中</p>
<p><br></p>
<p>例如：</p>
<p>在ES段的偏移1000H开始处存有10个ASCII码。搜索<code>E</code>，若找到则记下搜索次数及存放地址，并在屏幕上显示<code>Y</code>；若未找到则显示<code>N</code></p>
<p>在屏幕上显示一个字符的指令段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV  DL, &lt;字符&gt;</span><br><span class="line">MOV  AH, 2</span><br><span class="line">INT  21H</span><br></pre></td></tr></table></figure>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231225105324142.png" class title="image-20231225105324142">
<p>程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MOV  DI, 1000H         	;(DI)←串偏移地址</span><br><span class="line">MOV  CX, 10	            ;(CX)←串长度</span><br><span class="line">MOV  AL, ’E’          	;搜索关键字=’E’,要搜索的关键字放在AL(字节)或AX(字)中</span><br><span class="line">CLD                     ;置DF=0，从低地址到高地址进行搜索 </span><br><span class="line">REPNZ  SCASB            ;若未找到, 继续搜索                  </span><br><span class="line">JZ   FOUND              ;找到, 转至FOUND</span><br><span class="line">MOV  DL, ’N’          	;串中无’E’，(DL)←’N’</span><br><span class="line">JMP  DONE               ;转至DONE</span><br><span class="line">FOUND:</span><br><span class="line">DEC   DI                ;指针回退</span><br><span class="line">MOV  ADDR, DI           ;ADDR←’E’的地址	   </span><br><span class="line">SUB   DI, 1000H</span><br><span class="line">MOV  NUM, DI            ;NUM←搜索次数	    </span><br><span class="line">MOV  DL, ’Y’          	;(DL)←’Y’</span><br><span class="line">DONE:</span><br><span class="line">MOV  AH, 2		</span><br><span class="line">INT  21H             	;显示字符</span><br><span class="line">HLT 				  ;Halt指令，暂停程序</span><br></pre></td></tr></table></figure>
<p>对部分代码的解释：</p>
<p><code>REPNZ  SCASB</code>：<code>REPNZ</code>（Repeat While Not
Zero）是一个前缀指令，相当于循环执行CX次，同时CX自减，中间如果出现ZF=1就<code>break</code>，否则就正常结束循环</p>
<p>如果出现<code>break</code>的情况，那说明此时ZF一定为1（即<code>SCASB</code>搜索到对应值了），此时就紧接着执行<code>JZ   FOUND</code>指令，跳转到<code>FOUND</code>标签</p>
<p>如果没出现跳出循环的情况，<code>JZ   FOUND</code>指令就不起作用，紧接着执行的是<code>MOV  DL, ’N’</code>指令，按题目要求把<code>N</code>写入DL寄存器，然后执行<code>JMP   DONE</code>指令，跳转到<code>DONE</code>标签，执行显示操作</p>
<p><br></p>
<p>关于<code>FOUND</code>标签第一句：<code>DEC   DI</code>：不管<code>SCASB</code>找到没找到，DI一定会根据DF的值变化。在这里DF为0，DI一定会在<code>SCASB</code>执行完以后+1，所以如果DI到了E这里，执行搜索，搜到了，DI还是会自增1，这就是为什么在寻找E地址的时候需要<code>DEC DI</code></p>
<p>关于<code>MOV  ADDR, DI</code>和<code>MOV  NUM, DI</code>：这里的<code>ADDR</code>和<code>NUM</code>都是变量</p>
<p><br></p>
<p>关于最后的<code>HLT</code>指令：可以理解为C语言程序的<code>system("pause")</code>，处理器进入暂停状态，直到接收到中断信号</p>
<h4 id="串装入指令lodsb或lodsw">串装入指令<code>LODSB</code>或<code>LODSW</code></h4>
<p><code>LODSB</code>（Load String Byte）</p>
<p><code>LODSW</code>（Load String Word）</p>
<p>指令功能：<code>AL/AX ←- 源操作数</code></p>
<p><strong>源操作数</strong>的逻辑地址由<code>DS : SI</code>给出</p>
<p><br></p>
<p>每执行一次，将存储单元的内容写入累加器</p>
<p>不影响标志位</p>
<p><br></p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LODSB</span><br><span class="line">LODSW</span><br></pre></td></tr></table></figure>
<p>执行完以后SI会自增，如果是B就自增1次，如果是W就自增2次</p>
<p>其中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LODSB</span><br><span class="line">等价于</span><br><span class="line">MOV  AL, [SI]</span><br><span class="line">INC  SI</span><br><span class="line"></span><br><span class="line">LODSW</span><br><span class="line">等价于</span><br><span class="line">MOV  AX, [SI]</span><br><span class="line">INC  SI</span><br><span class="line">INC  SI</span><br></pre></td></tr></table></figure>
<h4 id="串存储指令stosb或stosw">串存储指令<code>STOSB</code>或<code>STOSW</code></h4>
<p><code>STOSB</code>（Store String Byte）</p>
<p><code>STOSW</code>（Store String Word）</p>
<p>指令功能：<code>目的操作数 ←- AL/AX</code></p>
<p><strong>目的操作数</strong>的逻辑地址由<code>ES : DI</code>给出</p>
<p><br></p>
<p>每执行一次，将累加器的内容写入存储单元</p>
<p>不影响标志位</p>
<p><br></p>
<p>例如：把从A000H开始的2KB内存单元清零</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV  DI, A000H		;起始偏移地址</span><br><span class="line">MOV  AX, 0			;将累加器的内容写入存储单元，所以先将0写入AX</span><br><span class="line">MOV  CX, 2048		;2KB</span><br><span class="line">CLD				    ;低地址向高地址写</span><br><span class="line">REP  STOSB 			;循环执行</span><br></pre></td></tr></table></figure>
<p>又例如：把1000H开始的100个存储单元填入ASCII码2AH(*)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV  DI, 1000H        ; 首地址</span><br><span class="line">MOV  AL, 2AH          ; ‘*’ </span><br><span class="line">MOV  CX, 100          ; 重复执行100次</span><br><span class="line">CLD                   ; 增量修改DI </span><br><span class="line">REP	STOSB</span><br></pre></td></tr></table></figure>
<p>再例如：设在1000H开始存有四个压缩的BCD码12、34、56、78；要求把它们转换为ASCII码存放在3000H开始的单元中</p>
<p>假定DS、ES都已设置为数据段的段基址</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231225115612016.png" class title="image-20231225115612016">
<p><strong>源操作数</strong>的逻辑地址由<code>DS : SI</code>给出，即<code>LODSB</code>指令将<code>DS : SI</code>的内容Load进累加器AL</p>
<p><strong>目的操作数</strong>的逻辑地址由<code>ES : DI</code>给出，即<code>STOSB</code>指令将累加器AL的内容Store进<code>ES : DI</code></p>
<p>程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MOV  SI, 1000H	;SI←BCD首址，因为LODSB指令需要从DS : SI读取数据</span><br><span class="line">MOV  DI, 3000H	;DI←ASCII首址，因为STOSB指令需要把数据写入ES : DI</span><br><span class="line">MOV  BX, 4		;置计数器初值</span><br><span class="line">BBB: </span><br><span class="line">MOV  AL, [SI]    ;AL←BCD码,第一次取12H</span><br><span class="line">AND  AL, 0FH	;屏蔽高4位→02H</span><br><span class="line">OR   AL, 30H	;转换为ASCII码→32H</span><br><span class="line">STOSB           ;保存结果，将累加器AL的内容写入ES : DI</span><br><span class="line">LODSB		   ;读取结果，将DS : SI的内容Load进累加器AL</span><br><span class="line">MOV  CL, 4</span><br><span class="line">SHR  AL, CL      ;逻辑右移4位</span><br><span class="line">OR   AL, 30H     ;得到高4位ASCII码</span><br><span class="line">STOSB           ;保存结果</span><br><span class="line">DEC  BX	   	    ;(BX)←(BX)-1</span><br><span class="line">JNZ  BBB	    ;(BX)≠0，则继续循环</span><br></pre></td></tr></table></figure>
<h3 id="指令前缀">指令前缀</h3>
<p><a id="explanation of Instruction Prefixes"></a></p>
<p>在串操作指令中，串的长度（数据个数）输入进CX，而指令执行时并不对CX进行操作</p>
<p>重复执行这些指令时，需要对CX中的值自减来控制循环的结束</p>
<p>指令前缀就是控制串处理指令循环啊进行，每执行一次，CX内容减1，直到CX内容减到0</p>
<p>如果有些指令还涉及到了ZF标志，则还需要对ZF进行判别</p>
<h4 id="rep前缀"><code>REP</code>前缀</h4>
<p><code>REP</code>前缀就是重复，每执行一次，CX内容减1，直到CX为0退出循环</p>
<p>例如：将偏移地址为BUFF1的内存区中100个字型数据，传送到偏移地址为BUFF2的内存区</p>
<p><strong>源操作数</strong>的逻辑地址由<code>DS : SI</code>给出，即操作<strong>SI</strong></p>
<p><strong>目的操作数</strong>的逻辑地址由<code>ES : DI</code>给出，即操作<strong>DI</strong></p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LEA		SI,	BUFF1	;源操作数地址</span><br><span class="line">LEA		DI,	BUFF2	;目的操作数地址</span><br><span class="line">CLD					;DF=0，从低地址向高地址</span><br><span class="line">MOV 	CX,	100		;100个字型数据</span><br><span class="line">REP		MOVSW		;字型，用MOVSB</span><br></pre></td></tr></table></figure></p>
<h4 id="repzrepe前缀"><code>REPZ</code>/<code>REPE</code>前缀</h4>
<p><code>REPZ</code>/<code>REPE</code>前缀往往与<code>CMPS</code>配合使用</p>
<p><code>REPZ</code>（Repeat While Zero）</p>
<p><code>REPE</code>（Repeat While Equal）</p>
<p>若执行这样的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPZ	CMPS</span><br></pre></td></tr></table></figure>
<p>每执行一次<code>CMPS</code>指令，CX减1，ZF根据比较的结果，如果相同就置1</p>
<p>若CX≠0且ZF=1，比较继续进行</p>
<p>若CX≠0且ZF=0，比较停止</p>
<p>若CX=0，比较停止</p>
<p>所以这个可以用于判断两个串数据是否相等</p>
<h4 id="repnzrepne前缀"><code>REPNZ</code>/<code>REPNE</code>前缀</h4>
<p><code>REPNZ</code>/<code>REPNE</code>前缀往往与<code>SCAS</code>配合使用</p>
<p><code>REPNZ</code>（Repeat While Not Zero）</p>
<p><code>REPNE</code>（Repeat While Not Equal）</p>
<p>若执行这样的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPNZ	SCASB</span><br></pre></td></tr></table></figure>
<p>每执行一次<code>SCASB</code>指令，CX减1，根据比较累加器AX（或AL）的值与当前指针指向的值，如果相等则ZF=1</p>
<p>若CX≠0且ZF=0，比较继续进行</p>
<p>若CX≠0且ZF=1，<code>break</code>比较停止</p>
<p>若CX=0，比较停止</p>
<p>所以这个可以用于判断是否找到AX里的值</p>
<h3 id="程序控制转移指令">程序控制转移指令</h3>
<h4 id="无条件转移jmp">无条件转移<code>JMP</code></h4>
<h5 id="段内转移">段内转移</h5>
<p>段内直接转移用<code>NEAR PTR</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JMP		NEAR PTR	目标地址	;直接转移</span><br><span class="line">JMP		CX						;间接转移</span><br><span class="line">JMP		WORD PTR	[BX]		;间接转移</span><br></pre></td></tr></table></figure>
<h5 id="段间转移">段间转移</h5>
<p>段间直接转移用<code>FAR PTR</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMP		FAR PTR		目标地址	;直接转移</span><br></pre></td></tr></table></figure>
<h4 id="条件转移">条件转移</h4>
<p>我在课设里用<code>JZ</code>用的最多，也还挺好用的</p>
<p><code>JZ</code>/<code>JE</code>：ZF标志为1就转移</p>
<p><code>JNZ</code>/<code>JNE</code>：ZF标志为0就转移</p>
<p><code>JC</code>：CF标志为1就转移</p>
<p><code>JNC</code>：CF标志为0就转移</p>
<p><code>JS</code>：SF标志为1就转移</p>
<p><code>JNS</code>：SF标志为0就转移</p>
<p><code>JO</code>：OF标志为1就转移</p>
<p><code>JNO</code>：OF标志为0就转移</p>
<h4 id="循环控制指令">循环控制指令</h4>
<h5 id="loop"><code>LOOP</code></h5>
<p>执行<code>LOOP</code>会使CX减1</p>
<p>用我在接口技术课设里的代码举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C_16	PROC	NEAR		;标准C，16分音符</span><br><span class="line">	MOV		CX,	29</span><br><span class="line">	C_LOOP_16:</span><br><span class="line">		CALL	Music_C</span><br><span class="line">		LOOP	C_LOOP_16</span><br><span class="line">	RET</span><br><span class="line">C_16	ENDP</span><br></pre></td></tr></table></figure>
<p><code>C_16</code>这个程序里用到了这样一段<code>LOOP</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV		CX,	29</span><br><span class="line">C_LOOP_16:</span><br><span class="line">		CALL	Music_C</span><br><span class="line">		LOOP	C_LOOP_16</span><br></pre></td></tr></table></figure>
<p>先给CX一个值，表示循环次数为29次</p>
<p>然后循环里就一直调用<code>Music_C</code>函数，调用29次</p>
<p>结束循环后直接<code>RET</code></p>
<h4 id="子程序调用和返回指令">子程序调用和返回指令</h4>
<p>注意：写子程序的时候<strong>先保护现场</strong>，最后返回现场</p>
<h5 id="子程序调用call">子程序调用<code>CALL</code></h5>
<p>根据我实际做课程设计的情况看，无论隔多远，都能<code>CALL</code>到</p>
<p>所以这里只记录段内直接调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL	函数名</span><br></pre></td></tr></table></figure>
<h5 id="子程序返回ret">子程序返回<code>RET</code></h5>
<p>这个就是高级语言的<code>return</code></p>
<h4 id="中断指令和中断返回指令">中断指令和中断返回指令</h4>
<p>中断指令<code>INT    N</code></p>
<p>中断返回指令<code>IRET</code></p>
<h3 id="关系运算符">关系运算符</h3>
<p><code>EQ</code>（Equal）：相等</p>
<p><code>NE</code>（Not Equal）：不等</p>
<p><code>LT</code>（Less Than）：小于</p>
<p><code>GT</code>（Greater Than）：大于</p>
<p><code>LE</code>（Less Equal）：小于等于</p>
<p><code>GE</code>（Greater Equal）：大于等于</p>
<p>若满足关系，则结果为1</p>
<p>不满足关系，则结果为0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV	DL,	10H LT 10</span><br></pre></td></tr></table></figure>
<p>10H不小于10，所以结果为0，相当于<code>MOV DL, 0</code></p>
<h3 id="处理器控制指令">处理器控制指令</h3>
<p><code>STC</code>：使CF置1</p>
<p><code>CLC</code>：使CF清0</p>
<p><code>CMC</code>：使CF取反</p>
<p><code>STD</code>：使DF置1</p>
<p><code>CLD</code>：使DF清0</p>
<p><code>STI</code>：使IF置1</p>
<p><code>CLI</code>：使IF清0</p>
<p><br></p>
<p><code>HLT</code>：暂停</p>
<p><code>WAIT</code>：等待</p>
<p><code>ESC</code>：换码指令/交权指令</p>
<p><code>LOCK</code>：总线封锁</p>
<p><code>NOP</code>：空操作指令</p>
<h2 id="指令集总结">8086指令集总结</h2>
<h3 id="用到的指令">用到的指令</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">MOV	目的操作数,	源操作数	;源操作数移动到目的操作数</span><br><span class="line"></span><br><span class="line">PUSH	oprd	;oprd指示的地址16位内容入栈，但不能是立即数</span><br><span class="line"></span><br><span class="line">POP	oprd	;16位栈顶元素出栈到oprd指示的地址</span><br><span class="line"></span><br><span class="line">XCHG	r,	oprd	;完成目的操作数和源操作数的内容互换</span><br><span class="line"></span><br><span class="line">IN	a,	oprd	;把oprd指示的端口内容传输到累加器a</span><br><span class="line"></span><br><span class="line">OUT	oprd, a	;把累加器a的内容传送到oprd指定的端口，目的操作数是I/O端口地址</span><br><span class="line"></span><br><span class="line">XLAT	;隐含寻址，从[BX + AL]地址中取数给AL</span><br><span class="line"></span><br><span class="line">LEA	r,	mem	;取mem指示的地址（这里就是偏移地址）送寄存器r，r应该是16位</span><br><span class="line"></span><br><span class="line">LDS	r,	mem	;将mem开始的4个连续字节的内容传输到目的寄存器r和数据段寄存器DS中</span><br><span class="line"></span><br><span class="line">LES	r,	mem	;与LDS类似，传输到ES中</span><br><span class="line"></span><br><span class="line">LAHF	;FR寄存器的低8位存入AH</span><br><span class="line"></span><br><span class="line">SAHF	;AH存入FR寄存器的低8位</span><br><span class="line"></span><br><span class="line">PUSHF	;FR寄存器内容入栈</span><br><span class="line"></span><br><span class="line">POPF	;从栈顶弹出内容存入FR寄存器</span><br><span class="line"></span><br><span class="line">;*********************************************************************************</span><br><span class="line"></span><br><span class="line">ADD	目的操作数,	源操作数	;目的操作数 ←- 目的操作数 + 源操作数</span><br><span class="line"></span><br><span class="line">ADC	目的操作数,	源操作数	;目的操作数 ←- 目的操作数 + 源操作数 + CF</span><br><span class="line"></span><br><span class="line">INC	oprd	;目的操作数 ←- 目的操作数 + 1，不影响CF标志</span><br><span class="line"></span><br><span class="line">DAA	;对压缩BCD数加法操作的结果进行校正</span><br><span class="line"></span><br><span class="line">AAA	;对非压缩BCD数加法操作的结果进行校正</span><br><span class="line"></span><br><span class="line">SUB	目的操作数,	源操作数	;目的操作数 ←- 目的操作数 - 源操作数</span><br><span class="line"></span><br><span class="line">SBB	目的操作数,	源操作数	;目的操作数 ←- 目的操作数 - 源操作数 - CF</span><br><span class="line"></span><br><span class="line">DEC	oprd	;目的操作数 ←- 目的操作数 - 1，不影响CF标志</span><br><span class="line"></span><br><span class="line">DAS	;对压缩BCD数减法操作的结果进行校正</span><br><span class="line"></span><br><span class="line">AAS	;对非压缩BCD数减法操作的结果进行校正</span><br><span class="line"></span><br><span class="line">CMP	目的操作数,	源操作数	;目的操作数 - 源操作数，但是不保存结果，仅影响ZF和CF</span><br><span class="line"></span><br><span class="line">NEG	oprd	;取补，0 - oprd -→ oprd</span><br><span class="line"></span><br><span class="line">MUL	oprd	;完成两个操作数相乘（AX内容乘oprd），存入AX，在指令中隐含AL或AX，oprd不能是立即数</span><br><span class="line"></span><br><span class="line">IMUL	oprd	;带符号数乘法指令（AX内容乘oprd），存入AX，oprd不能是立即数</span><br><span class="line"></span><br><span class="line">AAM	;非压缩BCD数乘法结果校正</span><br><span class="line"></span><br><span class="line">DIV	oprd	;完成AX ÷ 操作数，存入AX，oprd不能是立即数</span><br><span class="line"></span><br><span class="line">IDIV	oprd	;带符号数除法指令，完成AX ÷ 操作数，存入AX</span><br><span class="line"></span><br><span class="line">CBW	;带符号数 字节扩展指令，将AL的8位拓展为16位</span><br><span class="line"></span><br><span class="line">CWD	;带符号数 字扩展指令，将AX的16位拓展为32位</span><br><span class="line"></span><br><span class="line">AAD	;非压缩BCD数除法结果校正</span><br><span class="line"></span><br><span class="line">;*********************************************************************************</span><br><span class="line"></span><br><span class="line">NOT	oprd	;将8位、16位寄存器或存储器内容求反</span><br><span class="line"></span><br><span class="line">AND	目的操作数,	源操作数	;目的操作数 ←- 目的操作数 与 源操作数</span><br><span class="line"></span><br><span class="line">OR	目的操作数,	源操作数	;目的操作数 ←- 目的操作数 或 源操作数</span><br><span class="line"></span><br><span class="line">XOR	目的操作数,	源操作数	;目的操作数 ←- 目的操作数 异或 源操作数</span><br><span class="line"></span><br><span class="line">TEST	目的操作数,	源操作数	;目的操作数 与 源操作数，但不会改变操作数的值，只会改ZF</span><br><span class="line"></span><br><span class="line">;*********************************************************************************</span><br><span class="line"></span><br><span class="line">;*****	S为Shift，非循环移位	*****</span><br><span class="line"></span><br><span class="line">SAL	oprd,	1	;算术左移1位，补0</span><br><span class="line">SAL	oprd,	CL	;算术左移多位，用CL控制次数，补0</span><br><span class="line"></span><br><span class="line">SAR	oprd,	1	;算术右移1位，算数右移补符号位</span><br><span class="line">SAR	oprd,	CL	;算术右移多位，用CL控制次数，算数右移补符号位</span><br><span class="line"></span><br><span class="line">SHL	oprd,	1	;逻辑左移1位，补0</span><br><span class="line">SHL	oprd,	CL	;逻辑左移多位，用CL控制次数，补0</span><br><span class="line"></span><br><span class="line">SHR	oprd,	1	;逻辑右移1位，逻辑右移补0</span><br><span class="line">SHR	oprd,	CL	;逻辑右移多位，用CL控制次数，逻辑右移补0</span><br><span class="line"></span><br><span class="line">;*****	R为Rotate，循环移位	*****</span><br><span class="line"></span><br><span class="line">ROL	oprd,	1	;将操作数oprd所有位都向左移，最高位复制到CF和最低位</span><br><span class="line">ROL	oprd,	CL	;将操作数oprd所有位都向左移CL指定的位数，最高位复制到CF和最低位</span><br><span class="line"></span><br><span class="line">ROR	oprd,	1	;将操作数oprd所有位都向右移，最低位移入最高位</span><br><span class="line">ROR	oprd,	CL	;将操作数oprd所有位都向右移CL指定的位数，最低位移入最高位</span><br><span class="line"></span><br><span class="line">RCL	oprd,	1	;把操作数oprd的每一位都向左移，CF复制到最低位，而最高位复制到CF</span><br><span class="line">RCL	oprd,	CL	;把操作数oprd的每一位都向左移CL指定的位数，CF复制到最低位，而最高位复制到CF</span><br><span class="line"></span><br><span class="line">RCR	oprd,	1	;把操作数oprd的每一位都向右移，CF复制到最高位，而最低位复制到CF</span><br><span class="line">RCR	oprd,	CL	;把操作数oprd的每一位都向右移CL指定的位数，CF复制到最高位，而最低位复制到CF</span><br><span class="line"></span><br><span class="line">;*********************************************************************************</span><br><span class="line"></span><br><span class="line">;*****	串处理指令用到的标志控制指令	*****</span><br><span class="line"></span><br><span class="line">CLD	;将方向标志位DF清零，即从低地址到高地址</span><br><span class="line"></span><br><span class="line">STD	;将方向标志位DF置1，即从高地址到低地址</span><br><span class="line"></span><br><span class="line">;*****	串处理指令	*****</span><br><span class="line">;*****	源操作数的逻辑地址由DS : SI给出	*****</span><br><span class="line">;*****	目的操作数的逻辑地址由ES : DI给出	*****</span><br><span class="line"></span><br><span class="line">MOVSB	;B为Byte，传输一个字节，目的操作数 ←- 源操作数</span><br><span class="line">MOVSW	;W为Word，传输一个字，目的操作数 ←- 源操作数</span><br><span class="line"></span><br><span class="line">CMPSB	;目的操作数 - 源操作数，与CMP指令类似，不会产生结果，只会影响ZF位</span><br><span class="line">CMPSW	;目的操作数 - 源操作数，与CMP指令类似，不会产生结果，只会影响ZF位</span><br><span class="line"></span><br><span class="line">SCASB	;AL - 目的操作数，用于在串中查找指定的信息，要搜索的关键字放在AL(字节)或AX(字)中</span><br><span class="line">SCASW	;AX - 目的操作数，用于在串中查找指定的信息，要搜索的关键字放在AL(字节)或AX(字)中</span><br><span class="line"></span><br><span class="line">LODSB	;AL ←- 源操作数，每执行一次，将存储单元的内容写入累加器</span><br><span class="line">LODSW	;AX ←- 源操作数，每执行一次，将存储单元的内容写入累加器</span><br><span class="line"></span><br><span class="line">STOSB	;目的操作数 ←- AL，每执行一次，将累加器的内容写入存储单元</span><br><span class="line">STOSW	;目的操作数 ←- AX，每执行一次，将累加器的内容写入存储单元</span><br><span class="line"></span><br><span class="line">;*********************************************************************************</span><br><span class="line"></span><br><span class="line">REPZ	CMPS	;可以用于判断两个串数据是否相等</span><br><span class="line"></span><br><span class="line">REPNZ	SCASB	;可以用于判断是否找到AX里的值</span><br><span class="line"></span><br><span class="line">;*********************************************************************************</span><br><span class="line"></span><br><span class="line">JMP	NEAR PTR	目标地址	;直接转移</span><br><span class="line">JMP	CX	;间接转移</span><br><span class="line">JMP	WORD PTR	[BX]	;间接转移</span><br><span class="line"></span><br><span class="line">;*****	LOOP, CALL, RET	*****</span><br><span class="line">C_16	PROC	NEAR		;标准C，16分音符</span><br><span class="line">	MOV		CX,	29</span><br><span class="line">	C_LOOP_16:</span><br><span class="line">		CALL	Music_C</span><br><span class="line">		LOOP	C_LOOP_16</span><br><span class="line">	RET</span><br><span class="line">C_16	ENDP</span><br><span class="line"></span><br><span class="line">STC	;使CF置1</span><br><span class="line">CLC	;使CF清0</span><br><span class="line">CMC	;使CF取反</span><br><span class="line"></span><br><span class="line">STD	;使DF置1</span><br><span class="line">CLD	;使DF清0</span><br><span class="line"></span><br><span class="line">STI	;使IF置1</span><br><span class="line">CLI	;使IF清0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="能用立即数的指令">能用立即数的指令</h3>
<p><code>MOV</code>可以立即数，<code>PUSH, POP, XCHG</code>不行</p>
<p><code>LEA</code>可以立即数，<code>LDS, LES</code>不行</p>
<p>加减法可以立即数，乘除法不行</p>
<p><code>ADD, ADC</code>可以立即数，<code>INC</code>不行</p>
<p><code>SUB, SBB</code>可以立即数，<code>DEC</code>不行</p>
<p><code>CMP</code>可以立即数，<code>NEG</code>不行</p>
<p><code>AND, OR, XOR, TEST</code>可以立即数，<code>NOT</code>不行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MOV</span><br><span class="line">IN		;立即数用来指明端口</span><br><span class="line">OUT		;立即数用来指明端口</span><br><span class="line">LEA		;立即数用来指定地址</span><br><span class="line">ADD</span><br><span class="line">ADC</span><br><span class="line">SUB</span><br><span class="line">SBB</span><br><span class="line">CMP</span><br><span class="line">AND</span><br><span class="line">OR</span><br><span class="line">XOR</span><br><span class="line">TEST</span><br></pre></td></tr></table></figure>
<h3 id="不能用立即数的指令">不能用立即数的指令</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PUSH</span><br><span class="line">POP</span><br><span class="line">XCHG</span><br><span class="line">LDS</span><br><span class="line">LES</span><br><span class="line">INC</span><br><span class="line">DEC</span><br><span class="line">NEG</span><br><span class="line">MUL</span><br><span class="line">IMUL</span><br><span class="line">DIV</span><br><span class="line">IDIV</span><br><span class="line">NOT</span><br><span class="line">SAL		;这些位移指令，可以移动1次，这里1应该不算立即数</span><br><span class="line">SAR		;把这些位移指令放在“不能立即数”，是因为oprd不能是立即数寻址</span><br><span class="line">SHL</span><br><span class="line">SHR</span><br><span class="line">ROL</span><br><span class="line">ROR</span><br><span class="line">RCL</span><br><span class="line">RCR</span><br></pre></td></tr></table></figure>
<h3 id="隐含没有操作数的指令">隐含/没有操作数的指令</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">XLAT	;隐含操作数，涉及的寄存器有AL和BX</span><br><span class="line">LAHF</span><br><span class="line">SAHF</span><br><span class="line">PUSHF</span><br><span class="line">POPF	;上面几个都是操作标志寄存器的，隐含操作数</span><br><span class="line">DAA		;没有操作数</span><br><span class="line">AAA		;没有操作数</span><br><span class="line">DAS		;没有操作数</span><br><span class="line">AAS		;没有操作数</span><br><span class="line">AAM		;没有操作数</span><br><span class="line">CBW</span><br><span class="line">CWD</span><br><span class="line">AAD</span><br><span class="line">CLD</span><br><span class="line">STD</span><br><span class="line">MOVSB</span><br><span class="line">MOVSW</span><br><span class="line">CMPSB</span><br><span class="line">CMPSW</span><br><span class="line">SCASB</span><br><span class="line">SCASW</span><br><span class="line">LODSB</span><br><span class="line">LODSW</span><br><span class="line">STOSB</span><br><span class="line">STOSW</span><br></pre></td></tr></table></figure>
<h2 id="指令集作业">指令集作业</h2>
<p>分别指出下列指令中的源操作数和目的操作数的寻址方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MOV		AX, [SI]			;1</span><br><span class="line">MOV		DI, 100				;2</span><br><span class="line">MOV		[BX], AL			;3</span><br><span class="line">MOV		[BX][SI], CX		;4</span><br><span class="line">ADD		AX, 106H[SI]		;5</span><br><span class="line">PUSH	AX					;6</span><br><span class="line">AND		DS:[BP], AX			;7</span><br><span class="line">OR		AX, DX				;8</span><br></pre></td></tr></table></figure>
<p>答：</p>
<p>目的操作数寻址方式 源操作数寻址方式</p>
<p>（1） 寄存器 寄存器间接</p>
<p>（2） 寄存器 立即</p>
<p>（3） 寄存器间接 寄存器</p>
<p>（4） 基址+变址 寄存器</p>
<p>（5） 寄存器 变址</p>
<p>（6） 寄存器间接 寄存器</p>
<p>（7） 带段超越的寄存器间接 寄存器</p>
<p>（8） 寄存器 寄存器</p>
<p>注：</p>
<p><code>PUSH</code>指令目的操作数是隐藏的，目的操作数为[SP]，因此寻址方式是<strong>寄存器间接</strong></p>
<p><br></p>
<p>形如<code>106H[SI]</code>这样的写法：</p>
<p>当使用寄存器BX或BP(Base
Pointer，基址指针，通常与SS搭配)时，称为“<strong>基址寻址</strong>”</p>
<p>当使用寄存器SI或DI时，称为“<strong>变址寻址</strong>”</p>
<p><br></p>
<p><code>[BX][SI]</code>这样的是基址+变址</p>
<p><br></p>
<p><code>DS:[BP]</code>这样的，指定一个非默认的段，这种方式是段超越</p>
<p>因为BP默认是跟SS搭配的，这里指明了DS段，所以是非默认段，就是段超越</p>
<p>同时也是寄存器间接</p>
<p><br></p>
<p><br></p>
<p>已知寄存器（DS）=2000H，（SS）=1500H，（ES）=3200H，（SI）=0A0H，（BX）=100H，（BP）=10H</p>
<p>数据段中变量VAL的偏移地址值为50H</p>
<p>试指出下列各条指令中源操作数的寻址方式是什么？对于存储器操作数，其物理地址是多少？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MOV		AX, [100H]</span><br><span class="line"></span><br><span class="line">MOV		CX, ES:[BX]</span><br><span class="line"></span><br><span class="line">MOV		DX, [BX][SI]</span><br><span class="line"></span><br><span class="line">MOV		AX, VAL[SI]</span><br><span class="line"></span><br><span class="line">MOV		BX, 1234[BX]</span><br><span class="line"></span><br><span class="line">MOV		AX, [BP]</span><br></pre></td></tr></table></figure>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231225180947727.png" class title="image-20231225180947727">
<p>注意BP与SS搭配</p>
<p><br></p>
<p><br></p>
<p>指令理解题：判断下列指令有无错误，若有，则改正</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">（1）PUSH       CL				;错：堆栈指令都是16位，CL只有8位</span><br><span class="line">（2）ADC        AX, 0ABH			;对</span><br><span class="line">（3）OUT        3EBH, AX			;错，3EBH这个地址超过8位，要用DX间接寻址</span><br><span class="line">（4）MUL        AL, CL			;错，MUL指令的AL应该是隐藏的</span><br><span class="line">（5）MUL        AX, 25			;错，除了AX隐藏以外，MUL指令也不能用立即数</span><br><span class="line">（6）ROL        DX, 5				;错，位移指令的次数应该用CL控制</span><br><span class="line">（7）CALL       FAR SUM			;对</span><br><span class="line">（8）POP        FR				;错，FR寄存器出栈用POPF</span><br><span class="line">（9）MOV       234H, BX			;错，MOV指令的目的操作数应该给地址，应该是[234H]</span><br><span class="line">（10）INC       [SI]				;错，要加BYTE PTR或WORD PTR，因为汇编器无法确定要操作的是一个8位的字节还是一个16位的字</span><br><span class="line">（11）ADD      [BX], 456H			;错，跟上一句一样的错误，要加BYTE PTR或WORD PTR</span><br><span class="line">（12）INT       0					;错，没有中断0这条指令</span><br><span class="line">（13）DIV       AX, BX			;错，DIV隐藏AX这个操作数</span><br><span class="line">（14）DEC       [BP]				;错，跟10一样的错，要加BYTE PTR或WORD PTR</span><br><span class="line">（15）XLAT       BX				;错，XLAT不需要操作数</span><br><span class="line">（16）ADD       CX+1				;错，加法指令应该是两个操作数</span><br><span class="line">（17）DAA       AX				;错，DAA不需要操作数</span><br></pre></td></tr></table></figure>
<p>答：</p>
<p>（1）有错。对<strong>堆栈操作总是16位的</strong>。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH	CX</span><br></pre></td></tr></table></figure>
<p>（2）无错。只是CF的值是不确定的，可能是1，也可能是0</p>
<p>（3）有错。输出设备的端口地址若是超过8位，应使用DX间接寻址。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV		DX,	3EBH</span><br><span class="line">OUT		DX,	AX</span><br></pre></td></tr></table></figure>
<p>（4）有错。乘法指令中有AX或AL寄存器是隐含的，故指令中仅出现第二个操作数，若为AL×CL，则改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL	CL</span><br></pre></td></tr></table></figure>
<p>（5）有错。与题（4）有类似错误，即乘法指令其中一个数隐含在AX或AL；同时还有一处错误：<strong>乘法指令中不能用立即数</strong>。改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV   BX, 25</span><br><span class="line">MUL   BX</span><br></pre></td></tr></table></figure>
<p>（6）有错。8086指令系统中，<strong>移位的次数由CL寄存器控制</strong>。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV	CL, 5</span><br><span class="line">ROL	DX, CL</span><br></pre></td></tr></table></figure>
<p>（7）无错。在CALL指令中提供子程序的属性（FAR或NEAR），使汇编程序在汇编过程中更快</p>
<p>（8）有错。寄存器FR是不能单独操作的。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POPF</span><br></pre></td></tr></table></figure>
<p>（9）有错。立即数不能作为目的操作数，因为它不可能存放任何信息。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV	BX,	234H</span><br><span class="line">或</span><br><span class="line">MOV	[234H],	BX</span><br></pre></td></tr></table></figure>
<p>（10）有错。该错误主要是针对汇编程序的，由于翻译这条指令时，不知是8位的还是16位的目标码，故要加入宏汇编的综合运算符PTR。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INC   BYTE PTR [SI]</span><br><span class="line">或</span><br><span class="line">INC   WORD PTR [SI]</span><br></pre></td></tr></table></figure>
<p>（11）有错。与第（10）题有同样的错，因为该指令中没有限定翻译成8位的还是16位的目标码。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD  WORD PTR [BX],	456H</span><br><span class="line">或</span><br><span class="line">ADD  BYTE PTR [BX],	456H</span><br></pre></td></tr></table></figure>
<p>（12）有错。这条指令是没有的，因为被零除一旦产生，自动转去执行中断</p>
<p>（13）有错。除法指令和乘法指令类似，AX是隐含的，指令中不出现。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DIV  BX</span><br></pre></td></tr></table></figure>
<p>（14）有错。除与第（10）题有类似的错误外，还要注意，用BP寄存器间接寻址形成物理地址时，段寄存器是SS而不是DS。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEC   WORD PTR [BP]</span><br><span class="line">或</span><br><span class="line">DEC   WORD PTR DS:[BP]</span><br></pre></td></tr></table></figure>
<p>（15）有错。XLAT的操作数是隐含的，它是一条复合指令，在执行该指令之前，将BX指向表的首地址，AL中存入被转换的码，然后才执行该指令。如果用户不按此操作，将得不到希望的结果</p>
<p>（16）有错。加法指令应该是2个操作数。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INC	CX</span><br><span class="line">或</span><br><span class="line">ADD	CX, 1</span><br></pre></td></tr></table></figure>
<p>（17）有错。调整指令是专门针对AL寄存器的内容进行调整的，故指令中操作数隐含。修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DAA</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<p>选择题：</p>
<p>（1）带符号数<code>-86</code>在微机中所表示的二进制数值是（）。</p>
<p>A. 10101010B B. 01100101B</p>
<p>C. 10011101B D. 11001011B</p>
<p>答案：A</p>
<p>86的二进制为<code>101_0110B</code></p>
<p>负数在计算机中存的补码：逐位取反加1（或者从右往左数到第一个1，这个1右边的值不变，左边全部取反），按这个计算得<code>010_1010</code></p>
<p>最后在前面加上符号位<code>1</code></p>
<p><code>-86</code>的补码就是<code>1010_1010B</code></p>
<p><br></p>
<p>（2）执行“<code>MOV DL, 2AH</code>”和“<code>SHR DL, 1</code>”两条指令后，DL寄存器与CF标志分别为（）。</p>
<p>A. DL=10110110B CF=1 B. DL=00110101B CF=0</p>
<p>C. DL=00110100B CF=1 D. DL=00010101B CF=0</p>
<p>答案：D</p>
<p>DL一开始是<code>0010_1010B</code></p>
<p><code>SHR DL, 1</code>这条指令是逻辑右移，移出来的位进入CF，补0</p>
<p>移出0进入CF，移位完是<code>0001_0101B</code></p>
<p><br></p>
<p>（3）可将AX寄存器中D0、D5、D8和D11位求反，其余位不变的指令是（）。</p>
<ol type="A">
<li><p><code>AND AX，921H</code> B. <code>OR    AX，910H</code></p></li>
<li><p><code>XOR AX，0921H</code> D.
<code>XOR  AX，0110H</code></p></li>
</ol>
<p>答案：C</p>
<p><code>XOR</code>：异或0，不变；异或1，取反</p>
<p><code>XOR    AX, 0000_1001_0010_0001B</code></p>
<p><br></p>
<p>（4）某存储单元的物理地址为3B4FEH，其段地址和偏移地址可分别选为（）。</p>
<p>A. 3B4FH和104EH B. 3B40H和00FEH</p>
<p>C. 2A00H和114FEH D. 3B4FEH和0</p>
<p>答案：B</p>
<p><code>3B4FEH = 3B40H * 10H + 00FEH</code></p>
<p><br></p>
<p>（5）两个8位二进制数00110101及10110110做“异或”操作后，寄存器FR的下面3个状态标志分别是（）。</p>
<p>A. PF=1，SF=0，ZF=0 B. PF=0，SF=1，ZF=1</p>
<p>C. PF=0，SF=1，ZF=0 D. PF=1，SF=1，ZF=1</p>
<p>答案：C</p>
<p>异或结果为：<code>1000_0011B</code></p>
<p>最高位符号位为1，则SF=1</p>
<p>结果不为0，ZF=0</p>
<p>PF（Parity
Flag）为奇偶标志位，低8位如果有偶数个1，则PF置1；奇数个1，则PF置0</p>
<p>3个1，奇数，PF=0</p>
<p><br></p>
<p>（6）当执行存储器写指令时，如“<code>MOV [SI], AX</code>”，则CPU的外部管脚状态是（）。</p>
<ol type="A">
<li><p>~ WR=1，~ RD=1，M / ~ IO=0 B. ~ WR=0，~ RD=1，M / ~ IO=0</p></li>
<li><p>~ WR=1，~ RD=0，M / ~ IO=1 D. ~ WR=0，~ RD=1，M / ~ IO=1</p></li>
</ol>
<p>答案：D</p>
<p>“存储器写”就得出答案：</p>
<p>对存储器操作，M / ~ IO=1（谁有效就操作谁）</p>
<p>写指令，~ WR=0，~ RD=1</p>
<h1 id="汇编语言程序设计">汇编语言程序设计</h1>
<h2 id="汇编语言语句">汇编语言语句</h2>
<h3 id="指令性语句">指令性语句</h3>
<p>由CPU执行</p>
<p>语句格式：方括号是可选段</p>
<p><code>[标号:] 操作码[操作数1],[操作数2] [;注释]</code></p>
<p>标号段：以“:”分界，不是必须，<strong>提供引用</strong></p>
<p>操作码段：必须</p>
<p>操作数段：可以是常数、寄存器、标号、变量和表达式</p>
<p>注释段：以分号开始；不被汇编程序翻译</p>
<h3 id="指示性语句">指示性语句</h3>
<p>由汇编程序执行：伪指令或指示符</p>
<p>语句格式：方括号是可选段</p>
<p><code>[标识符(名字)] 指示符(伪指令) 表达式 [;注释]</code></p>
<p>标识符段：伪指令指定；字母、数字或上下划线</p>
<p>指示符段：伪指令；汇编程序执行</p>
<p>表达式段：常数、寄存器、标号、变量、操作符的序列，分为数字表达式和地址表达式</p>
<h3 id="有关属性">有关属性</h3>
<p>段值属性：段起始地址，在段寄存器内，标号的段总是在CS寄存器中</p>
<p>段内偏移量属性：16位无符号数，从段起始地址到该操作数所在位置之间的字节数；当前地址计数器的值（$）</p>
<p>类型属性：标号，该标号在本段内引用还是在其他段内引用；段内引用，称之为NEAR，指针长度为2字节；在段间引用，称之为FAR，指针长度为4字节。变量，其类型属性用来指出该变量所保留的字节数，以BYTE、WORD或DWORD</p>
<h2 id="伪指令">伪指令</h2>
<p>伪指令又称伪操作，在汇编程序的指示性语句中作为指示符，在对汇编语言源程序进行汇编期间，是由汇编程序处理的操作</p>
<p>伪指令可以对数据进行定义，为变量分配存储区，定义一个程序或一个过程，指示程序结束等</p>
<h3 id="符号定义语句">符号定义语句</h3>
<h4 id="等值语句">等值语句</h4>
<p><code>符号名 EQU 表达式</code></p>
<p>相当于C语言的<code>#define</code></p>
<p>比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PORT	EQU 1234</span><br><span class="line">BUFF	EQU PORT+58</span><br><span class="line">MEM	EQU DS:[BP+20H]</span><br><span class="line">COUNT	EQU CX</span><br><span class="line">ABC	EQU AAA</span><br></pre></td></tr></table></figure>
<p>调用<code>MOV  AX, PORT</code>就相当于<code>MOV   AX, 1234</code></p>
<p>一个符号名用EQU语句只允许定义一次，否则会出现语法错误</p>
<h4 id="等号语句">等号语句</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NUM = 35</span><br><span class="line">...</span><br><span class="line">NUM = 7</span><br></pre></td></tr></table></figure>
<p>与<code>EQU</code>相似，但可以多次赋值</p>
<h3 id="变量定义语句">变量定义语句</h3>
<p>语句格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">符号名	DB/DW/DD 表达式</span><br></pre></td></tr></table></figure>
<p>DB：变量为字节型数据（8位，Byte）</p>
<p>DW：变量为字型数据（16位，Word）</p>
<p>DD：变量为双字型数据（32位，Double）</p>
<p><br></p>
<p>变量被定义以后就有了属性：</p>
<p>数据类型</p>
<p>分配内存单元，如果没有特别指定，就按先后顺序从偏移地址0000H开始存放</p>
<p>低位字节存低地址，高位存高地址</p>
<h4 id="定义一组数据">定义一组数据</h4>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BUFF1	DW 1234H, 0ABCDH, 8EH, -79DH</span><br><span class="line">BUFF2	DB 12H, 34H, CDH, 8EH</span><br></pre></td></tr></table></figure>
<p><code>BUFF1</code>为字型变量，<code>BUFF2</code>为字节型变量</p>
<p>相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> buff1[<span class="number">4</span>]=&#123;<span class="number">0x1234</span>,<span class="number">0x0abcd</span>,<span class="number">0x8e</span>,<span class="number">-0x79d</span>&#125;;</span><br><span class="line"><span class="type">char</span> buff2[<span class="number">4</span>]=&#123;<span class="number">0x12</span>,<span class="number">0x34</span>,<span class="number">0x0cd</span>,<span class="number">0x8e</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="定义一串字符">定义一串字符</h4>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR	DB	‘Welcome’</span><br></pre></td></tr></table></figure>
<p>定义STR为一个字节型变量，即一个字符占1字节，用ASCII码存放</p>
<p>单引号内是字符串</p>
<h4 id="定义保留存储单元">定义保留存储单元</h4>
<p>程序设计中，如果希望将运算结果保存到内存中，设计时就要预留一部分存储单元</p>
<p>也就是说，这些存储单元<strong>不需要预先赋值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUM	DW	?, ?</span><br></pre></td></tr></table></figure>
<p>从SUM偏移地址开始，为两个字型数据保留了4字节的内存单元</p>
<h4 id="复制操作">复制操作</h4>
<p><code>DUP</code>（Duplication）用于预置重复的数值</p>
<p>比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALL_ZERO	DB	0, 0, 0, 0, 0</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALL_ZERO	DB	5	DUP(0)</span><br></pre></td></tr></table></figure>
<h3 id="段定义语句">段定义语句</h3>
<p>比如我现在定义了两个变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XX1		DB	12H, 34H</span><br><span class="line">XX2		DW	1200H, 3400H</span><br></pre></td></tr></table></figure>
<p>我就可以用这两个变量了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV	AL,	XX1</span><br><span class="line">MOV	DX,	XX2</span><br></pre></td></tr></table></figure>
<p>但是在翻译成机器码时，汇编程序不能确定<code>XX1, XX2</code>是哪一个段，而无法进行正确汇编</p>
<p><code>XX1, XX2</code>不一定在数据段中，也可以在其他三个段中</p>
<p>而对不同的段，<code>MOV</code>指令机器码是不一样的</p>
<p>所以才出现段定义语句</p>
<h4 id="段定义语句segment">段定义语句<code>SEGMENT</code></h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段名	SEGMENT [定位类型][组合类型][‘类别’]</span><br><span class="line">...</span><br><span class="line">段名	ENDS</span><br></pre></td></tr></table></figure>
<p>但是太复杂，不需要考虑<code>[定位类型][组合类型][‘类别’]</code>这些</p>
<p>直接用这样简单的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段名	SEGMENT</span><br><span class="line">...</span><br><span class="line">段名	ENDS</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>比如刚刚的问题，就可以结合段定义语句，如此定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyData	SEGMENT</span><br><span class="line">XX1		DB	12H, 34H</span><br><span class="line">XX2		DW	1200H, 3400H</span><br><span class="line">MyData	ENDS</span><br></pre></td></tr></table></figure>
<p>这样就说明了<code>XX1, XX2</code>是在<code>MyData</code>段中</p>
<p>但是<code>MyData</code>段又在哪呢？还是不知道是在数据段还是其他段</p>
<p>于是就给出了另一个伪指令<code>ASSUME</code></p>
<h4 id="段说明语句">段说明语句</h4>
<p>伪指令<code>ASSUME</code>在汇编时能提供正确的段码，使汇编程序知道程序的段结构</p>
<p>格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASSUME	段寄存器名：段名[,…]</span><br></pre></td></tr></table></figure>
<p>段寄存器可以是CS, DS, SS, ES</p>
<p>段名是刚刚<code>SEGMENT</code>定义的标识符</p>
<p><br></p>
<p>伪指令<code>ASSUME</code>只是指定某段分配给哪个寄存器，<strong>并不能把段地址装入寄存器</strong>（因为伪指令不是由CPU执行）</p>
<p>利用伪指令<code>ASSUME</code>，接着对<code>XX1, XX2</code>进行完整定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MyData	SEGMENT</span><br><span class="line">XX1		DB	12H, 34H</span><br><span class="line">XX2		DW	1200H, 3400H</span><br><span class="line">MyData	ENDS</span><br><span class="line"></span><br><span class="line">MyCode	SEGMENT</span><br><span class="line">		ASSUME	CS:MyCode,	DS:MyData</span><br><span class="line">		MOV	AX,	MyData	</span><br><span class="line">		MOV	DS,	AX		;最开始还是需要把MyData放入DS</span><br><span class="line">		...</span><br><span class="line">		MOV	AL,	XX1</span><br><span class="line">		MOV	DX,	XX2</span><br><span class="line">		...</span><br><span class="line">MyCode	ENDS</span><br></pre></td></tr></table></figure>
<p>这样就可以了</p>
<h3 id="过程定义语句">过程定义语句</h3>
<p>注意：写子程序的时候<strong>先保护现场</strong>，最后返回现场</p>
<p>比如这段程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MUL10 PROC			;一个把AX乘10子程序，入口参数是AX，出口参数AX</span><br><span class="line">	PUSHF			;保护现场，保护标志寄存器和BX</span><br><span class="line">	PUSH BX</span><br><span class="line">				;下面是功能程序段，实现10×AX→AX</span><br><span class="line">	ADD	AX,	AX		;2XX →AX</span><br><span class="line">	MOV	BX,	AX		;2XX →BX</span><br><span class="line">	ADD	AX,	AX		;4XX →AX</span><br><span class="line">	ADD	AX,	AX		;8XX →AX</span><br><span class="line">	ADD	AX,	BX		;8XX+2XX →AX</span><br><span class="line">				;恢复现场</span><br><span class="line">	POP BX</span><br><span class="line">	POPF</span><br><span class="line">	RET</span><br><span class="line">MUL10 ENDP</span><br></pre></td></tr></table></figure>
<p>过程中用到了BX，就需要保护BX</p>
<p>并且还需要保护标志寄存器FR，于是最开始就<code>PUSHF</code>，最后<code>POPF</code></p>
<p>过程就是函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">过程名	PROC NEAR/FAR</span><br><span class="line">...</span><br><span class="line">RET</span><br><span class="line">过程名	ENDP</span><br></pre></td></tr></table></figure>
<p>过程名是标识符，是子程序入口的符号地址</p>
<p><code>NEAR, FAR</code>都是类型属性，<code>NEAR</code>为段内调用，<code>FAR</code>为段间调用</p>
<p>但根据我接口技术课设的情况来看，全写<code>NEAR</code>就行</p>
<p>一般，过程的最后是<code>RET</code>语句</p>
<p><code>PROC</code>和<code>ENDP</code>必须成对出现</p>
<p>这就不得不再次提及接口技术课设写的代码了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">C_4		PROC	NEAR		;标准C，4分音符</span><br><span class="line">	MOV		CX,	116</span><br><span class="line">	C_LOOP_4:					</span><br><span class="line">		CALL	Music_C</span><br><span class="line">		LOOP	C_LOOP_4</span><br><span class="line">	RET</span><br><span class="line">C_4		ENDP</span><br><span class="line"></span><br><span class="line">Music_C	PROC	NEAR	;C大调对应的标准C，应该延时1911us</span><br><span class="line">	CALL	W_L		;写0,蜂鸣器响</span><br><span class="line">	CALL	T100	;延时1000us</span><br><span class="line">	CALL	T50		;延时500us</span><br><span class="line">	CALL	T20		;延时200us</span><br><span class="line">	CALL	T20		;延时200us</span><br><span class="line">	CALL	T1		;延时10us</span><br><span class="line"></span><br><span class="line">	CALL	W_H		;写1,蜂鸣器不响</span><br><span class="line">	CALL	T100	;延时1000us</span><br><span class="line">	CALL	T50		;延时500us</span><br><span class="line">	CALL	T20		;延时200us</span><br><span class="line">	CALL	T20		;延时200us</span><br><span class="line">	CALL	T1		;延时10us</span><br><span class="line">	RET	</span><br><span class="line">Music_C	ENDP	</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>C_4</code>函数里面调用了<code>Music_C</code>函数</p>
<h3 id="结束语句end">结束语句<code>END</code></h3>
<p>就<code>END</code></p>
<h3 id="宏定义与宏调用">宏定义与宏调用</h3>
<p>接口技术课设都没用到这玩意，我感觉也不是重点</p>
<p>宏调用降低了执行时间</p>
<p><br></p>
<p>宏调用与子程序调用异同：</p>
<p>都避免相同代码的重复性</p>
<p>都增加了灵活性</p>
<p><strong>宏调用没有减少目标代码的存储空间，子程序调用减少了目标代码的存储空间</strong></p>
<p>宏调用降低了执行时间</p>
<h2 id="dos功能调用">DOS功能调用</h2>
<p>DOS功能调用号：所有子程序从<strong>1号</strong>开始顺序编号</p>
<p>调用过程为：</p>
<p>&lt;1&gt;DOS功能调用号送AH寄存器</p>
<p>&lt;2&gt;如果需要，按要求给定输入参数（有些无）</p>
<p>&lt;3&gt;写入中断指令“<code>INT 21H</code>”</p>
<p>&lt;4&gt;调用结束，按功能使用其输出参数</p>
<p><br></p>
<p>例如曾经用过的显示函数：</p>
<p>在屏幕上显示一个字符的指令段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV  DL, &lt;字符&gt;	;显示字符放入DL</span><br><span class="line">MOV  AH, 2		;DOS功能号为2</span><br><span class="line">INT  21H		;通过AH里的值调用DOS功能</span><br></pre></td></tr></table></figure>
<p>显示一个字符串同理，放入DX</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV  DX, &lt;字符串&gt;	;显示字符串地址放入DL</span><br><span class="line">MOV  AH, 9		;DOS功能号为9H</span><br><span class="line">INT  21H		;通过AH里的值调用DOS功能</span><br></pre></td></tr></table></figure>
<p>再比如程序结束代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV	AX,	4C00H	;4CH就是程序结束</span><br><span class="line">MOV	AH,	4CH		;这两句功能一样</span><br><span class="line">INT	21H</span><br></pre></td></tr></table></figure>
<h2 id="ppt上汇编的例子">PPT上汇编的例子</h2>
<p><strong>基本上从<code>DATA</code>段拿数组都是<code>LEA</code></strong></p>
<h3 id="顺序执行">顺序执行</h3>
<p>作业题会用到这个例子，留下印象比较好</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DATA	SEGMENT</span><br><span class="line">	BLOCK DW 0ABCDH</span><br><span class="line">	BUFF DD ?</span><br><span class="line">DATA	ENDS</span><br><span class="line">CODE	SEGMENT</span><br><span class="line">	ASSUME CS:CODE,DS:DATA</span><br><span class="line">START:MOV AX,DATA</span><br><span class="line">	MOV DS,AX</span><br><span class="line">	MOV DX,BLOCK		;先把数据段放入DS</span><br><span class="line">	MOV AX,DX</span><br><span class="line">	AND AX,0F0FH</span><br><span class="line">	AND DX,0F0F0H		;对AX和DX进行与操作，此时AX内容为0B0DH，DX内容为A0C0H</span><br><span class="line">	MOV CL,4</span><br><span class="line">	SHR DX,CL			;对DX右移4位，结果是0A0CH</span><br><span class="line">	LEA BX,BUFF			;将BUFF的偏移地址移到BX</span><br><span class="line">	MOV [BX+0],AL		;0DH</span><br><span class="line">	MOV [BX+1],DL		;0CH</span><br><span class="line">	MOV [BX+2],AH		;0BH</span><br><span class="line">	MOV [BX+3],DH		;0AH</span><br><span class="line">	MOV AX,4C00H</span><br><span class="line">	INT 21H</span><br><span class="line">CODE	ENDS</span><br><span class="line">	END	START</span><br></pre></td></tr></table></figure>
<p>这段程序先把数据段放入DS</p>
<p>再BLOCK放入AX与DX</p>
<p>然后对AX和DX进行与操作</p>
<p>此时AX内容为0B0DH，DX内容为A0C0H</p>
<p>然后对DX右移4位，结果是0A0CH（注意：移位针对的二进制，十六进制的一位就代表二进制4位）</p>
<p>将BUFF的偏移地址移到BX</p>
<p>然后从BUFF指定的地址开始，依次存入0DH, 0CH, 0BH, 0AH</p>
<h3 id="分支结构">分支结构</h3>
<p>判断MEMS单元数据，将结果存入MEMD单元</p>
<p>如果数据&gt;0，结果为1，如果数据&lt;0，结果为-1，如果数据=0，结果为0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">MY_D SEGMENT</span><br><span class="line">	MEMS DB 08H</span><br><span class="line">	MEMD DB ?</span><br><span class="line">MY_D ENDS</span><br><span class="line">MY_C SEGMENT</span><br><span class="line">	ASSUME DS:MY_D,CS:MY_C</span><br><span class="line">START:</span><br><span class="line">	MOV	AX,	MY_D</span><br><span class="line">	MOV	DS,	AX</span><br><span class="line">	MOV	AL,	MEMS 	;取MEMS的数据进入AL</span><br><span class="line">	CMP	AL,	0		;检查是否为0</span><br><span class="line">	JZ	ZERO		;如果是0就跳转到ZERO</span><br><span class="line">	TEST	AL,	1000_0000B	;最高位为符号位，TEST检测</span><br><span class="line">	JZ	NOT_NEG		;如果TEST与运算的结果为0，说明最高位不是1，即非负</span><br><span class="line">	MOV	AL,	-1		;如果没有在上一步跳转，则说明为负</span><br><span class="line">	JMP	DONE</span><br><span class="line">ZERO:</span><br><span class="line">	MOV	AL,	0</span><br><span class="line">	JMP	DONE</span><br><span class="line">NOT_NEG:</span><br><span class="line">	MOV	AL,	1</span><br><span class="line">	JMP	DONE</span><br><span class="line">DONE: </span><br><span class="line">	MOV	MEMD,	AL	;根据上面对AL的赋值，直接把AL的值存入MEMD单元</span><br><span class="line">	MOV	AX,	4C00H</span><br><span class="line">	INT	21H</span><br><span class="line">MY_C ENDS</span><br><span class="line">	END START</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>这段代码是我自己写的</p>
<p>我用来判断负数的方式是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV	AL,	MEMS 	;取MEMS的数据进入AL</span><br><span class="line">TEST	AL,	1000_0000B	;最高位为符号位，TEST检测</span><br><span class="line">JZ	NOT_NEG		;如果TEST与运算的结果为0，说明最高位不是1，即非负</span><br></pre></td></tr></table></figure>
<p>我看PPT还提供了一种方式判断是不是负数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV	AL,	[BX] ;取数据</span><br><span class="line">ADD	AL,	0    ;做ADD运算，影响标志SF</span><br><span class="line">JNS	AA1     ;是正数，转移</span><br><span class="line">INC	DL      ;是负数，统计加1</span><br></pre></td></tr></table></figure>
<p>挺有意思</p>
<h3 id="循环结构">循环结构</h3>
<p>编程统计BUFF缓冲区中负数的个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">	BUFF	DB 67H,9EH,-6AH,0ABH,6DH</span><br><span class="line">	MEM	DB ?</span><br><span class="line">DATA ENDS</span><br><span class="line">CODE SEGMENT</span><br><span class="line">	ASSUME CS:CODE,DS:DATA</span><br><span class="line">START:MOV	AX,	DATA</span><br><span class="line">	MOV	DS,	AX</span><br><span class="line">	MOV	CX,	5		;控制循坏次数</span><br><span class="line">	LEA	BX,	BUFF	;设置缓冲区指针</span><br><span class="line">	XOR	DL,	DL   	;统计计数器DL清零</span><br><span class="line">NEXT:</span><br><span class="line">	MOV	AL,	[BX] ;取数据</span><br><span class="line">	ADD	AL,	0    ;做运算，影响标志</span><br><span class="line">	JNS	AA1     ;SF为0，是正数，转移，相当于continue的功能</span><br><span class="line">	INC	DL      ;SF为1，是负数，统计加1</span><br><span class="line">AA1:  </span><br><span class="line">	INC	BX      ;移动指针，BX++</span><br><span class="line">	LOOP NEXT   ;循坏控制</span><br><span class="line">	MOV MEM,DL  ;保存统计结果</span><br><span class="line">	MOV AX,4C00H</span><br><span class="line">	INT 21H</span><br><span class="line">CODE ENDS</span><br><span class="line">	END START</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>编程统计AX寄存器中“1”的个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CODE SEGMENT</span><br><span class="line">	ASSUME CS:CODE</span><br><span class="line">START:</span><br><span class="line">	MOV	CX,	16         ;循环控制次数</span><br><span class="line">	XOR	DL,	DL         ;统计计数清零</span><br><span class="line">	CMP	AX,	0		;AX的内容为0吗？</span><br><span class="line">	JZ	DONE		;是0，结束循坏</span><br><span class="line">BB1:  </span><br><span class="line">	SHL AX,1          ;否则移动AX，移出去的1进入CF</span><br><span class="line">	ADC DL,0          ;利用ADC加CF的特性，统计“1”的个数</span><br><span class="line">	LOOP BB1</span><br><span class="line">DONE: </span><br><span class="line">	MOV	AX,	4C00H</span><br><span class="line">	INT	21H</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>在BLOCK内存区中有一串字符，试编程统计“%”之前的字符个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">	BLOCK DB ‘ANDEPO139%WR’</span><br><span class="line">	COUNT EQU $-BLOCK</span><br><span class="line">	MEM   DB  0</span><br><span class="line">DATA ENDS</span><br><span class="line">CODE SEGMENT</span><br><span class="line">	ASSUME CS:CODE,DS:DATA</span><br><span class="line">START:</span><br><span class="line">	MOV	AX,	DATA</span><br><span class="line">	MOV	DS,	AX		;把DATA放入DS</span><br><span class="line">	MOV	SI,	OFFSET BLOCK	;这句是把BLOCK的偏移地址移到SI，和LEA	SI, BLOCK功能完全一样</span><br><span class="line">	</span><br><span class="line">	;*****************</span><br><span class="line">	;上面的MOV	SI,	OFFSET BLOCK可以完全替换成LEA</span><br><span class="line">	;LEA	SI, BLOCK</span><br><span class="line">	;*****************</span><br><span class="line">	</span><br><span class="line">	MOV CX,	COUNT         </span><br><span class="line">LOOP1:</span><br><span class="line">	MOV AL,[SI]       ;取字符</span><br><span class="line">	CMP AL,‘%’	;是‘%’吗</span><br><span class="line">	JZ DONE		;是，结束循坏</span><br><span class="line">	INC BYTE PTR MEM  ;否，统计值加1</span><br><span class="line">	INC SI            ;移动指针</span><br><span class="line">	LOOP LOOP1        ;继续循坏</span><br><span class="line">DONE: </span><br><span class="line">	MOV AX,4C00H</span><br><span class="line">	INT 21H</span><br><span class="line">CODE ENDS</span><br><span class="line">   END START</span><br></pre></td></tr></table></figure>
<h3 id="子程序">子程序</h3>
<p>例：用子程序结构编写寄存器AX内容乘10，结果仍在AX中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">	XX	EQU	1000</span><br><span class="line">CODE SEGMENT</span><br><span class="line">	ASSUME CS:CODE</span><br><span class="line">START:</span><br><span class="line">	MOV	AX,	XX			;把AX赋值为1000=03E8H</span><br><span class="line">	CALL	MUL10		;调用把AX内容乘10子程序</span><br><span class="line">	MOV AX,	4C00H</span><br><span class="line">	INT	21H</span><br><span class="line">	</span><br><span class="line">MUL10 PROC			;一个把AX乘10子程序，入口参数是AX，出口参数AX</span><br><span class="line">	PUSHF			;保护现场，保护标志寄存器和BX</span><br><span class="line">	PUSH BX</span><br><span class="line">				;下面是功能程序段，实现10×AX→AX</span><br><span class="line">	ADD	AX,	AX		;2XX →AX</span><br><span class="line">	MOV	BX,	AX		;2XX →BX</span><br><span class="line">	ADD	AX,	AX		;4XX →AX</span><br><span class="line">	ADD	AX,	AX		;8XX →AX</span><br><span class="line">	ADD	AX,	BX		;8XX+2XX →AX</span><br><span class="line">				;恢复现场</span><br><span class="line">	POP BX</span><br><span class="line">	POPF</span><br><span class="line">	RET</span><br><span class="line">MUL10 ENDP</span><br><span class="line">CODE ENDS</span><br><span class="line">	END START</span><br></pre></td></tr></table></figure>
<p>注意保护现场</p>
<p><br></p>
<p>例：用子程序结构编写程序统计BX和DX中1的个数，结果分别放在CL和CH中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">CODE SEGMENT</span><br><span class="line">	ASSUME CS:CODE</span><br><span class="line">START:</span><br><span class="line">	MOV BX,	1234H	;设置BX的值</span><br><span class="line">	CALL COUNT</span><br><span class="line">	MOV CL,	AL</span><br><span class="line">	MOV DX,	8432H	;设置DX的值</span><br><span class="line">	MOV BX,	DX   ;把DX内容传送给BX，因为COUNT程序只检查BX里的1</span><br><span class="line">	CALL COUNT</span><br><span class="line">	MOV CH,	AL</span><br><span class="line">	MOV AX,	4C00H</span><br><span class="line">	INT 21H</span><br><span class="line">					;子程序COUNT的功能是统计BX中1的个数</span><br><span class="line">COUNT PROC			;AL存的是1的个数</span><br><span class="line">	PUSH CX</span><br><span class="line">	PUSHF</span><br><span class="line">	MOV	AL,	0		;初始化AL为0</span><br><span class="line">	MOV	CX,	16		;BX是16位</span><br><span class="line">COUNT1:</span><br><span class="line">	SHR BX,	1		;右移BX，移出位进入进位标志CF	</span><br><span class="line">	JNC COUNT2		;检测CF</span><br><span class="line">	INC AL			;CF为1，AL加1</span><br><span class="line">COUNT2:</span><br><span class="line">	LOOP COUNT1</span><br><span class="line">	POPF</span><br><span class="line">	POP CX</span><br><span class="line">	RET</span><br><span class="line">COUNT	ENDP</span><br><span class="line">CODE	ENDS</span><br><span class="line">	END	START</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>例：编写一个子程序，完成一个2位十六进制数到ASCII码的转换</p>
<p>子程序名：CONHA</p>
<p>功能：将2位十六进制数转换成ASCII码（比如<code>1FH</code>转为49_70，即<code>0011_0001_0100_0110B</code>）</p>
<p>输入参数：AL = 待转换的数</p>
<p>输出参数：BX = 转换好的ASCII码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">CODE	SEGMENT</span><br><span class="line">	ASSUME CS:CODE</span><br><span class="line">	</span><br><span class="line">CONHA	PROC FAR</span><br><span class="line">	PUSHF</span><br><span class="line">	MOV	AH,	AL		;先给AH备份一个相同的数</span><br><span class="line">LOW:</span><br><span class="line">	AND	AL,	0FH		;处理第一个十六进制数，屏蔽掉AL的前4位</span><br><span class="line">	MOV	CL,	AL	LT	0AH		;判断是否为数字，条件为比0AH小</span><br><span class="line">	CMP	CL,	1		;如果AL现在存的是0-9，就是数字，就进入LOW_NUM</span><br><span class="line">	JZ	LOW_NUM			</span><br><span class="line">	JMP	LOW_LETTER	;如果AL现在存的是A-F，就是字母，进入LOW_LETTER</span><br><span class="line">LOW_NUM:</span><br><span class="line">	ADD	AL,	&#x27;0&#x27;		;给数字加&#x27;0&#x27;，就转换为ASCII</span><br><span class="line">	MOV	BL,	AL		;第一个十六进制数的ASCII码放入BL</span><br><span class="line">	JMP HIGH		;跳转到HIGH</span><br><span class="line">LOW_LETTER:</span><br><span class="line">	ADD	AL,	&#x27;A&#x27;		;给字母加&#x27;A&#x27;，就转换为ASCII</span><br><span class="line">	MOV	BL,	AL		;第一个十六进制数的ASCII码放入BL</span><br><span class="line">	JMP HIGH		;跳转到HIGH</span><br><span class="line">HIGH:</span><br><span class="line">	AND	AH,	F0H		;处理第二个十六进制数，屏蔽掉AH的后4位</span><br><span class="line">	MOV	CL,	4</span><br><span class="line">	SHR	AH,	CL		;给AH存的数右移4位，如果AH本来为10H，位移后为01H</span><br><span class="line">	MOV	CH,	AH	LT	0AH		;判断是否为数字，条件为比0AH小</span><br><span class="line">	CMP	CH,	1		;如果AH现在存的是0-9，就是数字，就进入HIGH_NUM</span><br><span class="line">	JZ	HIGH_NUM	</span><br><span class="line">	JMP	HIGH_LETTER	;如果AH现在存的是A-F，就是字母，进入HIGH_LETTER</span><br><span class="line">HIGH_NUM:</span><br><span class="line">	ADD	AH,	&#x27;0&#x27;		;给数字加&#x27;0&#x27;，就转换为ASCII</span><br><span class="line">	MOV	BH,	AH		;第二个十六进制数的ASCII码放入BH</span><br><span class="line">	JMP END			;跳转到END</span><br><span class="line">HIGH_LETTER:</span><br><span class="line">	ADD	AH,	&#x27;A&#x27;		;给字母加&#x27;A&#x27;，就转换为ASCII</span><br><span class="line">	MOV	BH,	AH		;第二个十六进制数的ASCII码放入BH</span><br><span class="line">	JMP END			;跳转到END</span><br><span class="line">END:</span><br><span class="line">	POPF</span><br><span class="line">	RET</span><br><span class="line">CONHA	ENDP</span><br><span class="line">CODE	ENDS</span><br></pre></td></tr></table></figure>
<p>代码解释：</p>
<p>这是我自己写的，我只会用<code>JZ</code>，所以写的比较麻烦，不过功能应该是能实现</p>
<h3 id="设计实例">设计实例</h3>
<p>例：在偏移首地址为ARRAY的内存区有100个字型数据，要求将数组的每个元素加1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">	ARRAY DW 100DUP(?)     ;定义100个字型随机数</span><br><span class="line">DATA EDNS</span><br><span class="line">CODE SEGMENT</span><br><span class="line">	ASSUME DS:DATA,CS:CODE</span><br><span class="line">START:</span><br><span class="line">	MOV AX,	DATA</span><br><span class="line">	MOV DS,	AX				;DATA放进DS段</span><br><span class="line">	LEA BX,	ARRAY			;设置数组首地址指针</span><br><span class="line">	MOV CX,	LENGTH ARRAY		;数组数据长度</span><br><span class="line">AA1:  </span><br><span class="line">	INC	WORD PTR[BX]		;指定为字型数加1</span><br><span class="line">	ADD	BX,	2				;BX指针+2（因为是字型数据）</span><br><span class="line">	LOOP	AA1</span><br><span class="line">	MOV	AH,	4CH</span><br><span class="line">	INT	21H</span><br><span class="line">CODE	ENDS</span><br><span class="line">	END	START</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>例：有一个100个元素的BCD数组。编写程序对数组元素求和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">	XBCD	DB	12H,34H,......98H  ;定义100个BCD数</span><br><span class="line">	YBCD	DW	?                  ;求和结果放在YBCD中</span><br><span class="line">DATA ENDS</span><br><span class="line">CODE SEGMENT</span><br><span class="line">	ASSUME CS:CODE,DS:DATA</span><br><span class="line">START:</span><br><span class="line">	MOV	AX,	DATA	</span><br><span class="line">	MOV	DS,	AX		;DATA放进DS段</span><br><span class="line">	LEA	BX,	XBCD     ;设置寄存器BX为数组XBCD地址指针</span><br><span class="line">	MOV	CX,	100      ;数组长度送给寄存器CX</span><br><span class="line">	MOV AX,	0     	 ;计算结果在AX中，初始值为0</span><br><span class="line">AGAIN:</span><br><span class="line">	ADD	AL,	[BX]	;AL+一个数值元素→AL</span><br><span class="line">	DAA				;十进制调整</span><br><span class="line">	XCHG	AL,	AH	;因为DAA只修正AL的值，所以对进位CF的处理需要对AH加法，将AL与AH交换</span><br><span class="line">	ADC	AL,	0		;AL+CF→AL</span><br><span class="line">	DAA				;十进制调整</span><br><span class="line">	XCHG	AH,	AL	;AL与AH交换</span><br><span class="line">	INC	BX        	;指针加1</span><br><span class="line">	LOOP AGAIN    	;循环</span><br><span class="line">	MOV	YBCD,	AX   ;计算结果存入变量YBCD中</span><br><span class="line">	MOV	AX,	4C00H</span><br><span class="line">	INT 21H</span><br><span class="line">CODE ENDS</span><br><span class="line">	END START</span><br></pre></td></tr></table></figure>
<p>注：<code>DAA</code>指令只修改AL寄存器，但是仅仅8位的AL是绝对不满足这道题的要求的</p>
<p>所以就出现了中间这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADD	AL,	[BX]	;AL+一个数值元素→AL</span><br><span class="line">DAA				;十进制调整</span><br><span class="line">XCHG	AL,	AH	;因为DAA只修正AL的值，所以对进位CF的处理需要对AH加法，将AL与AH交换</span><br><span class="line">ADC	AL,	0		;AL+CF→AL</span><br><span class="line">DAA				;十进制调整</span><br><span class="line">XCHG	AH,	AL	;AL与AH交换</span><br></pre></td></tr></table></figure>
<p>就用BDC码运算<code>46H + 56H = 102H</code>来解释</p>
<p>AX现在值是<code>0046H</code>，[BX]存的是<code>0056H</code>，经过<code>ADD</code>指令，AL存的就是<code>46H + 56H = 9CH</code></p>
<p>紧接着就是一次<code>DAA</code>修正，会把<code>9CH</code>修正为<code>102H</code>，但是AL只有8位，所以AL新的值就是<code>02H</code>，产生CF=1的进位</p>
<p>这时AX的值就是<code>0002H</code>，但我们想让这个进位加到高位AH上</p>
<p>于是就产生了<code>XCHG AL, AH</code>这句指令，把AH和AL交换，AX现在的值就是<code>0200H</code></p>
<p>再进行带进位的加法<code>ADC</code>指令，AX的值就是<code>0201H</code></p>
<p>对这个值再进行BCD修正，这个虽然例子体现不出来</p>
<p>最后把AH和AL再交换一次，AX的值就是<code>0102H</code>，就满足了<code>46H + 56H = 102H</code></p>
<p><br></p>
<p>例：有两个无符号字节型数组，设数组元素个数相等，编程将数组中的对应元素相加，结果存入另一个内存区</p>
<p>作业也有一个类似的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">	M1 DB 20 DUP(?)</span><br><span class="line">	M2 DB 20 DUP(?)</span><br><span class="line">	M3 DW 20 DUP(0)		;M3是Word型，即2字节</span><br><span class="line">DATA ENDS</span><br><span class="line">CODE SEGMENT</span><br><span class="line">	ASSUME CS:CODE,DS:DATA</span><br><span class="line">START:</span><br><span class="line">	MOV	AX,	DATA</span><br><span class="line">	MOV DS,	AX		;DATA加到DS</span><br><span class="line">	LEA	SI,	M1		;添加M1数组地址</span><br><span class="line">	LEA	DI,	M2		;添加M2数组地址</span><br><span class="line">	LEA	BX,	M3		;添加M3数组地址</span><br><span class="line">	MOV	CX,	20		;指定循环次数为数组长度</span><br><span class="line">AA1:  </span><br><span class="line">	MOV	AL,	[SI]	;M1数组取数放入AL</span><br><span class="line">	ADD	AL,	[DI]	;M2数组取数与AL相加，相加可能会产生进位，这个CF进位要加到高地址（M3为Word型，两字节）上</span><br><span class="line">	MOV	[BX],	AL	;AL相加后的8位结果存入BX</span><br><span class="line">	ADC	BYTE PTR[BX+1],0   ;结果的进位与高地址字节相加，BYTE PTR指明从BX+1的地方拿1个字节</span><br><span class="line">	INC	SI</span><br><span class="line">	INC	DI			;SI和DI只用加1，因为是字节型</span><br><span class="line">	ADD	BX,	2		;BX加2，因为是字型</span><br><span class="line">	LOOP	AA1</span><br><span class="line">	MOV	AX,	4C00H</span><br><span class="line">	INT 21H</span><br><span class="line">CODE ENDS</span><br><span class="line">	END START</span><br></pre></td></tr></table></figure>
<p>注：虽然做加法很简单，但是容易忽略一点：8位相加会产生进位，这个进位就需要存起来，与后面的进位加起来得到最后的高位</p>
<p>因此声明结果数组的时候<code>M3 DW 20 DUP(0)</code>，声明的是<code>DW</code>，Word型，2字节16位</p>
<p>每次把进位的CF加到这个高字节上就行</p>
<p><code>ADC BYTE PTR[BX+1],0</code>，用<code>BYTE PTR[BX+1]</code>指明取出高字节，把CF加到这里就行</p>
<p><br></p>
<p>例：将寄存器AL中高、低字节交换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CODE	SEGMENT</span><br><span class="line">	ASSUME	CS:CODE</span><br><span class="line">START:</span><br><span class="line">	MOV	AL,	1234H</span><br><span class="line">	MOV	AH,	AL</span><br><span class="line">	MOV	CL,	4</span><br><span class="line">	ROL	AL,	CL		;循环位移即可实现</span><br><span class="line">	MOV	AH,	4CH</span><br><span class="line">	INT	21H</span><br><span class="line">CODE	ENDS</span><br><span class="line">	END	START</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>例：将AX中的内容按相反顺序存入BX中</p>
<p>将AX左移出来的数右移进BX即可</p>
<p>AX左移出来的数移进CF，BX这边用有CF的右移位即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CODE	SEGMENT</span><br><span class="line">	ASSUME	CS:CODE</span><br><span class="line">START:</span><br><span class="line">	MOV	AX, 1234H</span><br><span class="line">	MOV	CX,	16</span><br><span class="line">ROTATE_LOOP:</span><br><span class="line">	SHL	AX,	1</span><br><span class="line">	ROR	BX,	1</span><br><span class="line">	LOOP	ROTATE_LOOP</span><br><span class="line">	MOV	AH,	4CH</span><br><span class="line">	INT 21H</span><br><span class="line">CODE	ENDS</span><br><span class="line">	END	START</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>例：编程将将以“$”结束的字符串中的小写字母改为大写字母</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">DATA	SEGMENT</span><br><span class="line">STR	DB	&#x27;QWertyuiop!$&#x27;</span><br><span class="line">DATA	ENDS</span><br><span class="line"></span><br><span class="line">CODE	SEGMENT</span><br><span class="line">	ASSUME	CS:CODE,	DS:DATA</span><br><span class="line">START:</span><br><span class="line">	MOV	AX,	DATA</span><br><span class="line">	MOV	DS,	AX</span><br><span class="line">	LEA	BX,	STR</span><br><span class="line">ENDLESS_LOOP:</span><br><span class="line">	MOV	AL,	[BX]</span><br><span class="line">	CMP	AL,	&#x27;$&#x27;</span><br><span class="line">	JZ	DONE			;循环直到遇到$结束</span><br><span class="line">	MOV	CL,	AL	GE	&#x27;a&#x27;	;如果大于&#x27;a&#x27;，就是小写字母</span><br><span class="line">	CMP	CL,	1</span><br><span class="line">	JZ	CHANGE			;是小写字母就跳转CHANGE</span><br><span class="line">    JMP	NEXT			;不是小写字母就跳转NEXT</span><br><span class="line">CHANGE:</span><br><span class="line">	MOV	DL,	&#x27;a&#x27;</span><br><span class="line">	SUB	DL,	&#x27;A&#x27;			;将&#x27;a&#x27;-&#x27;A&#x27;的差值存入DL</span><br><span class="line">	SUB	AL,	DL			;将小写字母减去差值</span><br><span class="line">	MOV	[BX],	AL		;将修改完的字母放回去</span><br><span class="line">NEXT:</span><br><span class="line">	INC	BX</span><br><span class="line">	JMP	ENDLESS_LOOP	;一直循环</span><br><span class="line">DONE:</span><br><span class="line">	MOV	AH,	4CH</span><br><span class="line">	INT	21H</span><br><span class="line">CODE	ENDS</span><br><span class="line">	END	START</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>例：编写程序，将0—9的数字转换成所要求的密码</p>
<p>明码和密码的映射关系位：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">9</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DATA	SEGMENT</span><br><span class="line">TABLE	DB	2,7,1,6,9,0,8,3,4,5	;密码表</span><br><span class="line">VAL1	DB	8,1,4,7,5		;被加密码</span><br><span class="line">VAL2	DB	0,0,0,0,0		;解密码</span><br><span class="line">DATA	ENDS</span><br><span class="line"></span><br><span class="line">CODE	SEGMENT</span><br><span class="line">	ASSUME	CS:CODE,	DS:DATA</span><br><span class="line">START:</span><br><span class="line">	MOV	AX,	DATA</span><br><span class="line">	MOV	DS,	AX		;DATA入DS</span><br><span class="line">	LEA	BX,	TABLE	;密码表的地址存入BX		基本上从DATA段拿数据地址都是LEA</span><br><span class="line">	LEA	SI,	VAL1	</span><br><span class="line">	LEA	DI,	VAL2</span><br><span class="line">	MOV	CX,	5</span><br><span class="line">MY_LOOP:</span><br><span class="line">	MOV	AL,	[SI]	;取被加密码</span><br><span class="line">	XLAT			;BX+AL地址取值，替换AL，BX地址为密码表地址，AL就是被加密码</span><br><span class="line">	MOV	[DI],	AL	;解密码保存</span><br><span class="line">	INC	SI</span><br><span class="line">	INC	DI</span><br><span class="line">	LOOP	MY_LOOP</span><br><span class="line">	MOV	AH,	4CH</span><br><span class="line">	INT	21H</span><br><span class="line">CODE	ENDS</span><br><span class="line">	END	START</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>例：从键盘输入两个1位十进制数，求两数之和且在屏幕上显示结果</p>
<p>键盘输入DOS功能编号为：1</p>
<p><strong>输入到AL</strong>中，为ASCII码</p>
<p>屏幕显示DOS功能编号为：2</p>
<p>把<strong>DL</strong>的ASCII码<strong>输出</strong>到屏幕</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CODE	SEGMENT</span><br><span class="line">	ASSUME CS:CODE</span><br><span class="line">START:</span><br><span class="line">	MOV	AH,	1		;DOS调用输入第一个数到AL</span><br><span class="line">	INT	21H</span><br><span class="line">	MOV	BL,	AL		;保存输入的第一个数到BL</span><br><span class="line">	MOV AH,	1		;DOS调用输入第二个数到AL</span><br><span class="line">	INT	21H</span><br><span class="line">	ADD	AL,	BL		;两个ASCII码相加</span><br><span class="line">	AAA				;调整加法结果位非压缩BCD数</span><br><span class="line">	MOV	DL,	AL</span><br><span class="line">	ADD	DL,	&#x27;0&#x27;		;将数字转换为对应的ASCII码</span><br><span class="line">	MOV	AH,	2		;DOS输出到屏幕</span><br><span class="line">	INT	21H</span><br><span class="line">	MOV AX,4C00H</span><br><span class="line">	INT 21H</span><br><span class="line">CODE	ENDS</span><br><span class="line">	END	START</span><br></pre></td></tr></table></figure>
<p>感觉这段代码还是有问题，不过这之后再说了，这个例子只是让我们知道DOS调用：1是键盘输入到AL，2是DL输出到屏幕</p>
<h2 id="汇编作业">汇编作业</h2>
<p>编写8086汇编语言程序，将寄存器AX的高8位传送到寄存器BL，AX的低8位传送到寄存器DL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CODE	SEGMENT</span><br><span class="line">	ASSUME	CS:CODE</span><br><span class="line">START:</span><br><span class="line">	MOV	BL,	AH</span><br><span class="line">	MOV	DL,	AL</span><br><span class="line">	MOV	AX,	4C00H</span><br><span class="line">	INT 21H</span><br><span class="line">CODE	ENDS</span><br><span class="line">	END	START</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>试统计9个数中偶数的个数，并将结果在屏幕上显示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">DATA	SEGMENT</span><br><span class="line">ARR	DB	1,2,3,4,5,6,7,8,9</span><br><span class="line">DATA	ENDS</span><br><span class="line">CODE	SEGMENT</span><br><span class="line">	ASSUME	CS:CODE,	DS:DATA</span><br><span class="line">START:</span><br><span class="line">	MOV	AX,	DATA</span><br><span class="line">	MOV	DS,	AX			;DATA入DS</span><br><span class="line">	LEA	BX,	ARR</span><br><span class="line">	MOV	CX,	9</span><br><span class="line">	XOR	DL,	DL			;用DL计数，先清零DL</span><br><span class="line">MY_LOOP:</span><br><span class="line">	MOV	AL,	[BX]</span><br><span class="line">	TEST	AL,	0000_0001B	;和01H与，如果结果为0，说明是偶数</span><br><span class="line">	JZ	EVEN			;结果为0，偶数，跳转EVEN</span><br><span class="line">	JMP	ODD				;结果不为0，奇数，跳转ODD</span><br><span class="line">EVEN:</span><br><span class="line">	INC	DL</span><br><span class="line">	JMP	NEXT</span><br><span class="line">ODD:</span><br><span class="line">	JMP	NEXT</span><br><span class="line">NEXT:</span><br><span class="line">	INC	BX</span><br><span class="line">	LOOP	MY_LOOP</span><br><span class="line">	ADD	DL,	&#x27;0&#x27;		;将DL内容转换为ASCII</span><br><span class="line">	MOV	AH,	2H</span><br><span class="line">	INT	21H</span><br><span class="line">	MOV	AH,	4CH</span><br><span class="line">	INT	21H</span><br><span class="line">CODE	ENDS</span><br><span class="line">	END	START</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>完成10个压缩BCD数相加，且将结果显示出来</p>
<p>如果是10个两位压缩BCD数相加：</p>
<p>多字节显示到显示屏：DOS调用号为9</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">DATA	SEGMENT</span><br><span class="line">XBCD	DB	12H,23H,34H,45H,56H,67H,78H,89H,90H,77H</span><br><span class="line">YBCD	DW	?				;加法结果</span><br><span class="line">DISPBUFF	DB	0,0,0,0		;显示区缓冲，4个字节，用于DOS调用显示多个数</span><br><span class="line">DATA	ENDS</span><br><span class="line">CODE	SEGMENT</span><br><span class="line">	ASSUME	CS:CODE,	DS:DATA</span><br><span class="line">START:</span><br><span class="line">	MOV	AX,	DATA</span><br><span class="line">	MOV	DS,	AX</span><br><span class="line">	LEA	BX,	XBCD	;BCD数组放入BX</span><br><span class="line">	XOR	AX,	AX		;结果放入AX，初始化清零</span><br><span class="line">	MOV	CX,	10		;循环次数</span><br><span class="line">MY_LOOP:</span><br><span class="line">	ADD	AL,	[BX]	;取值直接加到AL</span><br><span class="line">	DAA				;BCD修正</span><br><span class="line">	XCHG	AH,	AL	;交换AL和AH</span><br><span class="line">	ADC	AL,	0		;进位CF加到AH</span><br><span class="line">	DAA				;再修正</span><br><span class="line">	XCHG	AH,	AL	;这样进位就成功加到AH</span><br><span class="line">	INC	BX</span><br><span class="line">	LOOP	MY_LOOP	;循环结束后，AX存的就是BCD加法的和，也是BCD码形式</span><br><span class="line">	MOV	YBCD	AX	;结果保存</span><br><span class="line">	;*************因为显示到屏幕上是用ASCII码的形式******************</span><br><span class="line">	;*************所以需要对AX的4位数都进行ASCII转换*****************</span><br><span class="line">	;*************先把AX的4位分别存储，再加&#x27;0&#x27;转换ASCII**************</span><br><span class="line">	;*************把4位分出来可以见PPT第一个例子*********************</span><br><span class="line">	MOV	BX,	AX		;举例：如果AX和BX都是1234H</span><br><span class="line">	AND	AX,	0F0FH	;与运算后AX为0204H</span><br><span class="line">	AND	BX,	F0F0H	;与运算后BX为1030H</span><br><span class="line">	MOV	CL,	4</span><br><span class="line">	SHR	BX,	CL		;BX内容右移4位，现在BX为0103H</span><br><span class="line">	ADD	BH,	&#x27;0&#x27;</span><br><span class="line">	ADD	BL,	&#x27;0&#x27;</span><br><span class="line">	ADD	AH,	&#x27;0&#x27;</span><br><span class="line">	ADD	AL,	&#x27;0&#x27;		;4个数进行ASCII转换</span><br><span class="line">	LEA	SI,	DISPBUFF	;显示区缓冲地址放入SI</span><br><span class="line">	MOV	[SI],	BH		;1的ASCII</span><br><span class="line">	MOV	[SI+1],	AH		;2的ASCII</span><br><span class="line">	MOV	[SI+2],	BL		;3的ASCII</span><br><span class="line">	MOV	[SI+3],	AL		;4的ASCII</span><br><span class="line">	LEA	DX,	DISP		;DISP地址放入DX</span><br><span class="line">	MOV	AH,	9			;调用DOS的9号功能：显示多字符</span><br><span class="line">	INT	21H</span><br><span class="line">	MOV	AH,	4CH</span><br><span class="line">	INT	21H</span><br><span class="line">CODE	ENDS</span><br><span class="line">	END	START</span><br></pre></td></tr></table></figure>
<p>如果是10个4位压缩BCD数相加</p>
<p>你妈的，这个好几把麻烦，考试不可能考这么难，我宣布不看这个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">DATA	SEGMENT</span><br><span class="line">SBUFF	DW   1234H, 5678H, 9321H,…	;定义10个4位BCD数</span><br><span class="line">DBUFF	DW   ?, ?                  	;加法结果区</span><br><span class="line">COUNT	EQU   (DBUFF-SBUFF)/2     	;数据长度</span><br><span class="line">DATA	ENDS</span><br><span class="line"></span><br><span class="line">CODE	SEGMENT</span><br><span class="line">	ASSUME CS:CODE, DS:DATA</span><br><span class="line">START:  </span><br><span class="line">    MOV	AX,	DATA</span><br><span class="line">    MOV	DS,	AX</span><br><span class="line">    LEA	SI,	SBUFF		;数据区地址指针</span><br><span class="line">    LEA	DI,	DBUFF		;结果区地址指针</span><br><span class="line">    XOR	DL,	DL			;保存加法进位寄存器</span><br><span class="line">    MOV	AX,	0			;清空AX</span><br><span class="line">LOP1:   </span><br><span class="line">	MOV	BX, [SI]		;取4位的BCD数</span><br><span class="line">    ADD	AL, BL			;先做低2位加</span><br><span class="line">    DAA					;调整</span><br><span class="line">    MOV	[DI], AL		;存低2位临时结果</span><br><span class="line">    MOV	AL, AH			;做高2位加</span><br><span class="line">    ADC	AL, BH			;考虑上一步加法进位</span><br><span class="line">    DAA</span><br><span class="line">    MOV	[DI+1], AL		;存高2位临时结果</span><br><span class="line">    MOV	AL, DL			;统计上一次的进位</span><br><span class="line">    ADC	AL, 0</span><br><span class="line">    DAA					;调整进位位十进制数</span><br><span class="line">    MOV	DL, AL			;保存进位待下次加法用</span><br><span class="line">    MOV	AX, [DI]		;取低字节加法结果备下次加法用</span><br><span class="line">    LOOP	LOP1		;循坏执行加法、调整</span><br><span class="line">    ADD	DI, 2</span><br><span class="line">    MOV	[DI], DL</span><br><span class="line">    MOV	AX, 4C00H</span><br><span class="line">    INT	21H</span><br><span class="line">CODE	ENDS</span><br><span class="line">	END	START</span><br></pre></td></tr></table></figure>
<p>你妈的，这个好几把麻烦，考试不可能考这么难，我宣布不看这个</p>
<p><br></p>
<p>编写程序，将一串混乱的字母按从小到大的顺序排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">DATA	SEGMENT</span><br><span class="line">STR	DB	&#x27;QWERTYUIOPAZAZA&#x27;</span><br><span class="line">LIST	DB	26	DUP(0)			;桶排序的桶，字母表有26个字母，所以长度为26</span><br><span class="line">RESULT	DB	15	DUP(0)			;结果字符串，跟原字符串等长度，15</span><br><span class="line">DATA	ENDS</span><br><span class="line"></span><br><span class="line">CODE	SEGMENT</span><br><span class="line">	ASSUME	CS:CODE,	DS:DATA</span><br><span class="line">START:</span><br><span class="line">	MOV	AX,	DATA</span><br><span class="line">	MOV	DS,	AX</span><br><span class="line">	LEA	SI,	STR		;待排序字符串</span><br><span class="line">	LEA	DI,	LIST	;桶数组</span><br><span class="line">	MOV	CX,	LENGTH	STR</span><br><span class="line">MY_LOOP:</span><br><span class="line">	MOV	AL,	[SI]	;拿字符</span><br><span class="line">	SUB	AL,	&#x27;A&#x27;		;字符 - &#x27;A&#x27;算出偏移存进AL</span><br><span class="line">	INC	[DI+AL]		;偏移算出桶下标，对应数值++</span><br><span class="line">	INC	SI			;字符下标++</span><br><span class="line">	LOOP	MY_LOOP</span><br><span class="line">	;*********经过循环，得到的LIST就存了每个字母出现的次数*******</span><br><span class="line">	;*********遍历这个LIST数组，将非零元素输出到结果字符串*******</span><br><span class="line">	LEA	SI,	LIST	;桶数组</span><br><span class="line">	LEA	DI,	RESULT	;结果字符串</span><br><span class="line">	MOV	CX,	25		;循环次数</span><br><span class="line">	MOV	DL,	0		;控制结果字符串下标</span><br><span class="line">OUTPUT_LOOP:</span><br><span class="line">	MOV	AL,	[SI]	;取出桶中的值到AL</span><br><span class="line">	CMP	AL,	0		;测试是否为0</span><br><span class="line">	JZ	OUT		;如果为0，跳过</span><br><span class="line">	MOV	BL,	SI		;SI为桶的下标</span><br><span class="line">	ADD	BL,	&#x27;A&#x27;		;算出应该存放的字母，存到BL</span><br><span class="line">DECREASE_AL_LOOP:	;这个循环是用来给结果字符串加相同字母</span><br><span class="line">	MOV	[DI+DL]	BL</span><br><span class="line">	INC	DL</span><br><span class="line">	DEC	AL</span><br><span class="line">	CMP	AL,	0</span><br><span class="line">	JZ	OUT</span><br><span class="line">	JMP	DECREASE_AL_LOOP</span><br><span class="line">OUT:</span><br><span class="line">	INC	SI			;桶下标加1</span><br><span class="line">	LOOP	OUTPUT_LOOP	;循环结束后，RESULT就是排序后的结果字符串</span><br><span class="line">	LEA	DX,RESULT	;DOS调用显示</span><br><span class="line">	MOV	AH,	9</span><br><span class="line">	INT 21H</span><br><span class="line">	MOV	AH,	4CH</span><br><span class="line">	INT	21H</span><br><span class="line">CODE	ENDS</span><br><span class="line">	END	START</span><br></pre></td></tr></table></figure>
<h1 id="总线和存储">总线和存储</h1>
<h2 id="总线分类-1">总线分类</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101205616548.png" class title="image-20240101205616548">
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101205602275.png" class title="image-20240101205602275">
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101205606396.png" class title="image-20240101205606396">
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101205626460.png" class title="image-20240101205626460">
<h2 id="总线结构">总线结构</h2>
<p>单总线结构：分时调用占用</p>
<p>双总线结构：面向CPU和面向主存</p>
<p>多总线结构</p>
<h2 id="总线基本功能">总线基本功能</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101205752871.png" class title="image-20240101205752871">
<h2 id="存储器分类">存储器分类</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101205816859.png" class title="image-20240101205816859">
<h2 id="总线作业">总线作业</h2>
<p>在8086系统中，试用8K×8位的EPROM
2764、8K×8位的静态6264和74LS138译码器，构成一个16KB的ROM（从F0000H开始）和16KB的RAM（从C0000H开始），设8086工作于最小模式。画出硬件连接图，写出ROM和RAM的地址范围</p>
<p>答：</p>
<p>起始地址、容量都告诉你了，这个题还是很容易的</p>
<p>16KB，需要2片8K*8位，两个都是</p>
<p>要构成一个16KB（16K×8）位的ROM，需要两片EPROM 2764（8K×8位）</p>
<p>再计算地址，16K，就是<span class="math inline">\(2^4\times2^{10}=2^{14}\)</span>，则需要14根地址线</p>
<p>起始地址F0000H为：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101211000285.png" class title="image-20240101211000285">
<p>如果占用14根地址线，就是A0-A13，也就是说，A19到A14是不变的</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101211027146.png" class title="image-20240101211027146">
<p>可以利用这4个1和2个0来连接138</p>
<p>两片存储芯片，分别存偶地址和基地址，则可以用A0来控制偶地址存储器和基地址存储器</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101211840145.png" class title="image-20240101211840145">
<p>刚好，有A15A14这两个0，结合能变的A0，就是000和001，完美符合两种地址选择</p>
<p>剩下的，就是能让芯片正常工作了：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101211810868.png" class title="image-20240101211810868">
<p>另一个同理：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101211825753.png" class title="image-20240101211825753">
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101211851014.png" class title="image-20240101211851014">
<p>不变的地址：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101211857791.png" class title="image-20240101211857791">
<p>最后连接：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101211921062.png" class title="image-20240101211921062">
<h1 id="io">IO</h1>
<p>IO接口：把外设连接到总线上的一组逻辑电路的总称。实现外设与主机之间的信息交换</p>
<h2 id="io接口要解决的问题">IO接口要解决的问题</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101212213526.png" class title="image-20240101212213526">
<h2 id="io接口功能">IO接口功能</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101212232092.png" class title="image-20240101212232092">
<h2 id="io接口编址方式">IO接口编址方式</h2>
<p>统一编址</p>
<p>独立编址</p>
<h3 id="统一编址">统一编址</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101212311503.png" class title="image-20240101212311503">
<h3 id="独立编址">独立编址</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101212324101.png" class title="image-20240101212324101">
<p>8086采用的就是独立编址</p>
<p>但是地址线和存储器共用</p>
<h2 id="接收外设信息">接收外设信息</h2>
<p>查询方式</p>
<p>中断方式</p>
<p>DMA</p>
<h3 id="查询">查询</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101212636876.png" class title="image-20240101212636876">
<h3 id="中断">中断</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101212649566.png" class title="image-20240101212649566">
<h3 id="dma">DMA</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101212703867.png" class title="image-20240101212703867">
<p>DMA有专门的DMA控制器进行控制</p>
<h1 id="计时器定时器芯片">8253计时器/定时器芯片</h1>
<p>可编程计数器核心电路就是一个事先可以设置计数常数的计数器，其记录脉冲方式和记满“溢出”方式都可以通过程序设定</p>
<h2 id="如何实现定时">如何实现定时</h2>
<p><strong>软件方法</strong>：用一段程序实现延时</p>
<p>利用程序循环延迟指定时间</p>
<p>缺点：延时精度，降低了CPU利用率</p>
<p><strong>硬件方法</strong>：设计定时/计数器电路</p>
<p>利用脉冲计数在设定的时间输出定时信号</p>
<h2 id="概况">8253概况</h2>
<p>内部有3个独立的16位的定时/计数器（通道），可对3个外设实现定时或计数</p>
<p>每个通道6种工作方式</p>
<p>24引脚双列直插式</p>
<p>最高计数频率2MHz</p>
<p>TTL电平兼容</p>
<p>单电源+5V供电</p>
<h2 id="引线图">8253引线图</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218164333705.png" class title="image-20231218164333705">
<p>具体引脚如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218164310827.png" class title="image-20231218164310827">
<p>~CS为片选信号</p>
<p>9,10,11为通道0，同理13,14,15为通道1，16,17,18为通道3</p>
<h3 id="连接至系统端的主要引线">连接至系统端的主要引线</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218164511901.png" class title="image-20231218164511901">
<p>注意地址顺序：先是计数器012，再是控制寄存器</p>
<p>这个地址顺序与编程有关，题目可能告诉你的是8253接口地址范围，比如0120H~0123H</p>
<p>记住最后一个是控制寄存器就行</p>
<h3 id="计数通道的主要引线">计数通道的主要引线</h3>
<p>每个通道均相同</p>
<p>CLK，时钟脉冲输入，计数器的计时基准</p>
<p>GATE，门控信号输入，控制计数器的启停（相当于让CLK信号进入计数器的开关）</p>
<p>OUT，计数器输出信号，不同工作方式下产生不同波形</p>
<h2 id="内部结构">8253内部结构</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218164102679.png" class title="image-20231218164102679">
<p>厂家把计数器电路集成在“通道”中，计数器012就是这3个通道</p>
<p><br></p>
<p>程序员视点：</p>
<p>计数器有3个，每一个计数器内部包括16位初值寄存器，16为计数寄存器（减法计数器）</p>
<p>控制寄存器有1个，存放控制命令字，<strong>仅写</strong>不能读</p>
<p>占用4个地址——3个计数器，1个控制寄存器</p>
<p><br></p>
<p>数据总线缓冲器是CPU与8253交换信息的必经之路</p>
<h2 id="定时计数工作过程">8253定时/计数工作过程</h2>
<h3 id="工作过程">工作过程</h3>
<p>1.设置8253的工作方式</p>
<p>2.设置计数初值到初值寄存器</p>
<p>3.<strong>第一个CLK信号</strong>使初值寄存器的内容置入计数寄存器</p>
<p>4.以后每来一个<strong>CLK</strong>信号，计数寄存器减1</p>
<p>5.减到0时，<strong>OUT</strong>端输出一特殊波形的信号</p>
<p>注：以上计数过程中还受到<strong>GATE</strong>信号的控制</p>
<p><br></p>
<p>首先，外电路的脉冲信号通过CLK进入通道，如果GATE有效，使CLK上的脉冲信号进入计数器计数，8253计数器工作在减1状态，每输入一个计数脉冲，计数器的值减1</p>
<p>当计数器计数到0的时候，OUT信号有效，通知外设计数器产生溢出</p>
<p>在通道工作过程中，CPU可以随时通过对端口的读/写，读取计数器的数据</p>
<h3 id="通道内部">通道内部</h3>
<p>在8253中，每个通道内部设置一个16位计数器，可进行二进制或BCD码计数</p>
<p>采用二进制计数时，最大计数值为0FFFFH</p>
<p>采用BCD码计数时，最大计数值为9999</p>
<p>与此计数器相对应，每个通道内部设置一个16位计数值锁存器，必要时用于锁存计数值</p>
<p>每一个计数器内部如图：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218170911203.png" class title="image-20231218170911203">
<h3 id="计数值的设置">计数值的设置</h3>
<p>当一个通道用作计数器时，应将要计数的次数预置到该通道的计数器中</p>
<p>当用作定时器时，从CLK输入一固定频率的时钟脉冲，再根据要求定时的时间算出定时所需计数值（时间常数），并预置到计数器中</p>
<p>计数值与定时时间、CLK端时钟脉冲信号周期的关系如下： <span class="math display">\[
计数值=\frac{定时时间}{时钟脉冲周期}
\]</span></p>
<p>比如我现在输入8253的时钟频率是2MHZ（<span class="math inline">\(2\times10^6\)</span>HZ）</p>
<p>时钟脉冲周期就是<span class="math inline">\(\dfrac{1}{2\times10^6HZ}=0.5\times10^{-6}s=0.5\mu
s\)</span></p>
<p>我需要随便一个计数器，启动计数10ms后OUT输出高电平</p>
<p>单位换算：<span class="math inline">\(1s=1\times10^{3}ms=1\times10^{6}\mu
s=1\times10^{9}ns\)</span> <span class="math display">\[
计数值=\frac{10ms}{0.5\mu s}=20000
\]</span>
所以就给计数器赋值20000即可，至于工作方式的选择，下面再细讲</p>
<h2 id="计数启动方式">计数启动方式</h2>
<p>程序指令启动——软件启动</p>
<p>外部电路信号启动——硬件启动</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218172704311.png" class title="image-20231218172704311">
<p>软件启动的GATE<strong>保持高电平</strong>，<strong>写入计数初值</strong>后的<strong>第2个</strong>CLK脉冲的<strong>下降沿</strong>开始计数</p>
<p>注：软件启动时GATE保持高电平，如果之后工作过程中GATE变成低电平，则说明计数暂停</p>
<p><br></p>
<p>硬件启动的GATE会有<strong>上升沿</strong>，<strong>对应</strong>CLK脉冲的<strong>下降沿</strong>开始计数</p>
<p>这些与8253的工作方式有关</p>
<h2 id="工作方式">8253工作方式</h2>
<p>总共6种工作方式</p>
<p>编号从0到5</p>
<p>0,4是软件启动</p>
<p>1,5是硬件启动</p>
<p>2,3是软件硬件启动</p>
<p>只有方式2和3自动重复计数</p>
<h3 id="方式0计数结束中断">方式0——计数结束中断</h3>
<p>方式0的作用就是用户可以在设定时间上产生中断信号</p>
<p><strong>软件</strong>启动，不自动重复计数（计数初值一次性使用有效）</p>
<p>控制字写入控制寄存器后，OUT端变低电平（一直保持低信号）</p>
<p>计数初值再写入通道后计数器就开始工作</p>
<p>计数结束OUT输出高电平</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218180112248.png" class title="image-20231218180112248">
<p>可见，方式0的GATE要一直为1才能正常工作，不然就暂停</p>
<h3 id="方式1可重复触发的单稳态触发器">方式1——可重复触发的单稳态触发器</h3>
<p>所谓单稳电路，就是在输入的激励下产生固定宽度的脉冲电路</p>
<p>硬件启动，不自动重复计数（如果再给一个GATE上升沿，会重新计数）</p>
<p>控制字写入控制寄存器后，OUT端变高电平</p>
<p>初始计数值写入通道后并不开始计数工作，而是等触发信号到来，即GATE上升沿</p>
<p>计数开始OUT端变为低电平</p>
<p>计数结束后又变高（类似一个低脉冲的效果）</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218181522702.png" class title="image-20231218181522702">
<p>如图，计数已结束，但是再来一个GATE上升沿仍会重新计数</p>
<p>如图，计数未结束时再来一个GATE上升沿，则会重新计数</p>
<h3 id="方式2频率发生器">方式2——频率发生器</h3>
<p>软、硬件启动，<strong>自动重复计数</strong></p>
<p>装入初值后OUT端变高电平，计数到最后一个CLK时（即计数到1）OUT输出一个CLK时钟的负脉冲，并<strong>连续重复此过程</strong></p>
<p>输入信号是周期性脉冲信号，输出信号也是周期性脉冲信号，从OUT输出</p>
<p>方式2实际上是一个可编程的分频电路，把输入信号分频后以脉冲的形式输出，分频系数是用户事先对通道计数器写入的初始计数值</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218182327100.png" class title="image-20231218182327100">
<h3 id="方式3方波发生器">方式3——方波发生器</h3>
<p>软、硬件启动，<strong>自动重复计数</strong></p>
<p>装入初值后OUT端变高电平</p>
<p>然后OUT连续输出对称方波，即同一周期内，前一半为高电平，后一半为低电平</p>
<p>如果计数初始值N为奇数，则前<span class="math inline">\(\dfrac{N+1}{2}\)</span>个CLK里OUT为高，后<span class="math inline">\(\dfrac{N-1}{2}\)</span>个CLK里OUT为低</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218182702598.png" class title="image-20231218182702598">
<h3 id="方式4软件触发选通">方式4——软件触发选通</h3>
<p>软件出发实际上就是CPU通过指令触发一个选通信号给外设，选通信号在触发后<strong>设定时间点</strong>上发出</p>
<p>软件启动，不自动重复计数</p>
<p>装入初值后输出端维持高电平</p>
<p>计数结束输出<strong>一个CLK宽度</strong>的负脉冲</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218183537455.png" class title="image-20231218183537455">
<h3 id="方式5硬件触发选通">方式5——硬件触发选通</h3>
<p>硬件启动，不自动重复计数</p>
<p>OUT端波形与方式4相同</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218183646824.png" class title="image-20231218183646824">
<h3 id="各种工作方式总结">各种工作方式总结</h3>
<h4 id="方式0计数结束中断-1">方式0（计数结束中断）</h4>
<p>计数过程中，GATE端应保持<strong>高电平</strong></p>
<p>每写入一次初值计数一个周期，然后停止计数</p>
<p>OUT端输出是一个约(N+1)TCLK宽度的负脉冲（写入控制字时变低，直到计数为0时升高，从头到尾算是一个负脉冲）</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095341089.png" class title="image-20231219095341089">
<p>计数过程中可随时修改初值重新开始计数</p>
<h4 id="方式1单稳态触发器">方式1（单稳态触发器）</h4>
<p>门控信号GATE端的跳变触发计数，可重复触发</p>
<p>若下一次GATE上升沿提前到达，则OUT端负脉冲拉宽为两次计数过程之和</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095419928.png" class title="image-20231219095419928">
<p>计数过程中写入新初值不影响本次计数</p>
<h4 id="方式2频率发生器-1">方式2（频率发生器）</h4>
<p>GATE为计数的控制信号：GATE变低计数停止，再变高时的下一个CLK下降沿，从初值开始重新计数</p>
<p>每个计数周期结束时（<strong>减到1时</strong>），OUT端输出一个TCLK宽度的负脉冲</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095500010.png" class title="image-20231219095500010">
<p>计数过程<strong>自动重复</strong>进行</p>
<p>计数过程中修改初值不影响本轮计数过程</p>
<h4 id="方式3方波发生器-1">方式3（方波发生器）</h4>
<p>OUT输出方波，前半周期为高，后半周期为低，一半一半</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095518357.png" class title="image-20231219095518357">
<p>计数过程中修改初值不影响<strong>本半轮</strong>计数过程</p>
<p>其余的与方式2类似</p>
<h4 id="方式4软件触发选通-1">方式4（软件触发选通）</h4>
<p>计数过程中，GATE端应保持<strong>高电平</strong></p>
<p>每写入一次初值，计数一个周期，然后停止计数</p>
<p>每个计数周期结束时（减到0时），OUT端输出一个TCLK宽度的负脉冲</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095544309.png" class title="image-20231219095544309">
<p>计数过程中修改初值不影响本轮计数过程</p>
<h4 id="方式5硬件触发选通-1">方式5（硬件触发选通）</h4>
<p>写入初值时，GATE端应保持<strong>低电平</strong></p>
<p>GATE每出现一次正脉冲，计数一个周期，然后停止计数</p>
<p>每个计数周期结束时（减到0时），OUT端输出一个TCLK宽度的负脉冲</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095544309.png" class title="image-20231219095544309">
<p>计数过程中修改初值不影响本轮计数过程</p>
<h3 id="gate信号功能表">GATE信号功能表</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218184150817.png" class title="image-20231218184150817">
<h2 id="控制字">8253控制字</h2>
<p>用于确定各计数器的工作方式</p>
<p>8253必须先初始化才能正常工作</p>
<p>每个计数器都必须初始化一次</p>
<p>CPU通过OUT指令把控制字写入<strong>控制寄存器</strong></p>
<h3 id="控制字格式">控制字格式</h3>
<p>8位控制字</p>
<p>控制字包括：指定计数器，对通道计数器的读写方式，指定通道工作方式，通道计数器计数时采用的数制信息（BCD或二进制）</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218184439221.png" class title="image-20231218184439221">
<p>每个寄存器都要记住</p>
<p>从高到底分别为：</p>
<p>SC1, SC0, RL1, RL0, M2, M1, M0, BCD</p>
<p>前两个SC选择了计数器</p>
<p>两个RL用于确定读/写操作的方式，同时也是计数长度的选择，00锁存，01低8位，10高8位，11先低后高两个字节，即计数值为16位</p>
<p>M2M1M0指定工作方式，其中方式2和3的编码很特殊，不考虑M2位</p>
<p>最低位的BCD指定是否BCD计数</p>
<h2 id="初始化顺序">8253初始化顺序</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218185220397.png" class title="image-20231218185220397">
<p><strong>先写方式控制字</strong>，按012的顺序</p>
<p>写计数值低8位后紧接着写同一个计数器的计数值高8位</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218185724423.png" class title="image-20231218185724423">
<p>比如：</p>
<p>FF04H, FF05H, FF06H分别对应计数器012的地址</p>
<p>FF07H为控制器地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MOV   DX,	FF07H		;控制器地址</span><br><span class="line">MOV   AL,	36H			;0011_0110B</span><br><span class="line">OUT   DX,	AL			;计数器0，先低后高16位，方式3，二进制</span><br><span class="line">MOV   AL,	71H			;0111_0001B</span><br><span class="line">OUT   DX,	AL			;计数器1，先低后高16位，方式0，BCD</span><br><span class="line">MOV   AL,	0B5H		;1011_0101B</span><br><span class="line">OUT   DX,	AL			;计数器2，先低后高16位，方式2，BCD</span><br><span class="line">MOV   DX,	0FF04H		;换地址到DX</span><br><span class="line">MOV   AL,	0A8H		;1010_1000B</span><br><span class="line">OUT   DX,	AL			;写计数器0的低8位</span><br><span class="line">MOV    AL,	61H			</span><br><span class="line">OUT    DX,	AL			;写计数器0的高8位</span><br><span class="line">MOV    DX,	0FF05H		;换地址</span><br><span class="line">MOV    AL,	00H</span><br><span class="line">OUT    DX,	AL			;写计数器1的低8位</span><br><span class="line">MOV    AL,	02H</span><br><span class="line">OUT    DX,	AL			;写计数器1的高8位</span><br><span class="line">MOV    DX,	0FF06H		;换地址</span><br><span class="line">MOV    AX,	0050H</span><br><span class="line">OUT    DX,	AL			;写计数器2的低8位</span><br><span class="line">MOV    AL,	AH</span><br><span class="line">OUT    DX,	AL 			;写计数器2的高8位</span><br></pre></td></tr></table></figure>
<p>总结：用到哪些计数器就写对应的控制字，先写控制字</p>
<p>然后再写对应的计数值</p>
<h2 id="与系统的连接图">8253与系统的连接图</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218203805355.png" class title="image-20231218203805355">
<p>注意，138译码器只连A15到A2</p>
<p>因为A1A0直接连8253的A1A0</p>
<h2 id="如何读出当前计数值">如何读出当前计数值</h2>
<p>第1种方法——在计数过程中读计数值</p>
<p>先锁存当前计数值，再用两条输入指令将16位计数值读出</p>
<p><br></p>
<p>第2种方法——停止计数器再读</p>
<p>用GATE信号使计数器停止，再规定RL1和RL0的读写格式，然后读出</p>
<h2 id="扩展定时计数范围">扩展定时/计数范围</h2>
<p>当定时长度不够时，可把2个或3个计数通道串联起来使用，甚至可把多个8253串联起来使用</p>
<p>例如：CLK频率为1MHz，要求在OUT1端产生频率1Hz的脉冲</p>
<p>计数值设置为： <span class="math display">\[
\frac{定时时间}{时钟脉冲周期}=\frac{1}{\frac{1}{1\times10^6}}=1\times10^6
\]</span> 但是计数值最大设置是FFFFH，即65535</p>
<p><span class="math inline">\(1\times10^6\)</span>比65536大，只用一个计数器位数设置不够</p>
<p>这时可将计数器0、1串联，工作方式都均为方式3，计数初值均为1000</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218225423320.png" class title="image-20231218225423320">
<h2 id="应用举例">8253应用举例</h2>
<p>采用8253作定时/计数器，其接口地址为0120H~0123H</p>
<p>输入8253的时钟频率为2M HZ</p>
<p>计数器0: 每10ms输出1个CLK脉冲宽的负脉冲</p>
<p>“每10ms”，自动重复，1个CLK的负脉冲，即方式2，设置计数值为<span class="math inline">\(\dfrac{10\times10^{-3}}{\frac{1}{2\times10^{-6}}}=2\times10^{4}\)</span></p>
<p>计数器1: 产生10KHz的连续方波信号</p>
<p>方波，一眼方式3，设置计数值为<span class="math inline">\(\dfrac{\frac{1}{10\times10^3}}{\frac{1}{2\times10^{-6}}}=\dfrac{2\times10^{6}}{10\times10^3}=200\)</span></p>
<p>计数器2: 启动计数5ms后OUT输出高电平</p>
<p>启动后低电平，结束后高电平，方式0，计数值设置为<span class="math inline">\(\dfrac{5\times10^{-3}}{\frac{1}{2\times10^{-6}}}=10^4\)</span></p>
<p>初始化顺序：</p>
<p>先写控制字，按照012的顺序写控制字</p>
<p>计数器0的控制字：<code>0011_0100B</code></p>
<p>计数器1的控制字：<code>0101_0110B</code></p>
<p>计数器2的控制字：<code>1011_0000B</code></p>
<h2 id="作业-1">8253作业</h2>
<p><a id="8253_1"></a></p>
<h3 id="section">1.</h3>
<p>某系统中8253芯片的端口地址为FFF0H-FFF3H</p>
<p>定义计数器0工作在方式3，CLK0=2MHz，要求输出OUT0=1KHz方波</p>
<p>定义计数器1工作在方式4，用OUT0作计数脉冲，计数值为1000</p>
<p>计数器1计到0，向CPU发中断请求，CPU响应这一中断后继续写入计数值1000，重复开始计数，保持1秒钟向CPU发出一次中断请求</p>
<p>请编写初始化程序，并画出硬件连接图</p>
<p>答：</p>
<p>涉及到中断，就需要8259A，所以初始化也需要考虑8259</p>
<p>但是题目里没有明确指明8259的地址，和对应的中断类型号，所以就可以任取</p>
<p>比如：我规定8259地址为20H-21H，中断类型号为E0H-E7H，中断用8259的IR0</p>
<p>题目规定说CPU响应中断，把1000再写入计数器，则说明中断程序的功能就是再把1000写入计数器，很容易</p>
<p><br></p>
<p>8253地址：</p>
<p><code>1111_1111_1111_0000B</code></p>
<p>到</p>
<p><code>1111_1111_1111_0011B</code></p>
<p>分析一下地址：8253的地址不变的是从A2-A15，所以就从这里入手，用138选通唯一的信号出去，这里就用Y0输出：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240102100352439.png" class title="image-20240102100352439">
<p>如图，A3A2都是0，所以用这两个信号选通Y0即可，剩下的就让138能够工作</p>
<p><br></p>
<p>8259地址：</p>
<p>20H-21H，不变的就是A1到A15，而且0很多，只有A5一个固定为1</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240102100704875.png" class title="image-20240102100704875">
<p>硬件连线图：按题目要求，OUT0输出接到CLK1的输入，OUT1输出接到8259的IR0，剩下的正常相连：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240102100750943.png" class title="image-20240102100750943">
<p>然后就是初始化程序：</p>
<p>分析控制字：</p>
<p>计数器0，则控制字最开头两位是0，即控制字的D7D6为00</p>
<p>计数长度：<span class="math inline">\(\dfrac{\frac{1}{1k}}{\frac{1}{2M}}=\dfrac{2\times10^6}{1\times10^3}=2\times10^3\)</span>，2000，换成二进制就是<code>0111_1101_0000B</code>，可以用除2余数倒着写得到；因为超过了8位，所以需要先低后高写入计数值，即控制字的D5D4为11</p>
<p>规定了计数器0在工作方式3，所以D3D2D1为011</p>
<p>最后没说是否BCD，就不用，D0为0</p>
<p>计数器0的控制字就是：<code>0011_0110B</code></p>
<p><br></p>
<p>计数器1，则控制字最开头两位是01，即控制字的D7D6为01</p>
<p>题目明确指明计数器1的计数值为1000，换成二进制就是<code>0011_1110_1000B</code>；因为超过了8位，所以需要先低后高写入计数值，即控制字的D5D4为11</p>
<p>题目明确规定计数器1工作方式为方式4，则D3D2D1为100</p>
<p>最后没说是否BCD，就不用，D0为0</p>
<p>计数器1的控制字就是：<code>0111_1000B</code></p>
<p><br></p>
<p>8253初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MOV	DX,	FFF3H		;8253控制口地址</span><br><span class="line">MOV	AL,	0011_0110B	;计数器0控制字</span><br><span class="line">OUT	DX,	AL			</span><br><span class="line">MOV	AL,	0111_1000B	;计数器1控制字</span><br><span class="line">OUT	DX,	AL</span><br><span class="line">MOV	DX,	FFF0H		;计数器0地址</span><br><span class="line">MOV	AL,	1101_0000B	;写2000的低八位</span><br><span class="line">OUT	DX,	AL</span><br><span class="line">MOV	AL,	0000_0111B	;写2000的高八位</span><br><span class="line">OUT	DX,	AL</span><br><span class="line">MOV	DX,	FFF1H		;计数器1地址</span><br><span class="line">MOV	AL,	1110_1000B	;写1000的低八位</span><br><span class="line">OUT	DX,	AL</span><br><span class="line">MOV	AL,	0000_0011B	;写1000的高八位</span><br><span class="line">OUT	DX,	AL</span><br></pre></td></tr></table></figure>
<p>因为题目用到了8259，所以也需要对8259初始化</p>
<p>题目对8259没有过多约束，所以很容易</p>
<p>ICW1：我觉得可以用边沿触发，指定结束方式（即写ICW4），所以就为<code>0001_0011B</code></p>
<p>ICW2：指定中断类型号，我规定IR0的中断类型号就是E0H所以ICW2就为<code>1110_0000B</code></p>
<p>没用级联，所以不写ICW3</p>
<p>ICW4：最普通的中断结束方法，就是<code>0000_0001B</code>，普通结束方式</p>
<p>OCW1：我不需要中断屏蔽，不写</p>
<p>OCW2：我不需要改变中断优先级，也不需要中断结束EOI，不写</p>
<p>OCW3：不需要屏蔽和读出控制字，不写</p>
<p>所以，初始化顺序就是：写ICW1, ICW2, ICW4没了</p>
<p><br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MOV	DX,	20H			;A0=0，写ICW1</span><br><span class="line">MOV	AL,	0001_0011B	;写ICW1，边沿触发</span><br><span class="line">OUT	DX,	AL</span><br><span class="line">MOV	DX,	21H			;A0=1，写ICW2, ICW4</span><br><span class="line">MOV	AL,	1110_0000B	;写ICW2，指定中断类型号为E0H</span><br><span class="line">OUT	DX,	AL</span><br><span class="line">MOV	AL,	0000_0001B	;写ICW4，普通结束方式</span><br><span class="line">OUT	DX,	AL</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>然后需要把IR0对应的中断服务子程序放入IVT中，不过在此之前，我们需要先定义这个程序，因为要知道名字</p>
<p>中断服务程序，首先需要保存一系列现场，比如FR，DS，还有用到的寄存器；其次，要关中断，用<code>CLI</code>指令，执行完内容后，开中断，弹出对应内容，最后记得结束中断服务程序，<code>IRET</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MYINT	PROC	FAR</span><br><span class="line">PUSHF</span><br><span class="line">PUSH	DS</span><br><span class="line">PUSH	AX</span><br><span class="line">PUSH	DX</span><br><span class="line">CLI					;关中断</span><br><span class="line">MOV	DX,	FFF1H		;计数器1地址</span><br><span class="line">MOV	AL,	1110_1000B	;写1000的低八位</span><br><span class="line">OUT	DX,	AL</span><br><span class="line">MOV	AL,	0000_0011B	;写1000的高八位</span><br><span class="line">STI					;开中断</span><br><span class="line">POP		DX</span><br><span class="line">POP		AX</span><br><span class="line">POP		DS</span><br><span class="line">POPF</span><br><span class="line">IRET				;记得中断返回</span><br><span class="line">MYINT	ENDP</span><br></pre></td></tr></table></figure>
<p>现在就可以把这段程序放入IVT了：</p>
<p>具体过程很容易，保护DS，关中断，把0放入DS，把中断类型号E0H乘4放入SI，把段偏移放入<code>[SI]</code>，把段基址放入<code>[SI+2]</code>，开中断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CLI</span><br><span class="line">PUSH	DS</span><br><span class="line">MOV	AX,	0</span><br><span class="line">MOV	DS,	AX			;0放入DS</span><br><span class="line">MOV	SI,	4 * E0H		;中断类型号乘4</span><br><span class="line">LEA	AX,	MYINT		</span><br><span class="line">MOV	[SI],	AX		;偏移地址放入[SI]</span><br><span class="line">MOV	AX,	SEG	MYINT</span><br><span class="line">MOV	[SI+2],	AX		;段基址放入[SI+2]</span><br><span class="line">POP		DS</span><br><span class="line">STI</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="section-1">2.</h3>
<p>若8253芯片的端口地址为D0D0H-D0D3H，时钟频率为2MHz。现利用其分别产生周期为10微秒的方波、每隔1mS和1S产生一个负脉冲，试画出其与系统的电路连接图，并编写包括初始在内的程序</p>
<p>答：</p>
<p>这个题只有8253，所以比较容易</p>
<p>方波：用方式3，计数值为<span class="math inline">\(\dfrac{10\times10^{-6}}{\frac{1}{2\times10^6}}=20\)</span></p>
<p>每隔：说明重复，用方式2或3，指定是负脉冲，就是方式2</p>
<p>每隔1ms：方式2，计数值为<span class="math inline">\(\dfrac{1\times10^{-3}}{\frac{1}{2\times10^6}}=2\times10^3=2000\)</span></p>
<p>每隔1s：方式2，计数值为<span class="math inline">\(\dfrac{1}{\frac{1}{2\times10^6}}=2\times10^6\)</span>，超过了65536</p>
<p>所以这个就得级联的形式，可以用每隔1ms的输出接到每隔1s的输入上，再计数就是<span class="math inline">\(\dfrac{1}{1\times10^{-3}}=1\times10^{3}=1000\)</span></p>
<p><br></p>
<p>所以，计数器0产生方波，工作在方式3，计数值为20，所以只需要写低8位即可，控制字为<code>0001_0110B</code></p>
<p>计数器1每隔1ms产生一个负脉冲，工作在方式2，计数值为2000，需要先写低八位再写高8位，控制字为<code>0111_0100B</code></p>
<p>计数器2每隔1s产生一个负脉冲，工作在方式2，计数值为1000，需要先写低八位再写高8位，控制字为<code>1011_0100B</code></p>
<p>并且，计数器1的输出接给计数器2的输入</p>
<p><br></p>
<p>地址分析：</p>
<p>不变的是A2-A15，能让138工作就行</p>
<p>还是用低位过CBA，变成000，选择Y0导通</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240102113340626.png" class title="image-20240102113340626">
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240102113454820.png" class title="image-20240102113454820">
<p>程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MOV	DX,	D0D3H		;控制器地址</span><br><span class="line">MOV	AL,	0001_0110B	;计数器0控制字</span><br><span class="line">OUT	DX,	AL</span><br><span class="line">MOV	AL,	0111_0100B	;计数器1控制字</span><br><span class="line">OUT	DX,	AL</span><br><span class="line">MOV	AL,	1011_0100B	;计数器2控制字</span><br><span class="line">OUT	DX,	AL</span><br><span class="line">MOV	DX,	D0D0H		;计数器0地址</span><br><span class="line">MOV	AL,	20			;写20</span><br><span class="line">OUT	DX,	AL</span><br><span class="line">MOV	DX,	D0D1H		;计数器1地址</span><br><span class="line">MOV	AL,	1101_0000B	;2000的低8位</span><br><span class="line">OUT	DX,	AL</span><br><span class="line">MOV	AL,	0000_0111B	;2000的高8位</span><br><span class="line">OUT	DX,	AL</span><br><span class="line">MOV	DX,	D0D1H		;计数器2地址</span><br><span class="line">MOV	AL,	1110_1000B	;写1000的低8位</span><br><span class="line">OUT	DX,	AL</span><br><span class="line">MOV	AL,	0000_0011B	;写1000的高8位</span><br><span class="line">OUT	DX,	AL</span><br></pre></td></tr></table></figure>
<h1 id="并行可编程接口芯片">8255并行可编程接口芯片</h1>
<p>其实CPU可以直接和外设相连，不用8255也可以</p>
<p>但是CPU只是发送信号，驱动能力很低（电流很低），接很多外设CPU扛不住</p>
<p>于是可以在CPU和外设之间加一块8255，既可以传信号，也可以增加驱动能力，还可以可靠传输</p>
<h2 id="概况-1">8255概况</h2>
<p>8255A是一种通用的可编程并行I/O接口芯片，具有3个独立的带锁存或缓存的数据端口，<strong>可与外设并行进行数据交换</strong></p>
<p>用户可以用程序选择多种操作方式，可为CPU与外设之间提供并行输入/出通道</p>
<p>各端口内具有中断控制逻辑，在外设与CPU之间可用中断方式进行信息交换，使用条件传输方式时可用“联络”线进行控制</p>
<p>可通过编程设置各端口工作方式和数据传送方向（入/出/双向）</p>
<p>并行数据宽度为8位</p>
<h2 id="引线图-1">8255引线图</h2>
<p>共40个引脚</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218203116142.png" class title="image-20231218203116142">
<h3 id="连接至系统端的主要引线-1">连接至系统端的主要引线</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218203215422.png" class title="image-20231218203215422">
<p>注意，地址是端口ABC然后是控制寄存器，跟8253类似</p>
<h3 id="连接外设端的引脚">连接外设端的引脚</h3>
<p>PA0-PA7</p>
<p>PB0-PB7</p>
<p>PC0-PC7</p>
<p>对应了A, B, C三个8位输入/输出端口</p>
<p>三个端口可通过<strong>编程</strong>分别指定为输入或输出口</p>
<p>其中，C口即可用作独立的输入/输出口，也可用作A、B口的<strong>控制信号输出</strong>或<strong>状态信号输入</strong></p>
<h2 id="内部结构-1">8255内部结构</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218203534742.png" class title="image-20231218203534742">
<p>厂家除了把输入/输出接口电路集成在一块芯片中，还包括控制这些接口电路的控制部分，以及与CPU接口的总线接口部分</p>
<p><br></p>
<p>8255A芯片中包含3个8位端口：A口，B口，C口</p>
<p>这三个端口均可以作为CPU与外设通信时的缓冲器或锁存器</p>
<p>一般来说，它们做缓冲器使用时，是输入接口；作为锁存器使用时，是输出接口</p>
<p><br></p>
<h3 id="c口可作为ab两端口的信号输入输出">C口可作为AB两端口的信号输入输出</h3>
<p>条件传输方式需要“状态”或“联络”信号</p>
<p>中断传输方式需要“中断”信号</p>
<p>由于8255没有预先从芯片引脚上给出这些信号，因此在用户选择这两种工作方式时，8255A将从C口的8位I/O线中提取若干根线作为“状态”“联络”或“中断”线；在这种状态下，C口剩余的线依然可以作为I/O线</p>
<p>也就是说C口相当于“握手协议”，维持传输的稳定</p>
<p>3个端口通过各自的I/O线与外设联系</p>
<h3 id="ab端口控制">AB端口控制</h3>
<p>8255A有3个端口，但不是每个端口都有自己独立的控制部件，只有两个控制部件</p>
<p>只有A组和B组有控制部件，这样3个端口就会分为2组</p>
<p>A组由A口和C口的高4位组成</p>
<p>B组由B口和C口的低4位组成</p>
<p>A组和B组有自己的控制部件，可同时接受来自读/写控制电路的命令和CPU送来的控制字，并且根据这些来定义各个端口的操作方式</p>
<p><br></p>
<p>注：虽然分了AB组，A组用C的高4位，但是后面方式1工作方式用的却不是高4位</p>
<p>方式1输入，A组用的是PC3，PC4，PC5，方式1输出，A组用的是PC3，PC6，PC7</p>
<h3 id="数据总线缓冲器">数据总线缓冲器</h3>
<p>数据总线缓冲器是CPU与8255A交换信息的必经之路</p>
<h2 id="与系统的连接图-1">8255与系统的连接图</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218203732822.png" class title="image-20231218203732822">
<h2 id="工作方式-1">8255工作方式</h2>
<p>总共3种工作方式</p>
<p>编号是0，1，2</p>
<h3 id="方式0基本输入输出方式">方式0：基本输入/输出方式</h3>
<p>方式0主要工作在无条件的输入/输出方式下，不需要“联络”信号</p>
<p>A口，B口，C口均可工作在此方式下，C口只能工作在方式0下</p>
<p>在这种方式下，CPU与端口之间交换数据可以直接由CPU执行IN或OUT指令完成，不需要检测状态线</p>
<p>由于在方式0下，3个端口可以分别定义为输入或输出端口，于是3个端口就会有下图16种输入/输出组合：</p>
<p>16的原因：C口可以分为两个4位的独立端口</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218220935091.png" class title="image-20231218220935091">
<p><br></p>
<p>8255在方式0相当于三个独立的8位简单接口</p>
<p>各端口既可设置为输入口，也可设置为输出口，但<strong>不能同时</strong>实现输入及输出</p>
<p>C端口即可以是一个8位的简单接口，也可以分为<strong>两个独立的</strong>4位端口</p>
<p>设置为输出口时有锁存能力，设置为输入口时无锁存能力</p>
<p><br></p>
<h4 id="方式0的应用">方式0的应用</h4>
<p>用于连接简单外设</p>
<p>适用于：</p>
<p>无条件输入输出方式</p>
<p>查询输入输出方式：把A、B口作为8位数据的输入或输出口，C口的高/低4位分别定义为A、B口的控制位和状态位</p>
<h3 id="方式1选通输入输出方式">方式1：选通输入/输出方式</h3>
<p>方式1主要工作在异步或条件传输方式下</p>
<p>在方式1下，数据的输入、输出操作要在选通信号控制下完成，适合条件传输（必须先检查状态，然后才能传输数据）</p>
<p>仅有A口和B口可工作在此方式下，因为C口的部分位固定用作A、B口的选通控制信号（联络线），相当于握手协议</p>
<p>工作在方式1下的A口和B口可以作为输入接口，也可以作为输出接口</p>
<p>由于输入接口和输出接口所需要的选通控制不同，“联络线”的定义和功能也不同，需要分别介绍</p>
<h4 id="选通输入方式">选通输入方式</h4>
<p>AB口均为输入</p>
<p>在这种方式下，A口或B口需有C口3根线作为联络线</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219091555181.png" class title="image-20231219091555181">
<p>PC3, PC4, PC5作为A口的联络线，PC0, PC1, PC2作为B口的联络线</p>
<h5 id="信号功能">信号功能</h5>
<p>~STBA：A口的选通信号（外设发出，低电平有效），当其有效时，外设把数据输入A口的输入缓冲器</p>
<p>IBFA：A口的输入缓冲器“满”信号，当其有效时，表示A口的输入缓冲器已暂存一个有效数据，是输出信号；此信号由STB的<strong>前沿</strong>产生</p>
<p>INTRA：A口的中断请求信号，当其有效时，8255的A口向CPU申请中断，要求CPU从A口取数，是输出信号；此信号由STB的<strong>后沿</strong>产生</p>
<p>在这种方式下，A口的逻辑电路有一个INTEA信号，称为中断允许信号，这个信号为高时，与门导通，INTEA就可以作为INTRA中断信号输出了。INTEA对应C口输出锁存器的第4位，即通过对C口PC4的置位/复位就可以设置INTEA</p>
<p>即：INTEA =1和IBFA为高电平时，允许发出INTRA请求</p>
<h5 id="发送数据过程">发送数据过程</h5>
<p>在方式1下，外设把一个数据通过A口送给CPU的过程如下：</p>
<p>1.外设把数据送到A口的数据线PA7-PA0后，使选通信号~STBA有效，数据进入A口的输入缓冲区</p>
<p>2.A口的IBFA有效，通知外设或CPU，表示A口接收了一个有效数据</p>
<p>3.A口的INTRA有效，以中断方式通知CPU取走A口的数据</p>
<p>4.CPU读A口，数据进入CPU</p>
<p>5.IBFA和INTRA转为无效</p>
<p>方式1数据输入的时序图如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219093233107.png" class title="image-20231219093233107">
<p><br></p>
<p>可见，当A口接收外部数据以后，会有IBFA和INTRA的输出，对应了两种方式通知CPU取数：</p>
<p>条件查询方式，通过查询缓冲器是否“满”，即IBFA是否为高电平来取数</p>
<p>中断方式，先用控制字把C口的INTEA置位1，当IBFA=1时，这两个高电平通过与门产生高电平INTRA；若CPU允许中断，则中断当前执行的程序，转到对A口读数的中断服务子程序</p>
<h5 id="握手信号">握手信号</h5>
<p>在条件传输中，一般需要有“握手”信号来协调数据的传输</p>
<p>“握手”信号至少要有两位信号线，其中一位由接口电路发给外设，另一位是外设发给接口</p>
<p>在选通方式中，~STBA和IBFA是一对“握手”信号</p>
<p>~STBA是外设发给接口，有效时通知A口，外设传递进来一个数据</p>
<p>IBFA是接口发给外设，有效时通知外设，A口已经接收这个数据</p>
<h5 id="此时的状态字">此时的状态字</h5>
<p>从C口读出的8位数据各位的意义如下</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219101522618.png" class title="image-20231219101522618">
<h4 id="选通输出方式">选通输出方式</h4>
<p>AB口均为输出</p>
<p>在这种方式下，A口或B口需有C口3根线作为联络线</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219101654339.png" class title="image-20231219101654339">
<p>PC3, PC6, PC7作为A口的联络线，PC0, PC1,
PC2作为B口的联络线（与选通输入有点不同：A口的联络线变成了PC3, PC6,
PC7）</p>
<h5 id="信号功能-1">信号功能</h5>
<p>~OBFA：A口输出缓冲区“满”信号，有效时表示A口输出缓冲器已经暂存一个有效数据，通知外设取数据</p>
<p>~ACKA：外设应答信号，由外设发出，低电平有效时表示外设<strong>已经接收</strong>数据</p>
<p>INTRA：A口的中断请求信号，当其有效时，A口向CPU申请中断，要求CPU送数据给A口，由~ACKA上升沿产生（通常接到8259）</p>
<h5 id="发送数据过程-1">发送数据过程</h5>
<p>在方式1输出方式下，CPU把数据通过A口送给外设的过程如下：</p>
<p>1.CPU执行OUT指令，把数据写入A口的输出缓冲器</p>
<p>2.当有效数据进入A口的数据线PA7-PA0时，~OBFA有效通知外设：CPU已把一个有效数据输出到A口，外设可以从A口取数据了</p>
<p>3.外设取走数据时，发~ACKA信号给8255，告诉A口外设已经取完数据</p>
<p>4.A口~OBFA无效，表示A口数据已经被外设取走</p>
<p>5.INTRA有效，以中断的方式通知CPU再输出数据给A口</p>
<p>方式1数据输出的时序图如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219103820080.png" class title="image-20231219103820080">
<p><br></p>
<p>同样，当A口的输出缓冲器数据被外设取走后，有两种方式通知CPU再对A口写入数据：</p>
<p>条件查询方式，查询输出缓冲器是否为“空”，即~OBFA是否为高电平决定CPU是否转向对A口输出数据的程序</p>
<p>中断方式，先用控制字置A口的INTEA位为“1”，若外设取走A口的数据，应答信号~
ACKA有效，使~ OBFA为高电平；~
OBFA和INTEA都为高电平，通过与门产生INTRA中断信号，若CPU允许中断，则中断当前执行的程序，转到对A口写数的中断服务子程序</p>
<h5 id="握手信号-1">握手信号</h5>
<p>在这种方式下，~ ACKA和~ OBFA是一对握手信号</p>
<p>~OBFA是接口发给外设，通知外设A口有了一个新数据</p>
<p>~ACKA是外设发给接口，通知接口外设已经把数据取走</p>
<h5 id="此时状态字">此时状态字</h5>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219105111892.png" class title="image-20231219105111892">
<h4 id="方式1的应用">方式1的应用</h4>
<p>主要用于中断控制方式下的输入输出</p>
<p>C口除部分位用作选通信号外，其余位可工作在方式0下，作为输入或输出线</p>
<p>特别是A、B均为方式1时仅使用C口的6条线，余下二条线可作为单独的输入输出线，用程序指定其数据传送方向</p>
<h3 id="方式2双向传输方式仅a口">方式2：双向传输方式（仅A口）</h3>
<p>双向方式——既是输入口，又是输出口</p>
<p>利用C口的5条线提供传输联络信号</p>
<p>类似于A口方式1下输入和输出的组合</p>
<p>只有A口可工作在方式2下</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231227150614293.png" class title="image-20231227150614293">
<h2 id="控制字-1">8255控制字</h2>
<h3 id="控制字格式-1">控制字格式</h3>
<p>8位控制字</p>
<p>有3种控制字：方式控制字，C口置1清0控制字，读入状态字</p>
<p>要记住所有寄存器</p>
<p>D7为1时，是选择工作方式控制字</p>
<p>D7为0时，是C口置位/复位控制字</p>
<p><br></p>
<h3 id="方式控制字">方式控制字</h3>
<p>控制字包括1位的功能控制，4位的A组控制，3位的B组控制</p>
<p>0输出，1输入</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218213154942.png" class title="image-20231218213154942">
<p>从高位到低位分别是：</p>
<p>D7功能控制，区分出来两种控制字：<strong>选择工作方式控制字</strong>和<strong>C口置位/复位控制字</strong></p>
<p>D7为1时，是选择工作方式控制字</p>
<p>D7为0时，是C口置位/复位控制字</p>
<p><br></p>
<p>D6, D5, D4, D3是A组控制</p>
<p>其中D6和D5选择工作方式（仅有A口能用方式2）</p>
<p>D4是A口的输入、输出选择</p>
<p>D3为C口高4位的输入、输出选择</p>
<p><br></p>
<p>D2, D1, D0是B组控制</p>
<p>D2为B口的方式选择</p>
<p>D1是B口的输入、输出选择</p>
<p>D0为C口低4位的输入、输出选择</p>
<h3 id="c口置位复位控制字">C口置位/复位控制字</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218215033167.png" class title="image-20231218215033167">
<p>也就是可以直接操作C口的位</p>
<p>用D3，D2，D1指定PC0-PC7</p>
<p>然后再用D0选择这个口现在的信息</p>
<h3 id="读入状态字">读入状态字</h3>
<p>这个状态字是C口读出来的，而不是我们写进控制寄存器的</p>
<p>当8255A工作在方式1或方式2时，C口会根据不同情况产生或接收“联络”信号</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219101327421.png" class title="image-20231219101327421">
<h2 id="作业-2">8255作业</h2>
<h3 id="section-2">1.</h3>
<p>利用8253（端口地址C0-C3H）作为计数器，8255（端口地址D0-D3H）的一个输出端口控制8个指示灯，请设计出电路连接图，并编写程序，使8个指示灯依次闪动：闪动频率为每秒1次。</p>
<p>答：</p>
<p>涉及到中断，就需要8259A，所以初始化也需要考虑8259</p>
<p>但是题目里没有明确指明8259的地址，和对应的中断类型号，所以就可以任取</p>
<p>比如：我规定8259地址为20H-21H，中断类型号为E0-E7H，中断用8259的IR0，边沿触发形式</p>
<p>设置接入8253的时钟信号为1KHZ</p>
<p><br></p>
<p>整体过程很类似“<a href="#8253_1">8253作业第一题</a>”，所以此处并不会像8253第一题一样写的非常详细</p>
<p>整道题目的基本过程如下：</p>
<p>先分析硬件电路，基本思路就是8253时间到了往8259的IR0发一个信号，此处的信号为方波，那就是工作模式3</p>
<p>8259接到信号以后，像CPU产生一个中断</p>
<p>CPU响应中断服务子程序，直接向8255的A口发送数据，控制灯亮灭</p>
<p>用到8253的计数器0，8259的IR0，中断号设置成E0H，8255的A口</p>
<p><br></p>
<p>根据对应地址，让Y0被选中，8253的138译码电路为：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240104155741640.png" class title="image-20240104155741640">
<p>根据对应地址，让Y0被选中，8255的138译码电路为：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240104155813795.png" class title="image-20240104155813795">
<p>对应的硬件连接图为：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240104155923812.png" class title="image-20240104155923812">
<p>注意这里硬件连接图的灯，如果没有反相器，就是0亮1不亮，但是这里多了个反相器，就是逻辑非门，那就1亮0不亮</p>
<p>考试的时候自己爱咋连咋连，我如果自己画就不加这个反相器，但是我懒得画，直接用答案现成的就好</p>
<p><br></p>
<p>硬件电路分析完后，就是对应器件的初始化字了</p>
<p>先看8253：</p>
<p>选用计数器0，则开头两位为<code>00</code></p>
<p>如果接入的CLK是1KHZ，我们需要让灯1秒切换一个状态，那就是重复的方波，工作模式3，则D3D2D1分别为<code>011</code></p>
<p>对应计数值为：<span class="math inline">\(\dfrac{1}{\frac{1}{1\times10^3}}=1000\)</span>，对应的二进制就是<code>0000_0011_1110_1000B</code>，很明显比8位长，因此需要先低后高两次写入计数值，则D5D4为<code>11</code></p>
<p>最后，不用BCD，则D0为0</p>
<p>所以8253对应的控制字就是<code>0011_0110B</code></p>
<p>写对应的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MOV	DX,	00C3H	;8253控制口</span><br><span class="line">MOV	AL,	0011_0110B</span><br><span class="line">OUT	DX,	AL		;写控制字</span><br><span class="line">MOV	DX,	00C0H	;8253计数器0</span><br><span class="line">MOV	AL,	1110_1000B	;先写1000的低8位</span><br><span class="line">OUT	DX,	AL</span><br><span class="line">MOV	AL,	0000_0011B	;再写1000的高8位</span><br><span class="line">OUT	DX,	AL</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>再看8255：</p>
<p>这个更简单，只用到A口简单输出，只用到方式0，所以B口后面的所有位都可以不管</p>
<p>首先，设置工作方式，D7=1</p>
<p>其次，设置A口的工作方式为方式0，则D6D5为<code>00</code></p>
<p>然后，设置A口为输出，D4为0</p>
<p>最后，因为C口和B口都用不到，所以D0D1D2D3都是0</p>
<p>所以8255的控制字为：<code>1000_0000B</code></p>
<p>直接写入即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV	DX,	00D3H	;8255控制口</span><br><span class="line">MOV	AL,	1000_0000B</span><br><span class="line">OUT	DX,	AL		;写8255控制字</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>最后看8259A：</p>
<p>ICW1：因为接入的是IR0，设置的是边沿触发，单片，写ICW4，则ICW1为<code>0001_0011B</code></p>
<p>ICW2：设置IR0的中断向量码为E0H，则对应的ICW2为<code>1110_0000B</code></p>
<p>ICW3：不用级联，不写</p>
<p>ICW4：最简单的中断结束方式，就写<code>0000_0001B</code></p>
<p>OCW1：不需要中断屏蔽，不写</p>
<p>OCW2：不需要改变优先级，不写</p>
<p>OCW3：不需要中断屏蔽和读出，不写</p>
<p>最后对应8259的初始化程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MOV	DX,	0020H	;8259 A0=0</span><br><span class="line">MOV	AL,	0001_0011B</span><br><span class="line">OUT	DX,	AL		;写ICW1</span><br><span class="line">MOV	DX,	0021H	;8259 A0=1</span><br><span class="line">MOV	AL,	1110_0000B</span><br><span class="line">OUT	DX,	AL		;写ICW2</span><br><span class="line">MOV	AL,	0000_0001B</span><br><span class="line">OUT	DX,	AL		;写ICW4</span><br></pre></td></tr></table></figure>
<p>既然设置了中断，则需要有对应的中断服务程序</p>
<p>具体思路如下：在全局设置一个变量<code>LED</code>来控制8个灯亮与灭，0灭1亮，最开始就是<code>0000_0001B</code></p>
<p>然后每过1秒，CPU响应一次中断程序</p>
<p>每次都可以把这个值左移一位，看起来就是灯在依次闪动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DATA	SEGMENT</span><br><span class="line">LED	DB	0000_0001B	;数据段，定义LED这个变量</span><br><span class="line">DATA	ENDS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MYINT	PROC	FAR</span><br><span class="line">PUSHF			;保护现场</span><br><span class="line">PUSH	DX</span><br><span class="line">PUSH	AX</span><br><span class="line">CLI				;关中断</span><br><span class="line">MOV	DX,	D0H		;8255的A口</span><br><span class="line">MOV	AL,	LED	</span><br><span class="line">OUT	DX,	AL		;把LED的值从A口输出到硬件</span><br><span class="line">ROL	LED		;控制LED循环左移，这样就可以保证依次亮</span><br><span class="line">STI				;开中断</span><br><span class="line">POP	AX</span><br><span class="line">POP	DX</span><br><span class="line">POPF</span><br><span class="line">IRET		;记得中断返回</span><br><span class="line">MYINT	ENDP</span><br></pre></td></tr></table></figure>
<p>我定义的中断服务程序名字叫<code>MYINT</code>，现在应该把这个程序放入IVT</p>
<p>具体过程很容易，保护DS等寄存器，关中断，把0放入DS，把中断类型号E0H乘4放入SI，把段偏移放入<code>[SI]</code>，把段基址放入<code>[SI+2]</code>，开中断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CLI		;关中断</span><br><span class="line">PUSH	DS</span><br><span class="line">PUSH	AX</span><br><span class="line">PUSH	SI</span><br><span class="line">MOV	AX,	0000H</span><br><span class="line">MOV	DS,	AX		;把0放入DS，准备写IVT</span><br><span class="line">MOV	SI,	E0H * 4	;E0H乘4存入SI</span><br><span class="line">LEA	AX,	MYINT	;取偏移地址到AX</span><br><span class="line">MOV	[SI],	AX	;偏移地址放入低字节</span><br><span class="line">MOV	AX,	SEG	MYINT	;取段基址</span><br><span class="line">MOV	[SI+2],	AX	;段基址存入高字节</span><br><span class="line">POP	SI</span><br><span class="line">POP	AX</span><br><span class="line">POP	DS</span><br><span class="line">STI		;开中断 </span><br></pre></td></tr></table></figure>
<h3 id="section-3">2.</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240104164815453.png" class title="image-20240104164815453">
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240104164829159.png" class title="image-20240104164829159">
<p>答：</p>
<p>（1）</p>
<p>有点逆天了，唯一的区别只有A15</p>
<p>当A15为0时，8253被选通，8255不起作用；当A15为1时，8255被选通，8253不起作用</p>
<p>因为地址线为16根，所以区别就在这里：</p>
<p>8253：<code>0000_0000_0000_0000B</code>到<code>0111_1111_1111_1111B</code>，即<code>0000H - 7FFFH</code></p>
<p>8255：<code>1000_0000_0000_0000B</code>到<code>1111_1111_1111_1111B</code>，即<code>8000H - FFFFH</code></p>
<p>但是我不明白，为什么端口会这么多</p>
<p>（2）</p>
<p>我指定：8253的起始地址为0000H，8255的起始地址为8000H</p>
<p>先看8253：</p>
<p>指定用方波，就是方式3，计数值为<span class="math inline">\(\dfrac{\frac{1}{100}}{\frac{1}{1\times10^6}}=1\times10^4\)</span>，写成二进制就是<code>0010_0111_0001_0000B</code>，注意别写错了，我感觉这个二进制转换还是挺容易错的</p>
<p>指定计数器1，所以最开头两位为<code>01</code></p>
<p>因为10000的二进制超过8位，所以需要先低后高分2次存入，因此D5D4为<code>11</code></p>
<p>工作方式为方式3，所以D3D2D1为<code>011</code></p>
<p>没指定BCD，D0就是0</p>
<p>因此，8253控制字为<code>0111_0110B</code></p>
<p>再看8255：</p>
<p>指定A输出，BC为输入，所以工作方式0</p>
<p>指定工作方式，第一位为1</p>
<p>A口为方式0，则D6D5为<code>00</code></p>
<p>A口为输出，则D4为0</p>
<p>C口为输入，则D3和D0为1（D3控制高4位，D0控制低4位）</p>
<p>B口为方式0，则D2为0</p>
<p>B口为输入，则D1为1</p>
<p>对应的控制字为：<code>1000_1011B</code></p>
<p>对应的初始化程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;8253初始化</span><br><span class="line">MOV	DX,	0003H	;8253控制口</span><br><span class="line">MOV	AL,	0111_0110B</span><br><span class="line">OUT	DX,	AL		;写8253控制字</span><br><span class="line">MOV	DX,	0001H	;8253计数器1</span><br><span class="line">MOV	AL,	0001_0000B</span><br><span class="line">OUT	DX,	AL		;写10000的低八位</span><br><span class="line">MOV	AL,	0010_0111B</span><br><span class="line">OUT	DX,	AL		;写10000的高八位</span><br><span class="line"></span><br><span class="line">;8255初始化</span><br><span class="line">MOV	DX,	8003H	;8255控制口</span><br><span class="line">MOV	AL,	1000_1011B</span><br><span class="line">OUT	DX,	AL		;写8255控制字</span><br></pre></td></tr></table></figure>
<p>（3）</p>
<p>他这个拨码开关0-7最后的输入应该是独热码，即<code>0000_0001, 0000_0010</code>这样的，仅有1位是1，用这一位可以判断是哪个数</p>
<p>我不采用答案的写法，而是采用我在接口技术课设里电子琴的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">	;***************************************************************</span><br><span class="line">	;		C大调音</span><br><span class="line">	;***************************************************************</span><br><span class="line">START_C:	TEST	AL,2</span><br><span class="line">	JZ	START_D</span><br><span class="line">	CALL	Music_C	;1号键</span><br><span class="line">    JMP FAR PTR InitialState</span><br><span class="line">START_D:	TEST	AL,4		</span><br><span class="line">	JZ	START_E	</span><br><span class="line">	CALL	Music_D	;2号键</span><br><span class="line">	JMP	FAR PTR InitialState	</span><br><span class="line">START_E:	TEST	AL,8	</span><br><span class="line">	JZ	START_F	</span><br><span class="line">	CALL	Music_E	;3号键</span><br><span class="line">	JMP	FAR PTR InitialState	</span><br><span class="line">START_F:	TEST	AL,10H	</span><br><span class="line">	JZ	START_G	</span><br><span class="line">	CALL	Music_F	;4号键</span><br><span class="line">	JMP	FAR PTR InitialState	</span><br><span class="line">START_G:	TEST	AL,20H	</span><br><span class="line">	JZ	START_A	</span><br><span class="line">	CALL	Music_G	;5号键</span><br><span class="line">	JMP	FAR PTR InitialState	</span><br><span class="line">START_A:	TEST	AL,40H	</span><br><span class="line">	JZ	START_B	</span><br><span class="line">	CALL	Music_A	;6号键</span><br><span class="line">	JMP	FAR PTR InitialState	</span><br><span class="line">START_B:</span><br><span class="line">	CALL	Music_B	;7号键	</span><br><span class="line">    JMP	FAR PTR InitialState</span><br></pre></td></tr></table></figure>
<p>我的写法我认为很简单，就顺序判断0-7，执行对应的功能，最后跳转就可以了，可能写的有点长</p>
<p>开关如果置到1，输入B口的数据就是<code>1111_1110B</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">DATA	SEGMENT</span><br><span class="line">BINARYCODE	DB	01H, 02H, 03H,04H, 05H, 06H, 07H, 08H   ;自定义的二进制编码</span><br><span class="line">DATA	ENDS</span><br><span class="line"></span><br><span class="line">CODE	SEGMENT</span><br><span class="line">	ASSUME	CS:CODE,	DS:DATA</span><br><span class="line">START:</span><br><span class="line">	MOV	AX,	DATA</span><br><span class="line">	MOV	DS,	AX		;DATA放入AX</span><br><span class="line">	CALL	MYPRO	;调用函数</span><br><span class="line">	</span><br><span class="line">MYPRO	PROC	NEAR</span><br><span class="line">	PUSH	DX</span><br><span class="line">	PUSH	AX</span><br><span class="line">	PUSH	SI		;保护</span><br><span class="line">	MOV	DX,	8002H	;C口地址</span><br><span class="line">READLOOP:</span><br><span class="line">	IN	AX,	DX		;读C口数据</span><br><span class="line">	TEST	AX,	0000_0001B	;如果读出来的末位PC0是0，与的结果就是0，ZF就置1</span><br><span class="line">	JZ	CONTINUE	;末位PC0是0，就跳转</span><br><span class="line">	JMP	READLOOP	;如果末位不是0，就一直重复读</span><br><span class="line">CONTINUE:</span><br><span class="line">	LEA	SI,	BINARYCODE	;表格地址地址放入SI</span><br><span class="line">	MOV	DX,	8001H	;B口地址</span><br><span class="line">	IN	AX,	DX		;读B口数据到AX</span><br><span class="line">	CMP	AX,	0000_0001B	;比较只会改变ZF的值，相当于做减法</span><br><span class="line">	JZ	READ1			;如果结果为0，说明两个相等，可以直接JZ跳转</span><br><span class="line">	CMP	AX,	0000_0010B</span><br><span class="line">	JZ	READ2</span><br><span class="line">	CMP	AX,	0000_0100B</span><br><span class="line">	JZ	READ3</span><br><span class="line">	CMP	AX,	0000_1000B</span><br><span class="line">	JZ	READ4</span><br><span class="line">	CMP	AX,	0001_0000B</span><br><span class="line">	JZ	READ5</span><br><span class="line">	CMP	AX,	0010_0000B</span><br><span class="line">	JZ	READ6</span><br><span class="line">	CMP	AX,	0100_0000B</span><br><span class="line">	JZ	READ7</span><br><span class="line">	CMP	AX,	1000_0000B</span><br><span class="line">	JZ	READ8</span><br><span class="line">READ1:</span><br><span class="line">	MOV	AL,	[SI]	;对应二进制编码放入AL</span><br><span class="line">	JMP	END		;跳转最后</span><br><span class="line">READ2:</span><br><span class="line">	MOV	AL,	[SI+1]	;对应二进制编码放入AL</span><br><span class="line">	JMP	END		;跳转最后</span><br><span class="line">READ3:</span><br><span class="line">	MOV	AL,	[SI+2]	;对应二进制编码放入AL</span><br><span class="line">	JMP	END		;跳转最后</span><br><span class="line">READ4:</span><br><span class="line">	MOV	AL,	[SI+3]	;对应二进制编码放入AL</span><br><span class="line">	JMP	END		;跳转最后</span><br><span class="line">READ5:</span><br><span class="line">	MOV	AL,	[SI+4]	;对应二进制编码放入AL</span><br><span class="line">	JMP	END		;跳转最后</span><br><span class="line">READ6:</span><br><span class="line">	MOV	AL,	[SI+5]	;对应二进制编码放入AL</span><br><span class="line">	JMP	END		;跳转最后</span><br><span class="line">READ7:</span><br><span class="line">	MOV	AL,	[SI+6]	;对应二进制编码放入AL</span><br><span class="line">	JMP	END		;跳转最后</span><br><span class="line">READ8:</span><br><span class="line">	MOV	AL,	[SI+7]	;对应二进制编码放入AL</span><br><span class="line">	JMP	END		;跳转最后</span><br><span class="line">END:</span><br><span class="line">	MOV	DX,	8000H	;A口地址</span><br><span class="line">	OUT	DX,	AL		;输出</span><br><span class="line">	POP	SI</span><br><span class="line">	POP	AX</span><br><span class="line">	POP	DX</span><br><span class="line">	RET</span><br><span class="line">MYPRO	ENDP</span><br><span class="line"></span><br><span class="line">CODE	ENDS</span><br><span class="line">	END	START</span><br></pre></td></tr></table></figure>
<p>答案的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Disp	PROC	NEAR</span><br><span class="line">PUSH	CX</span><br><span class="line">PUSH	SI</span><br><span class="line">XOR	CX,  CX			;CX置0</span><br><span class="line">CLC</span><br><span class="line">LEA	SI,   BINARYCODE	;获得存储编码位置的地址</span><br><span class="line">MOV	DX, 8002H              ;PC口地址</span><br><span class="line">GO:	</span><br><span class="line">IN	AL, DX</span><br><span class="line">CMP	AL, 01H			;测试PC0是否为1</span><br><span class="line">JNZ	GO				;循环检测</span><br><span class="line">MOV	DX, 8001H		;读取PB口开关的值</span><br><span class="line">IN	AL, DX			;读取PB口开关的值</span><br><span class="line">GO1:</span><br><span class="line">SHR	AL, 1         ;不停右移获得权重值</span><br><span class="line">INC	CX</span><br><span class="line">JC	GO1	;标志位为1就转移              </span><br><span class="line">DEC	CX	;多加的一次减掉</span><br><span class="line">ADD	SI,  CX</span><br><span class="line">MOV	AL, [SI]			;读取编码值</span><br><span class="line">MOV	DX, 8000H		;赋给PA口</span><br><span class="line">OUT	DX, AL</span><br><span class="line">POP	SI</span><br><span class="line">POP	CX</span><br><span class="line">RET</span><br><span class="line">Disp	ENDP</span><br></pre></td></tr></table></figure>
<p>用循环和位移确实代码少一些</p>
<h1 id="中断-1">中断</h1>
<h2 id="中断的定义">中断的定义</h2>
<p>CPU执行程序时，由于发生了某种随机的事件(外部或内部)，引起CPU<strong>暂时中断</strong>正在运行的程序，<strong>转去执行一段特殊的服务程序</strong>(称为中断服务程序或中断处理程序)，以处理该事件，该事件处理完后又返回被中断的程序继续执行，这一过程称为中断</p>
<h2 id="中断源">中断源</h2>
<p>引起CPU中断的事件就是中断源</p>
<p>中断源分为：外部中断、内部中断</p>
<h3 id="外部中断">外部中断</h3>
<p>CPU以外的设备、部件产生的中断</p>
<h3 id="内部中断">内部中断</h3>
<p>CPU内部执行程序时自身产生的中断</p>
<h2 id="引入中断的原因">引入中断的原因</h2>
<p>提高数据传输率</p>
<p>避免了CPU不断检测外设状态的过程，提高了CPU的利用率</p>
<p>实现对特殊事件的实时响应（如多任务系统操作系统中：缺页中断，设备中断，各类异常）</p>
<h2 id="中断五个步骤">中断五个步骤</h2>
<p>中断请求、中断判优(有时还要进行中断源识别)、中断响应、中断服务、中断返回</p>
<h3 id="中断请求">中断请求</h3>
<p>外设接口（中断源）发出中断请求信号，送到CPU的INTR或NMI引脚</p>
<p>中断请求信号应<strong>保持到中断被处理为止</strong></p>
<p>CPU响应中断后，中断请求信号应<strong>及时撤销</strong></p>
<p>在8086/8088系统中，外设的中断要经过8259A可编程中断控制器(PIC)的排队判优后向CPU发出</p>
<h3 id="中断判优">中断判优</h3>
<p>中断优先级控制要处理两种情况：</p>
<p>对同时产生的中断：应首先处理优先级别较高的中断；若优先级别相同，则按先来先服务的原则处理</p>
<p>对非同时产生的中断：低优先级别的中断处理程序<strong>允许被高优先级别的中断源所中断</strong>——即允许<strong>中断嵌套</strong></p>
<p><br></p>
<h4 id="中断优先级控制方法">中断优先级控制方法</h4>
<p>分为硬件判优和软件判优</p>
<h5 id="硬件判优">硬件判优</h5>
<p>链式判优电路：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231227164116769.png" class title="image-20231227164116769">
<p>INTR为电平请求，只要有器件需要中断就过或门，发起中断请求</p>
<p>菊花链逻辑电路：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231227164233608.png" class title="image-20231227164233608">
<p>链式判优按照中断优先级的顺序，把硬件的中断顺序排好了</p>
<p>~INTA为CPU发出的响应信号</p>
<p>IREQ为连接到下面或门的中断请求信号，可以看看上面那张图</p>
<p>CPU的响应信号从优先级高的器件到优先级低的器件</p>
<p>如果高的器件没有IREQ信号，则菊花链中断确认的与非门就没有信号，~INTA响应信号通过或门继续到下一个器件</p>
<p>如果这个器件有IREQ信号，则~INTA信号先过一个非门，变成1；然后和IREQ信号（高电平）经过与非门输出低电平的中断确认信号，进入外设接口</p>
<p>同时，IREQ信号经过下面的或门，把INTAout信号置为1，后面的器件就没法获得低电平的相应信号了</p>
<h5 id="软件判优">软件判优</h5>
<p>顺序查询中断请求，先查询的先服务（即先查询的优先级别高）</p>
<h3 id="中断响应">中断响应</h3>
<p>CPU响应中断，要完成下面三个工作：</p>
<p>向中断源发出INTA中断响应信号</p>
<p>断点保护，包括CS、IP和PSW（FLAGS）。这主要是保证中断结束后能返回被中断的程序</p>
<p>获得中断服务程序首地址（入口）</p>
<p><br></p>
<p>想得到中断服务程序首地址，常用的是<strong>中断向量法</strong></p>
<h3 id="中断服务">中断服务</h3>
<p>中断服务子程序特点</p>
<ol type="1">
<li><p>为“远”过程（类型为FAR）</p></li>
<li><p>要用IRET指令返回</p></li>
</ol>
<p><br></p>
<p>中断服务子程序要做的工作</p>
<ol type="1">
<li><p>保护现场(<code>PUSH reg’s</code>)</p></li>
<li><p>开中断(<code>STI</code>)</p></li>
<li><p>进行中断处理</p></li>
<li><p>恢复现场(<code>POP reg’s</code>)</p></li>
<li><p>中断返回(<code>IRET</code>)</p></li>
</ol>
<h3 id="中断返回">中断返回</h3>
<p>执行<code>IRET</code>指令</p>
<p>IRET指令将使CPU把堆栈内保存的断点信息弹出到IP、CS和FLAG中，保证被中断的程序从断点处能够继续往下执行</p>
<h2 id="中断向量表ivt">中断向量表（IVT）</h2>
<p>存放各类中断的<strong>中断服务程序的入口地址</strong>（段和偏移）——<strong>中断向量</strong></p>
<p>表的地址位于内存的00000H～003FFH，大小为1KB，共<strong>256个</strong>中断向量（一个中断向量占4个字节，表总长1024个字节，故<span class="math inline">\(1024\div4=256\)</span>个中断向量）</p>
<p>每个中断向量占用<strong>4
Bytes</strong>，<strong>低字为段内偏移，高字为段基址</strong></p>
<p>根据中断类型号获得中断服务程序入口的方法: (n为中断类型号，从0开始)
<span class="math display">\[
中断向量在IVT中的存放地址 = 4\times n
\]</span> 因为一个中断向量占4字节，所以乘4</p>
<h3 id="中断向量表初始化">中断向量表初始化</h3>
<p>初始化 —— 将中断服务程序的入口地址放入向量表</p>
<p>两种方法：</p>
<ol type="1">
<li>直接将中断处理子程序入口地址填写进中断向量表中</li>
<li>通过调用DOS的25H子功能实现</li>
</ol>
<p>中断类型码为48H的中断处理子程序的名字为int48h，编写程序段将该中断处理子程序的入口地址放入向量表</p>
<p>方法1：自己写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CLI			;清零IF，IF=0时表示CPU禁止中断，即关中断</span><br><span class="line">PUSH	DS	;保护DS的值，因为下面修改了DS的值</span><br><span class="line">MOV	AX,	0		;0放入AX，因为中断向量表一般在内存的00000H-003FFH</span><br><span class="line">MOV	DS,	AX		;DS现在存的就是0，即中断向量表的地址</span><br><span class="line">MOV	SI,	48H * 4	;把48H在中断向量表中的偏移地址放入SI</span><br><span class="line">				;因为指明了中断类型码为48H，偏移地址就是48H * 4</span><br><span class="line">MOV	AX,	OFFSET	int48h	;把int48h的偏移地址放入AX，和LEA用法一致</span><br><span class="line">MOV	[SI],	AX	;把偏移地址放入48H在中断向量表中该放的位置的低地址</span><br><span class="line">MOV	AX,	SEG	int48h		;把int48h的段地址放入AX，其中SEG	int48h就是取int48h的段基址</span><br><span class="line">MOV	[SI+2],	AX	;把段地址放入[SI]的高两个字节，因为低地址存的是偏移地址，高地址存的是段基址</span><br><span class="line">POP	DS		;弹出DS的值</span><br><span class="line">STI			;IF置1，IF=1时CPU可响应中断，开中断</span><br></pre></td></tr></table></figure>
<p>方法2：用DOS的25H调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUSH	DS</span><br><span class="line">MOV	AX,	SEG	int48h	;把int48h的段地址放入AX</span><br><span class="line">MOV	DS,	AX			;把int48h的段地址放入DS</span><br><span class="line">LEA	DX,	int48h		;把int48h的偏移地址放入DX</span><br><span class="line">MOV	AL,	48H			;把中断类型码放入AL</span><br><span class="line">MOV	AH,	25H			;调用DOS的25H，自动把中断向量写进去</span><br><span class="line">INT	21H</span><br><span class="line">POP	DS</span><br></pre></td></tr></table></figure>
<p>如果要用DOS的25H调用，首先得保护现在DS段的值</p>
<p>然后把中断处理子程序的<strong>段地址</strong>通过AX传给DS</p>
<p>再把中断处理子程序的<strong>偏移地址</strong>放入DX</p>
<p>把<strong>中断类型码</strong>放入AL</p>
<p>就能调用DOS的25H了</p>
<p>相当于25H需要3个变量：中断处理子程序的段地址（放入DS）、中断处理子程序的偏移地址（放入DX）、中断处理子程序的中断类型码（放入AL）</p>
<h2 id="中断响应过程">8086中断响应过程</h2>
<p>这个算是重点？我看作业有这个考点</p>
<p>主要步骤：</p>
<ol type="1">
<li><code>PUSH    FLAG</code></li>
<li><code>IF = 0</code>，即关中断</li>
<li><code>PUSH    CS</code></li>
<li><code>PUSH    IP</code></li>
<li>取中断向量送入IP和CS</li>
</ol>
<p><br></p>
<h3 id="例题">例题</h3>
<p>比如一个作业题：</p>
<p>已知（SP）=0100H,（SS）=3500H,（CS）=9000H,（IP）=0200H,（00020H）=7FH,（00021H）=1AH,（00022H）=07H,（00023H）=6CH</p>
<p>在地址为90200H开始的连续2个单元中存放1条两字节指令INT 8</p>
<p>试指出在执行该指令并进入相应的中断程序时，SP、SS、IP、CS寄存器的内容以及SP所指向的字单元的内容是什么？</p>
<p>答：</p>
<p>执行该指令时，IP为下一条指令的地址，即0200H+2H=0202H</p>
<p>8086响应中断，首先把<code>FLAG</code>压栈，所以SP先减2为<code>00FEH</code></p>
<p>再关中断，这个不影响这些寄存器</p>
<p>再把CS内容压栈，即SP再减2为<code>00FCH</code></p>
<p>再把IP内容压栈，即SP再减2为<code>00FAH</code>，此时SP指向的内容就是0202H</p>
<p>这时就取中断向量送入IP和CS了</p>
<p>把偏移地址送入IP，把段基址送入CS</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231227180005215.png" class title="image-20231227180005215">
<p>于是，答案为：</p>
<p>SS不变，3500H</p>
<p>SP压栈3次，变为00FAH</p>
<p>IP变为1A7FH</p>
<p>CS变为6C07H</p>
<p>SP指向的内容，看最后一个被压栈的内容：IP，即0202H</p>
<h2 id="系统各中断优先级">8086系统各中断优先级</h2>
<p>优先级从高到低顺序如下：</p>
<p>内部中断</p>
<p>NMI（非屏蔽中断）</p>
<p>INTR（可屏蔽中断）</p>
<p>单步中断</p>
<h1 id="a可编程中断控制器">8259A可编程中断控制器</h1>
<p>1片可对8个中断源实现优先级控制，通过扩展可以对64个中断源实现优先级控制</p>
<p>可编程设置IR0-IR7中断优先级次序</p>
<p>可编程设置IR0-IR7中断类型码</p>
<p>可编程对IR0-IR7进行中断屏蔽设置</p>
<p>可编程读出内部IRR、ISR、IMR寄存器值，以了解中断情况</p>
<p>可编程设置8259A的工作方式</p>
<h2 id="a引脚">8259A引脚</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231227181412293.png" class title="image-20231227181412293">
<h2 id="a内部结构">8259A内部结构</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231227181444863.png" class title="image-20231227181444863">
<p>需要记的寄存器如下：</p>
<p>IRR（Interrupt Request Register）</p>
<p>ISR（Interrupt Service Register）</p>
<p>IMR（Interrupt Mute Register）</p>
<h3 id="中断请求寄存器irr">中断请求寄存器IRR</h3>
<p>保存从IR0～IR7来的<strong>中断请求信号</strong>，某位=1表示对应的
IR_i <strong>有中断请求</strong></p>
<h3 id="中断服务寄存器isr">中断服务寄存器ISR</h3>
<p>保存所有<strong>正在服务</strong>的中断源，某位=1表示对应的 IR_i
中断<strong>正在被服务</strong></p>
<h3 id="中断屏蔽寄存器imr">中断屏蔽寄存器IMR</h3>
<p>存放<strong>中断屏蔽字</strong>，某位=1表示对应的 IR_i
输入<strong>被屏蔽</strong></p>
<h3 id="中断优先权判别电路">中断优先权判别电路</h3>
<p>确定是否向CPU发出中断请求，中断响应时确定ISR的哪位应置位及把相应中断的类型码放到数据总线上</p>
<h2 id="a工作过程">8259A工作过程</h2>
<p>当某 IR_i 有效时，IRR相应位置1</p>
<p>若有效的 IR_i 未被屏蔽，则向CPU发出中断请求</p>
<p>检测到第1个INTA#信号后，置ISR_i=1，IRR i=0（及时清空）</p>
<p>检测到第2个INTA#信号后，把ISR_i=1中<strong>最高优先级</strong>的中断类型码放到DB上</p>
<p>若工作在AEOI方式，在第2个INTA#结束时，使ISRi复位；否则由CPU发出EOI命令使ISRi复位</p>
<h2 id="a工作方式">8259A工作方式</h2>
<p>中断优先方式与中断嵌套</p>
<p>中断结束处理方式</p>
<p>屏蔽中断源的方式</p>
<p>中断触发方式</p>
<p>级联工作方式</p>
<p><br></p>
<p>8259A工作方式设置：通过编写初始化程序实现</p>
<p>对其内部的ICW1-4四个命令寄存器进行设置和编写控制程序</p>
<p>对3个操作控制寄存器OCW0-2设置</p>
<h3 id="中断优先方式">中断优先方式</h3>
<p>中断优先方式 ：通过OCW2来设置</p>
<p>两种优先级控制方式：<strong>固定优先级</strong>和<strong>循环优先级</strong></p>
<p>固定优先级方式——OCW2中R位（D7位）= 0</p>
<p>循环优先级方式——OCW2中R位（D7位）= 1</p>
<h4 id="固定优先级">固定优先级</h4>
<p>所有中断请求IRi的中断优先级固定不变</p>
<p>优先级排列顺序可编程改变</p>
<p>加电后8259A的<strong>默认方式</strong>，默认优先级顺序从高到低为IR0～IR7</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231227183601648.png" class title="image-20231227183601648">
<h4 id="循环优先级">循环优先级</h4>
<p>中断源<strong>轮流处于最高优先级</strong>，即自动中断优先级循环</p>
<p>初始优先级顺序可用编程改变</p>
<p>某中断请求IRi<strong>被处理后</strong>，其优先级别自动<strong>降为最低</strong>，原来<strong>比它低一级的中断上升为最高级</strong></p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231227183924180.png" class title="image-20231227183924180">
<p>如图，此时有2个中断请求：IR6和IR4，IR4优先级更高，所以先响应IR4</p>
<p>响应完IR4以后，IR4的优先级就变成7，也就是最低优先级，最高优先级变成了IR5</p>
<p>优先级调换是在响应完一个中断请求后</p>
<h3 id="中断嵌套方式">中断嵌套方式</h3>
<p>中断嵌套方式—ICW4中D4位（SFNM）</p>
<p>在中断处理过程中允许被更高优先级的事件所中断称为中断嵌套</p>
<p>有两种中断嵌套方式：</p>
<p>一般全嵌套方式（默认方式）： ICW4的 SFNM=0</p>
<p>一中断正被处理时，只有更高优先级的事件可以打断当前的中断处理过程而被服务</p>
<p>特殊全嵌套方式 ： ICW4的 SFNM=1</p>
<p>一中断正被处理时，允许同级或更高优先级的事件可以打断当前的中断处理过程而被服务</p>
<h3 id="中断结束处理方式">中断结束处理方式</h3>
<p>当某一IRi中断被服务时，ISR中的相应位ISRi=1</p>
<p>当服务结束后，则必须清零该ISRi位</p>
<p>使ISRi=0是通过向8259A发出<strong>中断结束命令</strong>（<strong>EOI命令</strong>）实现的</p>
<p>三种EOI命令：ICW4的D1位AEOI</p>
<p>AEOI=1：自动EOI（AEOI）——（自动EOI方式）</p>
<p>非指定EOI（NSEOI）——（正常EOI方式）</p>
<p>指定EOI（SEOI）——（特殊EOI方式）</p>
<p><br></p>
<h3 id="屏蔽中断源的方式">屏蔽中断源的方式</h3>
<p>IMR屏蔽字决定了允许或禁止某位IRi所对应的中断：IMi=1 禁止， IMi=0
允许</p>
<p>特殊屏蔽方式：通过OCW3的D6D5位设置</p>
<h3 id="中断触发方式">中断触发方式</h3>
<p>边沿触发</p>
<p>IRi出现上升沿表示有中断请求</p>
<p>电平触发</p>
<p>IRi出现高电平表示有中断请求</p>
<p>在第1个~INTA结束前，IRi必须保持高电平</p>
<h3 id="级联工作方式">级联工作方式</h3>
<p>单片8259A可支持8个中断源</p>
<p>采用多片8259A级连，可最多支持64个中断源</p>
<p>n片8259A可支持7n+1个中断源</p>
<p>级连时<strong>只能有一片8259A为主片</strong>，其余的均为从属片</p>
<p><br></p>
<p>涉及到的8259A引脚包括：</p>
<p>CAS0-CAS2（连接级联缓冲比较器）</p>
<p>SP#/EN#</p>
<p>IRi</p>
<p>INT</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231227200904238.png" class title="image-20231227200904238">
<p>可以看到，主片的INT作为整个级联的INT</p>
<p>从片的INT当做主片的IRi</p>
<p>主片的CAS0-CAS2依次连接到从片的CAS0-CAS2</p>
<h2 id="a的编程使用">8259A的编程使用</h2>
<p>8259的控制命令分为：</p>
<p>初始化命令字ICW（ICW1-4）</p>
<p>操作命令字OCW（OCW1-3）</p>
<p>8259有2个地址：</p>
<p>A0=0时写ICW1, OCW2, OCW3</p>
<p>A0=1时写ICW2, ICW3, ICW4, OCW1</p>
<p><br></p>
<p>向8259A写入ICW的过程称为<strong>初始化编程</strong></p>
<p>初始化的任务：是设置中断请求信号的有效形式，确定是单片工作还是级联工作（ICW1）；设定IR0—IR7的中断类型号（ICW2）；设定8259A的级连情况（ICW3）；设定IR0—IR7各级请求信号的优先排序规则和中断结束操作规则（中断结束时如何清除ISR的中断标志位）（ICW4）</p>
<p><br></p>
<p>向8259A写入OCW的过程称为操作方式编程</p>
<h3 id="写icw">写ICW</h3>
<h4 id="a初始化顺序">8259A初始化顺序</h4>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101200418471.png" class title="image-20240101200418471">
<h4 id="icw1初始化字">ICW1——初始化字</h4>
<p>初始化8259A<strong>必须从ICW1开始</strong></p>
<p>写ICW1意味着<strong>重新初始化</strong>8259A</p>
<p>写入ICW1后，8259A的状态如下：</p>
<p>清除ISR（中断服务寄存器）和IMR(中断屏蔽寄存器，全0，1为屏蔽，0
不屏蔽)</p>
<p>将中断优先级设成初始状态：IR0最高，IR7最低</p>
<p>设定为一般屏蔽方式</p>
<p>采用非自动EOI中断结束方式</p>
<p>状态读出逻辑预置为读IRR</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101200612442.png" class title="image-20240101200612442">
<p>设置中断请求信号的有效形式，确定是单片工作还是级联工作</p>
<p>高3位没用，指定D4为1</p>
<h4 id="icw2中断向量码">ICW2——中断向量码</h4>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101200735382.png" class title="image-20240101200735382">
<p>也就是说，前5位是指定好的，后面3位会根据中断源0-7自行设置</p>
<p>比如：</p>
<p>如果<span class="math inline">\(IR_0\)</span>的中断向量码是：<code>0100_1000B</code>（48H）</p>
<p><span class="math inline">\(IR_1\)</span>的中断向量码是：<code>0100_1001B</code>（49H）</p>
<p><span class="math inline">\(IR_2\)</span>的中断向量码是：<code>0100_1010B</code>（4AH）</p>
<p>...</p>
<p><span class="math inline">\(IR_7\)</span>的中断向量码是：<code>0100_1111B</code>（4FH）</p>
<h4 id="icw3级联控制字连在哪">ICW3——级联控制字（连在哪）</h4>
<p>1用0不用</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101201216315.png" class title="image-20240101201216315">
<p>级联，就分为主片和从片</p>
<p>主片的ICW3控制字很容易，哪连了线，哪一位就是1</p>
<p>从片的ICW3控制字，前面5位定死为0，仅后面3位可变，说明了本从片连接到主片的哪一个引脚，IR0-7</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101201405720.png" class title="image-20240101201405720">
<p>主片从片对应关系必须一致</p>
<p>比如主片IR4与从片INT连接，主片的ICW3就是<code>0001_0000B</code>（10H），从片的ICW3就是<code>0000_0100B</code>（前5位定死为0，04H）</p>
<p>CAS三根线的作用就体现在这里，用来给从片确认是否能发送中断向量</p>
<h4 id="icw4中断结束方式字">ICW4——中断结束方式字</h4>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101202057030.png" class title="image-20240101202057030">
<p>高三位定死为0，最低位定死为1</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101202438430.png" class title="image-20240101202438430">
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101202445683.png" class title="image-20240101202445683">
<h3 id="写ocw">写OCW</h3>
<p>OCW用于设置8259的工作状态：改变8259A的中断控制方式、屏蔽某几个中断源、控制读出IRR、ISR、IMR的值，以了解中断情况信息</p>
<p>在初始化后任意时刻写入</p>
<p>OCW的写入顺序可任意</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101203454039.png" class title="image-20240101203454039">
<h4 id="ocw1中断屏蔽字">OCW1——中断屏蔽字</h4>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101203532182.png" class title="image-20240101203532182">
<p>1屏蔽，0允许</p>
<p>OCW1对应的A0应该为1</p>
<h4 id="ocw2中断结束和优先级循环">OCW2——中断结束和优先级循环</h4>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101203643543.png" class title="image-20240101203643543">
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101203837035.png" class title="image-20240101203837035">
<p>中断优先方式 ：通过OCW2来设置</p>
<p>两种优先级控制方式：<strong>固定优先级</strong>和<strong>循环优先级</strong></p>
<p>固定优先级方式——OCW2中R位（D7位）= 0</p>
<p>循环优先级方式——OCW2中R位（D7位）= 1</p>
<h5 id="固定优先级-1">固定优先级</h5>
<p>所有中断请求IRi的中断优先级固定不变</p>
<p>优先级排列顺序可编程改变</p>
<p>加电后8259A的<strong>默认方式</strong>，默认优先级顺序从高到低为IR0～IR7</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231227183601648.png" class title="image-20231227183601648">
<h5 id="循环优先级-1">循环优先级</h5>
<p>中断源<strong>轮流处于最高优先级</strong>，即自动中断优先级循环</p>
<p>初始优先级顺序可用编程改变</p>
<p>某中断请求IRi<strong>被处理后</strong>，其优先级别自动<strong>降为最低</strong>，原来<strong>比它低一级的中断上升为最高级</strong></p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231227183924180.png" class title="image-20231227183924180">
<p>如图，此时有2个中断请求：IR6和IR4，IR4优先级更高，所以先响应IR4</p>
<p>响应完IR4以后，IR4的优先级就变成7，也就是最低优先级，最高优先级变成了IR5</p>
<p>优先级调换是在响应完一个中断请求后</p>
<h4 id="ocw3屏蔽方式和读出控制字">OCW3——屏蔽方式和读出控制字</h4>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101204017999.png" class title="image-20240101204017999">
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101204025225.png" class title="image-20240101204025225">
<h2 id="a编程举例">8259A编程举例</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101204116581.png" class title="image-20240101204116581">
<p>上升沿，单片，ICW4，这个是写ICW1，高3位没用，指定D4为1，D2没用</p>
<p>D3写LTIM，0为上升沿，1为高电平</p>
<p>D1写单片还是级联，1单片，0级联</p>
<p>D0写ICW4,0不写1写</p>
<p>对应就是<code>0001_0010B</code>（12H）</p>
<p><br></p>
<p>对应中断向量码给定，用于写ICW2</p>
<p>ICW2，后面3位随着IR0到IR7变，000到111</p>
<p>所以告诉你IR0对应08H，就是<code>0000_1000B</code></p>
<p>故ICW2就写<code>0000_1000B</code>，就是IR0对应的中断向量码</p>
<p><br></p>
<p>IR4到IR7不使用，则修改屏蔽字OCW1：1屏蔽，0允许</p>
<p>即OCW1=<code>1111_0000B</code>（F0H）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INIT8259A：</span><br><span class="line">MOV	DX, 20H	;A0=0，写ICW1</span><br><span class="line">MOV	AL,	12H	;上升沿触发，单片，不写ICW4</span><br><span class="line">OUT	DX,	AL</span><br><span class="line">MOV	DX,	21H	;A0=1，写ICW2，OCW1</span><br><span class="line">MOV	AL,	08H	;ICW2</span><br><span class="line">OUT	DX,	AL</span><br><span class="line">MOV	AL,	0F0H;OCW1：屏蔽IR4-IR7</span><br><span class="line">OUT	DX,	AL</span><br></pre></td></tr></table></figure>
<h2 id="中断程序设计">中断程序设计</h2>
<p>⑴ 确定要使用的中断类型号</p>
<p>某些中断类型号已被系统占用，用户只能占用那些专门保留给用户的中断类型号（PC机可供用户使用的中断类型号为：60H-66H和68H-6FH）</p>
<p>⑵ 保存原中断向量</p>
<p>可使用DOS的35H子功能完成（取出中断向量保存在ES：BX中）</p>
<p>⑶ 设置自己的中断向量</p>
<p>可使用DOS的25H子功能完成</p>
<p>⑷ 设置中断屏蔽字（可选）</p>
<p>通过8259A的OCW1设置完成</p>
<p>⑸ CPU开中断</p>
<p>8086CPU通过STI指令修改标志寄存器IF=1实现</p>
<p>⑹ 退出前要恢复原中断向量</p>
<p>可使用DOS的25H子功能完成</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240101205031573.png" class title="image-20240101205031573">
<h2 id="作业-3">8259作业</h2>
<h3 id="section-4">1.</h3>
<p>某输入接口（74LS244）的端口地址为0E54H，输出接口（74LS273）的端口地址为01FBH。试编写程序，使当输入接口的1、4、7位同时为1时，CPU将内存中DATA为首地址的20个单元的数据从输出接口输出；若不满足上述条件则等待。</p>
<p>答：</p>
<p>判断D1D4D7同时为1：先把原数和<code>1001_0010B</code>相与，得到的结果只会保留这三位</p>
<p>再与<code>1001_0010B</code>做减法，如果为0，就成立了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MOV	CX,	20	;循环次数放入CX</span><br><span class="line">LEA	BX,	DATA	;数据起始地址放入BX</span><br><span class="line">MYLOOP:</span><br><span class="line">MOV	DX,	0E54H	;输入端口</span><br><span class="line">MYWAIT:</span><br><span class="line">IN	AL,	DX		;获取输入</span><br><span class="line">AND	AL,	1001_0010B	;相与，保留147位</span><br><span class="line">CMP	AL,	1001_0010B	;相减，如果结果为0就说明题目要求的成立</span><br><span class="line">JNZ	MYWAIT		;如果结果不为0，就一直循环MYWAIT</span><br><span class="line">MOV	DX,	01FBH	;输出端口</span><br><span class="line">MOV	AX,	[BX]	;获取BX数据</span><br><span class="line">OUT	DX,	AX		;输出数据</span><br><span class="line">INC	BX</span><br><span class="line">LOOP	MYLOOP	;循环20次</span><br></pre></td></tr></table></figure>
<p>其实我感觉这样写也行？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MOV	CX,	20	;循环次数放入CX</span><br><span class="line">LEA	BX,	DATA	;数据起始地址放入BX</span><br><span class="line">MOV	DX,	0E54H	;输入端口</span><br><span class="line">MYWAIT:</span><br><span class="line">IN	AL,	DX		;获取输入</span><br><span class="line">AND	AL,	1001_0010B	;相与，保留147位</span><br><span class="line">CMP	AL,	1001_0010B	;相减，如果结果为0就说明题目要求的成立</span><br><span class="line">JNZ	MYWAIT		;如果结果不为0，就一直循环MYWAIT</span><br><span class="line">MOV	DX,	01FBH	;输出端口</span><br><span class="line">MYLOOP:			;这种写法，就是在147都为1成立以后，一口气传完20位</span><br><span class="line">MOV	AX,	[BX]	;获取BX数据</span><br><span class="line">OUT	DX,	AX		;输出数据</span><br><span class="line">INC	BX</span><br><span class="line">LOOP	MYLOOP	;循环20次</span><br></pre></td></tr></table></figure>
<p>这种写法，就是在147都为1成立以后，一口气传完20位</p>
<p>因为题目没细说，所以逻辑上来说应该是都行</p>
<h3 id="section-5">2.</h3>
<p>PC机8259A中断控制器地址为20H、21H，中断类型号为08H-0FH</p>
<p>初始已经设置为“边沿触发”、“普通结束方式”，外中断源连接到8259A的IRQ7上，响应中断时显示一个字符串</p>
<p>系统还通过开关，决定响应2个软中断（类型号60H-66H），其中1个软中断要求通过发光二极管显示其对应中断类型号，另一个软中断通过发光二极管显示当前开关的值</p>
<p>要求画出电路图，并编写程序。</p>
<p>答：</p>
<p>这道题并不难，先分析要求：</p>
<p>先是8259与一个中断源连接，如果中断源产生中断信号，8259就要给CPU产生一个中断信号，来响应8259对应的中断服务子程序：显示一串字符串，这个用DOS的9H就能实现，把字符串首地址放入DX就行，跟显示单个字符很类似</p>
<p><br></p>
<p>然后题目还要求实现两个软中断，这个通过开关输入实现，把信息输出到二极管</p>
<p>而开关和二极管就是输入输出，说到底也有个地址，根据对应的地址读取输入，信息输出就可以了</p>
<p>至于这个软中断，仍然是正常的中断子程序，只是调用方式用<code>INT</code>来调用，子程序退出仍然是用<code>IRET</code>，仍然要把这个程序放入IVT</p>
<p>软中断的调用条件，就可以写一个死循环，然后每次判断开关的值，调用对应的软中断即可</p>
<p><br></p>
<p>硬件连线：</p>
<p>我规定输入的开关地址为00F1H，输出的二极管地址为00F0H</p>
<p>连接电路如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240104204418670.png" class title="image-20240104204418670">
<p><br></p>
<p>程序结构分析完成，现在开始实际作答</p>
<p>8259的初始化字：</p>
<p>ICW1：边沿触发，D3为0；单片8259，D1为1；普通结束方式，写ICW4为<code>0000_0001B</code>，所以ICW1的D0为1</p>
<p>故ICW1为<code>0001_0011B</code></p>
<p>ICW2：题目规定了中断类型号为08H-0FH，则ICW2为<code>0000_1000B</code></p>
<p>ICW3：没有级联，不需要</p>
<p>ICW4：普通结束，ICW4为<code>0000_0001B</code></p>
<p>OCW123不需要，不写</p>
<p>在8259初始化的同时也要把对应的中断子程序放入IVT，我设置这个程序名为<code>PRINT</code>，直接用就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">INIT8259	PROC	NEAR</span><br><span class="line">MOV	DX,	20H	;A0=0</span><br><span class="line">MOV	AL,	0001_0011B	</span><br><span class="line">OUT	DX,	AL	;写ICW1</span><br><span class="line">MOV	DX,	21H	;A0=1</span><br><span class="line">MOV	AL,	0000_1000B</span><br><span class="line">OUT	DX,	AL	;写ICW2</span><br><span class="line">MOV	AL,	0000_0001B</span><br><span class="line">OUT	DX,	AL	;写ICW4</span><br><span class="line"></span><br><span class="line">CLI		;关中断</span><br><span class="line">PUSHF</span><br><span class="line">PUSH	DS</span><br><span class="line">PUSH	AX</span><br><span class="line">PUSH	SI</span><br><span class="line">MOV	AX,	0</span><br><span class="line">MOV	DS,	AX	;0放入数据段，写IVT</span><br><span class="line">MOV	SI,	0FH * 4	;中断类型号*4放入SI</span><br><span class="line">	;注意，这里接入的是IR7，对应的中断类型号为0FH</span><br><span class="line">LEA	AX,	PRINT	;中断子程序的偏移地址放入AX</span><br><span class="line">MOV	[SI],	AX	;偏移地址写入低字节</span><br><span class="line">MOV	AX,	SEG	PRINT	;段基址放入AX</span><br><span class="line">MOV	[SI+2],	AX	;段基址写入高字节</span><br><span class="line">POP	SI</span><br><span class="line">POP	AX</span><br><span class="line">POP	DS</span><br><span class="line">POPF</span><br><span class="line">STI		;开中断</span><br><span class="line"></span><br><span class="line">RET</span><br><span class="line">INIT8259	ENDP</span><br></pre></td></tr></table></figure>
<p>写完8259初始化程序，
接下来就接着写对应的<code>PRINT</code>中断子程序</p>
<p>我设置数据段里面存<code>STR</code>为要显示的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DATA	SEGMENT</span><br><span class="line">STR	DB	&#x27;STRING&#x27;</span><br><span class="line">DATE	ENDS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PRINT	PROC	NEAR</span><br><span class="line">PUSHF</span><br><span class="line">PUSH	AH</span><br><span class="line">PUSH	DX</span><br><span class="line">CLI</span><br><span class="line">LEA	DX,	STR	;从DATA取数组，基本都是LEA</span><br><span class="line">MOV	AH,	9H</span><br><span class="line">INT	21H</span><br><span class="line">STI</span><br><span class="line">POP	DX</span><br><span class="line">POP	AH</span><br><span class="line">POPF</span><br><span class="line">IRET</span><br><span class="line">PRINT	ENDP</span><br></pre></td></tr></table></figure>
<p>写完8259，就准备写输入输出控制的软中断了</p>
<p><br></p>
<p>我规定输入的开关地址为00F1H，输出的二极管地址为00F0H</p>
<p>我再规定，把软中断程序写入IVT中断向量表的程序名叫<code>SOFT1</code>和<code>SOFT2</code>，软中断对应的两个中断程序名叫<code>INT1</code>和<code>INT2</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SOFT1	PROC	NEAR		;把软中断1写入IVT的程序</span><br><span class="line">CLI		;关中断</span><br><span class="line">PUSHF</span><br><span class="line">PUSH	DS</span><br><span class="line">PUSH	AX</span><br><span class="line">PUSH	SI</span><br><span class="line">MOV	AX,	0</span><br><span class="line">MOV	DS,	AX	;0放入数据段，写IVT</span><br><span class="line">MOV	SI,	60H * 4	;中断类型号60H*4放入SI</span><br><span class="line">LEA	AX,	INT1	;中断子程序的偏移地址放入AX</span><br><span class="line">MOV	[SI],	AX	;偏移地址写入低字节</span><br><span class="line">MOV	AX,	SEG	INT1	;段基址放入AX</span><br><span class="line">MOV	[SI+2],	AX	;段基址写入高字节</span><br><span class="line">POP	SI</span><br><span class="line">POP	AX</span><br><span class="line">POP	DS</span><br><span class="line">POPF</span><br><span class="line">STI		;开中断</span><br><span class="line">SOFT1	ENDP</span><br><span class="line"></span><br><span class="line">SOFT2	PROC	NEAR		;把软中断2写入IVT的程序</span><br><span class="line">CLI		;关中断</span><br><span class="line">PUSHF</span><br><span class="line">PUSH	DS</span><br><span class="line">PUSH	AX</span><br><span class="line">PUSH	SI</span><br><span class="line">MOV	AX,	0</span><br><span class="line">MOV	DS,	AX	;0放入数据段，写IVT</span><br><span class="line">MOV	SI,	61H * 4	;中断类型号61H*4放入SI</span><br><span class="line">LEA	AX,	INT2	;中断子程序的偏移地址放入AX</span><br><span class="line">MOV	[SI],	AX	;偏移地址写入低字节</span><br><span class="line">MOV	AX,	SEG	INT2	;段基址放入AX</span><br><span class="line">MOV	[SI+2],	AX	;段基址写入高字节</span><br><span class="line">POP	SI</span><br><span class="line">POP	AX</span><br><span class="line">POP	DS</span><br><span class="line">POPF</span><br><span class="line">STI		;开中断</span><br><span class="line">SOFT2	ENDP</span><br></pre></td></tr></table></figure>
<p>这两个就是对上面的复制粘贴，只需要改对应的程序名和中断向量号</p>
<p><br></p>
<p>现在写对应的软中断程序1：通过发光二极管显示其对应中断类型号</p>
<p>就是把60H输出到二极管即可，很容易</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INT1	PROC	NEAR</span><br><span class="line">PUSHF</span><br><span class="line">CLI</span><br><span class="line">MOV	DX,	00F0H	;输出，二极管的地址</span><br><span class="line">MOV	AL,	60H</span><br><span class="line">OUT	DX,	AL		;把60H输出到二极管</span><br><span class="line">STI</span><br><span class="line">POPF</span><br><span class="line">IRET	;中断退出</span><br><span class="line">INT1	ENDP</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>现在写对应的软中断程序2：通过发光二极管显示当前开关的值</p>
<p>也就是说，先读输入，再把这个输入值，输出到二极管，也很简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">INT2	PROC	NEAR</span><br><span class="line">PUSHF</span><br><span class="line">CLI</span><br><span class="line">MOV	DX,	00F1H	;输入开关的地址</span><br><span class="line">IN	AL,	DX		;输入读到AL</span><br><span class="line">MOV	DX,	00F0H	;输出，二极管的地址</span><br><span class="line">OUT	DX,	AL		;把读取的输入直接输出到二极管</span><br><span class="line">STI</span><br><span class="line">POPF</span><br><span class="line">IRET	;中断退出</span><br><span class="line">INT2	ENDP</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>最后就是总体的程序，把上面所有进行结合即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">DATA	SEGMENT	</span><br><span class="line">STR	DB	&#x27;STRING&#x27;</span><br><span class="line">DATE	ENDS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CODE	SEGMENT</span><br><span class="line">	ASSUME	CS:CODE,	DS:DATA</span><br><span class="line">START:</span><br><span class="line">	MOV	AX,	DATA</span><br><span class="line">	MOV	DS,	AX</span><br><span class="line">	CALL	INIT8259</span><br><span class="line">	CALL	SOFT1</span><br><span class="line">	CALL	SOFT2</span><br><span class="line">	</span><br><span class="line">	;此处开始是新的，一直读取输入，判断调用哪个软中断</span><br><span class="line">LOOP:</span><br><span class="line">	MOV	DX,	00F1H	;输入地址</span><br><span class="line">	IN	AL,	DX	;读输入到AL</span><br><span class="line">	CMP	AL,	01H	;判断用INT1</span><br><span class="line">	JZ	CALLINT1</span><br><span class="line">	CMP	AL,	02H	;判断用INT2</span><br><span class="line">	JZ	CALLINT2</span><br><span class="line">	JMP	LOOP	;死循环，一直反复执行</span><br><span class="line">CALLINT1:</span><br><span class="line">	INT	60H		;调用中断子程序INT1</span><br><span class="line">	JMP	LOOP</span><br><span class="line">CALLINT2:</span><br><span class="line">	INT	61H		;调用中断子程序INT2</span><br><span class="line">	JMP	LOOP</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">INIT8259	PROC	NEAR</span><br><span class="line">MOV	DX,	20H	;A0=0</span><br><span class="line">MOV	AL,	0001_0011B	</span><br><span class="line">OUT	DX,	AL	;写ICW1</span><br><span class="line">MOV	DX,	21H	;A0=1</span><br><span class="line">MOV	AL,	0000_1000B</span><br><span class="line">OUT	DX,	AL	;写ICW2</span><br><span class="line">MOV	AL,	0000_0001B</span><br><span class="line">OUT	DX,	AL	;写ICW4</span><br><span class="line"></span><br><span class="line">CLI		;关中断</span><br><span class="line">PUSHF</span><br><span class="line">PUSH	DS</span><br><span class="line">PUSH	AX</span><br><span class="line">PUSH	SI</span><br><span class="line">MOV	AX,	0</span><br><span class="line">MOV	DS,	AX	;0放入数据段，写IVT</span><br><span class="line">MOV	SI,	0FH * 4	;中断类型号*4放入SI</span><br><span class="line">	;注意，这里接入的是IR7，对应的中断类型号为0FH</span><br><span class="line">LEA	AX,	PRINT	;中断子程序的偏移地址放入AX</span><br><span class="line">MOV	[SI],	AX	;偏移地址写入低字节</span><br><span class="line">MOV	AX,	SEG	PRINT	;段基址放入AX</span><br><span class="line">MOV	[SI+2],	AX	;段基址写入高字节</span><br><span class="line">POP	SI</span><br><span class="line">POP	AX</span><br><span class="line">POP	DS</span><br><span class="line">POPF</span><br><span class="line">STI		;开中断</span><br><span class="line"></span><br><span class="line">RET</span><br><span class="line">INIT8259	ENDP</span><br><span class="line"></span><br><span class="line">SOFT1	PROC	NEAR		;把软中断1写入IVT的程序</span><br><span class="line">CLI		;关中断</span><br><span class="line">PUSHF</span><br><span class="line">PUSH	DS</span><br><span class="line">PUSH	AX</span><br><span class="line">PUSH	SI</span><br><span class="line">MOV	AX,	0</span><br><span class="line">MOV	DS,	AX	;0放入数据段，写IVT</span><br><span class="line">MOV	SI,	60H * 4	;中断类型号60H*4放入SI</span><br><span class="line">LEA	AX,	INT1	;中断子程序的偏移地址放入AX</span><br><span class="line">MOV	[SI],	AX	;偏移地址写入低字节</span><br><span class="line">MOV	AX,	SEG	INT1	;段基址放入AX</span><br><span class="line">MOV	[SI+2],	AX	;段基址写入高字节</span><br><span class="line">POP	SI</span><br><span class="line">POP	AX</span><br><span class="line">POP	DS</span><br><span class="line">POPF</span><br><span class="line">STI		;开中断</span><br><span class="line">SOFT1	ENDP</span><br><span class="line"></span><br><span class="line">SOFT2	PROC	NEAR		;把软中断2写入IVT的程序</span><br><span class="line">CLI		;关中断</span><br><span class="line">PUSHF</span><br><span class="line">PUSH	DS</span><br><span class="line">PUSH	AX</span><br><span class="line">PUSH	SI</span><br><span class="line">MOV	AX,	0</span><br><span class="line">MOV	DS,	AX	;0放入数据段，写IVT</span><br><span class="line">MOV	SI,	61H * 4	;中断类型号61H*4放入SI</span><br><span class="line">LEA	AX,	INT2	;中断子程序的偏移地址放入AX</span><br><span class="line">MOV	[SI],	AX	;偏移地址写入低字节</span><br><span class="line">MOV	AX,	SEG	INT2	;段基址放入AX</span><br><span class="line">MOV	[SI+2],	AX	;段基址写入高字节</span><br><span class="line">POP	SI</span><br><span class="line">POP	AX</span><br><span class="line">POP	DS</span><br><span class="line">POPF</span><br><span class="line">STI		;开中断</span><br><span class="line">SOFT2	ENDP</span><br><span class="line"></span><br><span class="line">INT1	PROC	NEAR</span><br><span class="line">PUSHF</span><br><span class="line">CLI</span><br><span class="line">MOV	DX,	00F0H	;输出，二极管的地址</span><br><span class="line">MOV	AL,	60H</span><br><span class="line">OUT	DX,	AL		;把60H输出到二极管</span><br><span class="line">STI</span><br><span class="line">POPF</span><br><span class="line">IRET	;中断退出</span><br><span class="line">INT1	ENDP</span><br><span class="line"></span><br><span class="line">INT2	PROC	NEAR</span><br><span class="line">PUSHF</span><br><span class="line">CLI</span><br><span class="line">MOV	DX,	00F1H	;输入开关的地址</span><br><span class="line">IN	AL,	DX		;输入读到AL</span><br><span class="line">MOV	DX,	00F0H	;输出，二极管的地址</span><br><span class="line">OUT	DX,	AL		;把读取的输入直接输出到二极管</span><br><span class="line">STI</span><br><span class="line">POPF</span><br><span class="line">IRET	;中断退出</span><br><span class="line">INT2	ENDP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">CODE	ENDS</span><br><span class="line">	END	START</span><br></pre></td></tr></table></figure>
<h3 id="section-6">3.</h3>
<p>已知（SP）=0100H,（SS）=3500H,（CS）=9000H,（IP）=0200H,（00020H）=7FH,（00021H）=1AH,（00022H）=07H,（00023H）=6CH</p>
<p>在地址为90200H开始的连续2个单元中存放1条两字节指令INT 8</p>
<p>试指出在执行该指令并进入相应的中断程序时，SP、SS、IP、CS寄存器的内容以及SP所指向的字单元的内容是什么？</p>
<p>答：</p>
<p>执行该指令时，IP为下一条指令的地址，即0200H+2H=0202H</p>
<p>8086响应中断，首先把<code>FLAG</code>压栈，所以SP先减2为<code>00FEH</code></p>
<p>再关中断，这个不影响这些寄存器</p>
<p>再把CS内容压栈，即SP再减2为<code>00FCH</code></p>
<p>再把IP内容压栈，即SP再减2为<code>00FAH</code>，此时SP指向的内容就是0202H</p>
<p>这时就取中断向量送入IP和CS了</p>
<p>把偏移地址送入IP，把段基址送入CS</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231227180005215.png" class title="image-20231227180005215">
<p>于是，答案为：</p>
<p>SS不变，3500H</p>
<p>SP压栈3次，变为00FAH</p>
<p>IP变为1A7FH</p>
<p>CS变为6C07H</p>
<p>SP指向的内容，看最后一个被压栈的内容：IP，即0202H</p>
<h3 id="section-7">4.</h3>
<p>某系统中设置三片8259A，级连使用，一片为主8259A（端口地址为20H、21H），2片为从8259A（端口地址分别为A0H、A1H和B0H、B1H）它们分别接入主8259A的IR2和IR0端。若已知当前主8259A和从8259A的IR3上各接有一个外中断源，它们的中断类型码分别为C3H，E3H，F3H，已知它们的中断入口均在同一段中，其段地址为2050H，偏移地址分别为11A0H、22B0H、33C0H，所有中断都采用电平触发方式、完全嵌套、普通EOI结束方式。要求：</p>
<p>⑴ 画出它们的硬件连接图；</p>
<p>⑵ 编写全部的初始化程序。</p>
<p>答：</p>
<p>（1）</p>
<p>电路图有些麻烦，因为涉及到8259级联</p>
<p>级联，就是把从片的INT连接到主片的IR上，题目要求，一个连IR2，一个连IR0；并且把主片的CAS信号引出来，分别连到从片对应的CAS上，很容易</p>
<p>然后就是，题目说的，三个8259的IR3都连接外部中断，连上就行</p>
<p>主片的地址为：<code>0010_0000B</code>到<code>0010_0001B</code></p>
<p>从片1的地址为：<code>1010_0000B</code>到<code>1010_0001B</code></p>
<p>从片2的地址为：<code>1011_0000B</code>到<code>1011_0001B</code></p>
<p>利用差别就可以唯一选中这些芯片，还是建议用138芯片的Y0输出</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20240104211648363.png" class title="image-20240104211648363">
<p>（2）</p>
<p>分析各个芯片的控制字</p>
<p>主片控制字：</p>
<p>ICW1：电平触发，D3为1；有级联，所以D1为0；要普通EOI结束，需要写ICW4，D0为1</p>
<p>所以ICW1为<code>0001_1001B</code></p>
<p>ICW2：对应的中断向量号为C0H，因为IR3对应的是C3H，这里要求的是IR0的中断向量号，对应为<code>1100_0000B</code></p>
<p>ICW3：用到级联，需要写：对应位1用0不用</p>
<p>主片用到的<strong>从片的位</strong>有IR0, IR2，<strong>没有
IR3</strong>，因为IR3是连的外界中断源，所以对应的ICW3为<code>0000_0101B</code></p>
<p>ICW4：正常EOI就是<code>0000_0001B</code>，很好记</p>
<p>OCW1：不屏蔽，不写</p>
<p>OCW2：完全嵌套，就是<code>0010_0000B</code></p>
<p>OCW3：不需要，不写</p>
<p><br></p>
<p>连接在主片IR2上的从片的控制字：</p>
<p>ICW1：电平触发，D3为1；有级联，所以D1为0；要普通EOI结束，需要写ICW4，D0为1</p>
<p>所以ICW1为<code>0001_1001B</code></p>
<p>ICW2：对应的中断向量号为E0H，因为IR3对应的是E3H，这里要求的是IR0的中断向量号，对应为<code>1110_0000B</code></p>
<p>ICW3：连接在主片的IR2上，所以ICW3为<code>0000_0010B</code></p>
<p>ICW4：正常EOI就是<code>0000_0001B</code>，很好记</p>
<p>OCW1：不屏蔽不写</p>
<p>OCW2：和主片一样，完全嵌套，就是<code>0010_0000B</code></p>
<p>OCW3：不需要，不写</p>
<p><br></p>
<p>连接在主片IR0上的从片的控制字：</p>
<p>ICW1：电平触发，D3为1；有级联，所以D1为0；要普通EOI结束，需要写ICW4，D0为1</p>
<p>所以ICW1为<code>0001_1001B</code></p>
<p>ICW2：对应的中断向量号为F0H，因为IR3对应的是F3H，这里要求的是IR0的中断向量号，对应为<code>1111_0000B</code></p>
<p>ICW3：连接在主片的IR0上，所以ICW3为<code>0000_0000B</code></p>
<p>ICW4：正常EOI就是<code>0000_0001B</code>，很好记</p>
<p>OCW1：不屏蔽不写</p>
<p>OCW2：和主片一样，完全嵌套，就是<code>0010_0000B</code></p>
<p>OCW3：不需要，不写</p>
<p><br></p>
<p>最后的最后，编写初始化程序</p>
<p>初始化要考虑控制字的写，还要考虑中断向量放入IVT</p>
<p>主片初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">;主片8259初始化</span><br><span class="line">MOV	DX,	20H			;A0=0</span><br><span class="line">MOV	AL,	0001_1001B	</span><br><span class="line">OUT	DX,	AL			;写ICW1</span><br><span class="line">MOV	DX,	21H</span><br><span class="line">MOV	AL,	1100_0000B</span><br><span class="line">OUT	DX,	AL			;写ICW2</span><br><span class="line">MOV	AL,	0000_0101B</span><br><span class="line">OUT	DX,	AL			;写ICW3</span><br><span class="line">MOV	AL,	0000_0001B</span><br><span class="line">OUT	DX,	AL			;写ICW4</span><br><span class="line">MOV	DX,	20H			;A0=0</span><br><span class="line">MOV	AL,	0010_0000B	</span><br><span class="line">OUT	DX,	AL			;写OCW2</span><br><span class="line">;把IR3对应的中断服务程序写入IVT</span><br><span class="line">PUSHF</span><br><span class="line">CLI</span><br><span class="line">MOV	AX,	0</span><br><span class="line">MOV	DS,	AX</span><br><span class="line">MOV	SI,	C3H * 4	;中断向量号乘4</span><br><span class="line">MOV	AX,	11A0H	;偏移地址</span><br><span class="line">MOV	[SI],	AX	;偏移地址放入低字节</span><br><span class="line">MOV	AX,	2050H	;段基址</span><br><span class="line">MOV	[SI+2],	AX	;段基址放入高字节</span><br><span class="line">STI</span><br><span class="line">POPF</span><br></pre></td></tr></table></figure>
<p>连接主片IR2的从片初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">;连接主片IR2的从片初始化</span><br><span class="line">MOV	DX,	20H			;A0=0</span><br><span class="line">MOV	AL,	0001_1001B	</span><br><span class="line">OUT	DX,	AL			;写ICW1</span><br><span class="line">MOV	DX,	21H</span><br><span class="line">MOV	AL,	1110_0000B</span><br><span class="line">OUT	DX,	AL			;写ICW2</span><br><span class="line">MOV	AL,	0000_0010B</span><br><span class="line">OUT	DX,	AL			;写ICW3</span><br><span class="line">MOV	AL,	0000_0001B</span><br><span class="line">OUT	DX,	AL			;写ICW4</span><br><span class="line">MOV	DX,	20H			;A0=0</span><br><span class="line">MOV	AL,	0010_0000B	</span><br><span class="line">OUT	DX,	AL			;写OCW2</span><br><span class="line">;把IR3对应的中断服务程序写入IVT</span><br><span class="line">PUSHF</span><br><span class="line">CLI</span><br><span class="line">MOV	AX,	0</span><br><span class="line">MOV	DS,	AX</span><br><span class="line">MOV	SI,	E3H * 4	;中断向量号乘4</span><br><span class="line">MOV	AX,	22B0H	;偏移地址</span><br><span class="line">MOV	[SI],	AX	;偏移地址放入低字节</span><br><span class="line">MOV	AX,	2050H	;段基址</span><br><span class="line">MOV	[SI+2],	AX	;段基址放入高字节</span><br><span class="line">STI</span><br><span class="line">POPF</span><br></pre></td></tr></table></figure>
<p>连接主片IR0的从片初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">;连接主片IR0的从片初始化</span><br><span class="line">MOV	DX,	20H			;A0=0</span><br><span class="line">MOV	AL,	0001_1001B	</span><br><span class="line">OUT	DX,	AL			;写ICW1</span><br><span class="line">MOV	DX,	21H</span><br><span class="line">MOV	AL,	1111_0000B</span><br><span class="line">OUT	DX,	AL			;写ICW2</span><br><span class="line">MOV	AL,	0000_0000B</span><br><span class="line">OUT	DX,	AL			;写ICW3</span><br><span class="line">MOV	AL,	0000_0001B</span><br><span class="line">OUT	DX,	AL			;写ICW4</span><br><span class="line">MOV	DX,	20H			;A0=0</span><br><span class="line">MOV	AL,	0010_0000B	</span><br><span class="line">OUT	DX,	AL			;写OCW2</span><br><span class="line">;把IR3对应的中断服务程序写入IVT</span><br><span class="line">PUSHF</span><br><span class="line">CLI</span><br><span class="line">MOV	AX,	0</span><br><span class="line">MOV	DS,	AX</span><br><span class="line">MOV	SI,	F3H * 4	;中断向量号乘4</span><br><span class="line">MOV	AX,	33C0H	;偏移地址</span><br><span class="line">MOV	[SI],	AX	;偏移地址放入低字节</span><br><span class="line">MOV	AX,	2050H	;段基址</span><br><span class="line">MOV	[SI+2],	AX	;段基址放入高字节</span><br><span class="line">STI</span><br><span class="line">POPF</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<p><br></p>
<hr>
<h1 id="参考资料">参考资料</h1>
<p>课程PPT</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/">复习整理</a><a class="post-meta__tags" href="/tags/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/">接口技术</a><a class="post-meta__tags" href="/tags/8086/">8086</a><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">汇编语言</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/20/hexo%E7%9B%B8%E5%85%B3/Hexo_Nunjucks_Error%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" title="Hexo Nunjucks Error解决方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hexo Nunjucks Error解决方法</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/06/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/OOAD%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="OOAD复习整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">OOAD复习整理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/Java%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="Java复习整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-12</div><div class="title">Java复习整理</div></div></a></div><div><a href="/2023/12/06/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/OOAD%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="OOAD复习整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-06</div><div class="title">OOAD复习整理</div></div></a></div><div><a href="/2024/01/01/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="数字图像处理复习整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-01</div><div class="title">数字图像处理复习整理</div></div></a></div><div><a href="/2023/06/03/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="数字信号处理复习整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-03</div><div class="title">数字信号处理复习整理</div></div></a></div><div><a href="/2023/02/16/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="操作系统复习整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-16</div><div class="title">操作系统复习整理</div></div></a></div><div><a href="/2023/12/28/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="数值分析复习整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-28</div><div class="title">数值分析复习整理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/WinkySpeed%20SP%20-%20Repaired.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">WinkySpeed</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WinkySpeed"><i class="fab fa-github"></i><span>GitHub</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">接口技术复习整理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">2.</span> <span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9C%A8%E5%B7%A5%E4%B8%9A%E7%94%9F%E4%BA%A7%E8%BF%87%E7%A8%8B%E7%9A%84%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">计算机在工业生产过程的闭环控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">总线分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu"><span class="toc-number">2.3.</span> <span class="toc-text">CPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.</span> <span class="toc-text">I&#x2F;O接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%AE%BE%E9%80%9A%E8%BF%87io%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%80%BB%E7%BA%BF%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.4.1.</span> <span class="toc-text">外设通过I&#x2F;O接口与总线连接的原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA"><span class="toc-number">2.5.</span> <span class="toc-text">微机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.5.1.</span> <span class="toc-text">微机基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">微机工作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA%E5%88%86%E7%B1%BB"><span class="toc-number">2.5.3.</span> <span class="toc-text">微机分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA%E7%BB%84%E6%88%90"><span class="toc-number">2.5.4.</span> <span class="toc-text">微机组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.5.</span> <span class="toc-text">微机工作原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">8086系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">8086CPU结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE"><span class="toc-number">3.1.1.</span> <span class="toc-text">8086CPU内部结构框图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E6%8E%A5%E5%8F%A3%E9%83%A8%E4%BB%B6biubus-interfaceunit"><span class="toc-number">3.1.2.</span> <span class="toc-text">总线接口部件BIU(Bus
InterfaceUnit)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#biu%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">BIU功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#biu%E7%BB%84%E6%88%90"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">BIU组成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E6%AE%B5%E5%9F%BA%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.2.2.1.</span> <span class="toc-text">段寄存器（段基址寄存器）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.2.2.2.</span> <span class="toc-text">指令指针寄存器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%8A%A0%E6%B3%95%E5%99%A8"><span class="toc-number">3.1.2.2.3.</span> <span class="toc-text">物理地址加法器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%98%9F%E5%88%97"><span class="toc-number">3.1.2.2.4.</span> <span class="toc-text">指令队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E6%8E%A7%E5%88%B6%E9%83%A8%E4%BB%B6"><span class="toc-number">3.1.2.2.5.</span> <span class="toc-text">总线控制部件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#biu%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">BIU工作过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%83%A8%E4%BB%B6euexecution-unit"><span class="toc-number">3.1.3.</span> <span class="toc-text">指令执行部件EU(Execution
Unit)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#eu%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">EU功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eu%E7%BB%84%E6%88%90"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">EU组成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E9%80%BB%E8%BE%91%E9%83%A8%E4%BB%B6alu"><span class="toc-number">3.1.3.2.1.</span> <span class="toc-text">算术运算逻辑部件ALU</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8frflag-register"><span class="toc-number">3.1.3.2.2.</span> <span class="toc-text">标志寄存器FR（Flag Register）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A0%87%E5%BF%97"><span class="toc-number">3.1.3.2.2.1.</span> <span class="toc-text">状态标志</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%A0%87%E5%BF%97"><span class="toc-number">3.1.3.2.2.2.</span> <span class="toc-text">控制标志</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.3.2.3.</span> <span class="toc-text">通用寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.3.2.3.1.</span> <span class="toc-text">数据寄存器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.3.2.3.2.</span> <span class="toc-text">指针变址寄存器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#eu%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">3.1.3.2.4.</span> <span class="toc-text">EU控制器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eu%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">EU的工作过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu%E5%BC%95%E8%84%9A"><span class="toc-number">3.2.</span> <span class="toc-text">8086CPU引脚</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E8088%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">3.3.</span> <span class="toc-text">8086与8088不同之处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87"><span class="toc-number">3.4.</span> <span class="toc-text">8086存储器组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BC%96%E5%9D%80"><span class="toc-number">3.4.1.</span> <span class="toc-text">线性编址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">3.4.2.</span> <span class="toc-text">数据存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%8A%80%E6%9C%AF"><span class="toc-number">3.4.3.</span> <span class="toc-text">分段技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E6%AE%B5"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">存储空间的分段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%A2%E6%88%90"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">物理地址的形成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%9A%84%E6%9D%A5%E6%BA%90%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E6%AE%B5%E5%86%85%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8%E6%90%AD%E9%85%8D%E4%BD%BF%E7%94%A8"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">逻辑地址的来源（段寄存器与段内指针寄存器搭配使用）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.4.</span> <span class="toc-text">分体结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E9%82%BB%E4%B8%A4%E4%B8%AA%E5%8D%95%E5%85%83%E5%AD%97%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">相邻两个单元（字）的读写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%B6%E5%9C%B0%E5%9D%80%E4%B8%BA%E4%BD%8E%E5%AD%97%E8%8A%82%E7%9A%84%E5%AD%97%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">3.4.4.1.1.</span> <span class="toc-text">偶地址为低字节的字的读写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A5%87%E5%9C%B0%E5%9D%80%E4%B8%BA%E4%BD%8E%E5%AD%97%E8%8A%82%E7%9A%84%E5%AD%97%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">3.4.4.1.2.</span> <span class="toc-text">奇地址为低字节的字的读写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%A0%88"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">堆栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A"><span class="toc-number">3.5.</span> <span class="toc-text">8086作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">8086指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.</span> <span class="toc-text">8086指令的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%81%B5%E6%B4%BB%E7%9A%84%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.灵活的指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%BD%A2%E5%BC%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">2.指令格式的一对多形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%83%E5%BC%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">4.1.3.</span> <span class="toc-text">3.较强的运算指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%9C%89%E6%9E%81%E5%BC%BA%E7%9A%84%E5%AF%BB%E5%9D%80%E8%83%BD%E5%8A%9B"><span class="toc-number">4.1.4.</span> <span class="toc-text">4.指令有极强的寻址能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%9C%89%E5%A4%84%E7%90%86%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="toc-number">4.1.5.</span> <span class="toc-text">5.指令有处理多种数据的能力</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">8086指令寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">立即寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">寄存器寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">直接寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.1.4.</span> <span class="toc-text">寄存器间接寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.1.5.</span> <span class="toc-text">基址&#x2F;变址寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80-1"><span class="toc-number">4.2.1.6.</span> <span class="toc-text">基址+变址寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.1.7.</span> <span class="toc-text">串寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io%E7%AB%AF%E5%8F%A3%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.1.8.</span> <span class="toc-text">I&#x2F;O端口寻址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">8086指令格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">8086数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">4.5.</span> <span class="toc-text">8086指令集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.1.</span> <span class="toc-text">数据传输指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4%E5%85%B1%E5%90%8C%E7%89%B9%E7%82%B9"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">数据传输指令共同特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.1.2.</span> <span class="toc-text">通用数据传输指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4mov"><span class="toc-number">4.5.1.2.1.</span> <span class="toc-text">传送指令MOV</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#mov%E6%8C%87%E4%BB%A4%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F"><span class="toc-number">4.5.1.2.1.1.</span> <span class="toc-text">MOV指令需要注意</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4push"><span class="toc-number">4.5.1.2.2.</span> <span class="toc-text">入栈指令PUSH</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BA%E6%A0%88%E6%8C%87%E4%BB%A4pop"><span class="toc-number">4.5.1.2.3.</span> <span class="toc-text">出栈指令POP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8C%87%E4%BB%A4xchg"><span class="toc-number">4.5.1.2.4.</span> <span class="toc-text">交换指令XCHG</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%AF%E5%8A%A0%E5%99%A8%E4%B8%93%E7%94%A8%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.1.3.</span> <span class="toc-text">累加器专用传输指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8C%87%E4%BB%A4in"><span class="toc-number">4.5.1.3.1.</span> <span class="toc-text">输入指令IN</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%8C%87%E4%BB%A4out"><span class="toc-number">4.5.1.3.2.</span> <span class="toc-text">输出指令OUT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8D%A2%E7%A0%81%E6%8C%87%E4%BB%A4xlat"><span class="toc-number">4.5.1.3.3.</span> <span class="toc-text">换码指令XLAT</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%9C%B0%E5%9D%80%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.1.4.</span> <span class="toc-text">目标地址传输指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#lea%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80%E4%BC%A0%E8%BE%93%E5%88%B0%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.5.1.4.1.</span> <span class="toc-text">LEA（有效地址传输到寄存器）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#lds%E8%A3%85%E5%85%A5%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">4.5.1.4.2.</span> <span class="toc-text">LDS（装入一个新的物理地址）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#les%E8%A3%85%E5%85%A5%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">4.5.1.4.3.</span> <span class="toc-text">LES（装入一个新的物理地址）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.1.5.</span> <span class="toc-text">标志寄存器传送指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.2.</span> <span class="toc-text">算术运算指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">算数运算指令的共同点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%8A%A0%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.2.2.</span> <span class="toc-text">算术加法指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%8A%A0%E6%B3%95add"><span class="toc-number">4.5.2.2.1.</span> <span class="toc-text">算术加法ADD</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E8%BF%9B%E4%BD%8D%E7%AE%97%E6%9C%AF%E5%8A%A0%E6%B3%95adc"><span class="toc-number">4.5.2.2.2.</span> <span class="toc-text">带进位算术加法ADC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A01%E6%8C%87%E4%BB%A4inc"><span class="toc-number">4.5.2.2.3.</span> <span class="toc-text">加1指令INC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E5%8E%8B%E7%BC%A9bcd%E6%95%B0%E5%8A%A0%E6%B3%95%E6%93%8D%E4%BD%9C%E7%9A%84%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E6%A0%A1%E6%AD%A3daa"><span class="toc-number">4.5.2.2.4.</span> <span class="toc-text">对压缩BCD数加法操作的结果进行校正DAA</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E9%9D%9E%E5%8E%8B%E7%BC%A9bcd%E6%95%B0%E5%8A%A0%E6%B3%95%E6%93%8D%E4%BD%9C%E7%9A%84%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E6%A0%A1%E6%AD%A3aaa"><span class="toc-number">4.5.2.2.5.</span> <span class="toc-text">对非压缩BCD数加法操作的结果进行校正AAA</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%87%8F%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.2.3.</span> <span class="toc-text">算术减法指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%87%8F%E6%B3%95sub"><span class="toc-number">4.5.2.3.1.</span> <span class="toc-text">算术减法SUB</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E8%BF%9B%E4%BD%8D%E7%AE%97%E6%9C%AF%E5%87%8F%E6%B3%95sbb"><span class="toc-number">4.5.2.3.2.</span> <span class="toc-text">带进位算术减法SBB</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F1%E6%8C%87%E4%BB%A4dec"><span class="toc-number">4.5.2.3.3.</span> <span class="toc-text">减1指令DEC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E5%8E%8B%E7%BC%A9bcd%E6%95%B0%E5%87%8F%E6%B3%95%E6%93%8D%E4%BD%9C%E7%9A%84%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E6%A0%A1%E6%AD%A3das"><span class="toc-number">4.5.2.3.4.</span> <span class="toc-text">对压缩BCD数减法操作的结果进行校正DAS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E9%9D%9E%E5%8E%8B%E7%BC%A9bcd%E6%95%B0%E5%87%8F%E6%B3%95%E6%93%8D%E4%BD%9C%E7%9A%84%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E6%A0%A1%E6%AD%A3aas"><span class="toc-number">4.5.2.3.5.</span> <span class="toc-text">对非压缩BCD数减法操作的结果进行校正AAS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4cmp"><span class="toc-number">4.5.2.3.6.</span> <span class="toc-text">比较指令CMP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%96%E8%A1%A5%E6%8C%87%E4%BB%A4neg"><span class="toc-number">4.5.2.3.7.</span> <span class="toc-text">取补指令NEG</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.2.4.</span> <span class="toc-text">算术乘法指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4mul"><span class="toc-number">4.5.2.4.1.</span> <span class="toc-text">无符号数乘法指令MUL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4imul"><span class="toc-number">4.5.2.4.2.</span> <span class="toc-text">带符号数乘法指令IMUL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%8E%8B%E7%BC%A9bcd%E6%95%B0%E4%B9%98%E6%B3%95%E7%BB%93%E6%9E%9C%E6%A0%A1%E6%AD%A3aam"><span class="toc-number">4.5.2.4.3.</span> <span class="toc-text">非压缩BCD数乘法结果校正AAM</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E9%99%A4%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.2.5.</span> <span class="toc-text">算术除法指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%99%A4%E6%B3%95%E6%8C%87%E4%BB%A4div"><span class="toc-number">4.5.2.5.1.</span> <span class="toc-text">无符号数除法指令DIV</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%99%A4%E6%B3%95%E6%8C%87%E4%BB%A4idiv"><span class="toc-number">4.5.2.5.2.</span> <span class="toc-text">带符号数除法指令IDIV</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%AD%97%E8%8A%82%E6%89%A9%E5%B1%95%E6%8C%87%E4%BB%A4cbw"><span class="toc-number">4.5.2.5.3.</span> <span class="toc-text">带符号数字节扩展指令CBW</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%AD%97%E6%89%A9%E5%B1%95%E6%8C%87%E4%BB%A4cwd"><span class="toc-number">4.5.2.5.4.</span> <span class="toc-text">带符号数字扩展指令CWD</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%8E%8B%E7%BC%A9bcd%E6%95%B0%E9%99%A4%E6%B3%95%E7%BB%93%E6%9E%9C%E6%A0%A1%E6%AD%A3aad"><span class="toc-number">4.5.2.5.5.</span> <span class="toc-text">非压缩BCD数除法结果校正AAD</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.3.</span> <span class="toc-text">位操作指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E5%85%B1%E5%90%8C%E7%89%B9%E7%82%B9"><span class="toc-number">4.5.3.1.</span> <span class="toc-text">位操作指令共同特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.3.2.</span> <span class="toc-text">逻辑运算指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E9%9D%9E%E6%8C%87%E4%BB%A4not"><span class="toc-number">4.5.3.2.1.</span> <span class="toc-text">逻辑非指令NOT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%B8%8E%E6%8C%87%E4%BB%A4and"><span class="toc-number">4.5.3.2.2.</span> <span class="toc-text">逻辑与指令AND</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%88%96%E6%8C%87%E4%BB%A4or"><span class="toc-number">4.5.3.2.3.</span> <span class="toc-text">逻辑或指令OR</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96%E6%8C%87%E4%BB%A4xor"><span class="toc-number">4.5.3.2.4.</span> <span class="toc-text">逻辑异或指令XOR</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%8C%87%E4%BB%A4test"><span class="toc-number">4.5.3.2.5.</span> <span class="toc-text">测试指令TEST</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.3.3.</span> <span class="toc-text">逻辑移位指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.3.3.1.</span> <span class="toc-text">非循环移位指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.3.3.2.</span> <span class="toc-text">循环移位指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.4.</span> <span class="toc-text">串处理指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">4.5.4.1.</span> <span class="toc-text">串处理指令共同点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E6%8C%87%E4%BB%A4%E4%BD%BF%E7%94%A8%E4%B8%80%E8%88%AC%E6%96%B9%E6%B3%95"><span class="toc-number">4.5.4.2.</span> <span class="toc-text">串指令使用一般方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cld%E5%92%8Cstd%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.4.3.</span> <span class="toc-text">CLD和STD指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4movsb%E6%88%96movsw"><span class="toc-number">4.5.4.4.</span> <span class="toc-text">串传输指令MOVSB或MOVSW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4cmpsb%E6%88%96cmpsw"><span class="toc-number">4.5.4.5.</span> <span class="toc-text">串比较指令CMPSB或CMPSW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E6%90%9C%E7%B4%A2%E6%8C%87%E4%BB%A4scasb%E6%88%96scasw"><span class="toc-number">4.5.4.6.</span> <span class="toc-text">串搜索指令SCASB或SCASW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E8%A3%85%E5%85%A5%E6%8C%87%E4%BB%A4lodsb%E6%88%96lodsw"><span class="toc-number">4.5.4.7.</span> <span class="toc-text">串装入指令LODSB或LODSW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4stosb%E6%88%96stosw"><span class="toc-number">4.5.4.8.</span> <span class="toc-text">串存储指令STOSB或STOSW</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%89%8D%E7%BC%80"><span class="toc-number">4.5.5.</span> <span class="toc-text">指令前缀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rep%E5%89%8D%E7%BC%80"><span class="toc-number">4.5.5.1.</span> <span class="toc-text">REP前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repzrepe%E5%89%8D%E7%BC%80"><span class="toc-number">4.5.5.2.</span> <span class="toc-text">REPZ&#x2F;REPE前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repnzrepne%E5%89%8D%E7%BC%80"><span class="toc-number">4.5.5.3.</span> <span class="toc-text">REPNZ&#x2F;REPNE前缀</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.6.</span> <span class="toc-text">程序控制转移指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BBjmp"><span class="toc-number">4.5.6.1.</span> <span class="toc-text">无条件转移JMP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E5%86%85%E8%BD%AC%E7%A7%BB"><span class="toc-number">4.5.6.1.1.</span> <span class="toc-text">段内转移</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E9%97%B4%E8%BD%AC%E7%A7%BB"><span class="toc-number">4.5.6.1.2.</span> <span class="toc-text">段间转移</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB"><span class="toc-number">4.5.6.2.</span> <span class="toc-text">条件转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.6.3.</span> <span class="toc-text">循环控制指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#loop"><span class="toc-number">4.5.6.3.1.</span> <span class="toc-text">LOOP</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E5%92%8C%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.6.4.</span> <span class="toc-text">子程序调用和返回指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8call"><span class="toc-number">4.5.6.4.1.</span> <span class="toc-text">子程序调用CALL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9Eret"><span class="toc-number">4.5.6.4.2.</span> <span class="toc-text">子程序返回RET</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8C%87%E4%BB%A4%E5%92%8C%E4%B8%AD%E6%96%AD%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.6.5.</span> <span class="toc-text">中断指令和中断返回指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.5.7.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.8.</span> <span class="toc-text">处理器控制指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86%E6%80%BB%E7%BB%93"><span class="toc-number">4.6.</span> <span class="toc-text">8086指令集总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E5%88%B0%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">4.6.1.</span> <span class="toc-text">用到的指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E7%94%A8%E7%AB%8B%E5%8D%B3%E6%95%B0%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">4.6.2.</span> <span class="toc-text">能用立即数的指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E7%94%A8%E7%AB%8B%E5%8D%B3%E6%95%B0%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">4.6.3.</span> <span class="toc-text">不能用立即数的指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%90%AB%E6%B2%A1%E6%9C%89%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">4.6.4.</span> <span class="toc-text">隐含&#x2F;没有操作数的指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%9C%E4%B8%9A"><span class="toc-number">4.7.</span> <span class="toc-text">指令集作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.</span> <span class="toc-text">汇编语言程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.1.</span> <span class="toc-text">汇编语言语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%80%A7%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.1.1.</span> <span class="toc-text">指令性语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E7%A4%BA%E6%80%A7%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.1.2.</span> <span class="toc-text">指示性语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E5%B1%9E%E6%80%A7"><span class="toc-number">5.1.3.</span> <span class="toc-text">有关属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">5.2.</span> <span class="toc-text">伪指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%AE%9A%E4%B9%89%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.2.1.</span> <span class="toc-text">符号定义语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%80%BC%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">等值语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%8F%B7%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">等号语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.2.2.</span> <span class="toc-text">变量定义语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E7%BB%84%E6%95%B0%E6%8D%AE"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">定义一组数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%B2%E5%AD%97%E7%AC%A6"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">定义一串字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%BF%9D%E7%95%99%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">定义保留存储单元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">5.2.2.4.</span> <span class="toc-text">复制操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%AE%9A%E4%B9%89%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.2.3.</span> <span class="toc-text">段定义语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%AE%9A%E4%B9%89%E8%AF%AD%E5%8F%A5segment"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">段定义语句SEGMENT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E8%AF%B4%E6%98%8E%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">段说明语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E5%AE%9A%E4%B9%89%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.2.4.</span> <span class="toc-text">过程定义语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F%E8%AF%AD%E5%8F%A5end"><span class="toc-number">5.2.5.</span> <span class="toc-text">结束语句END</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%8F%E8%B0%83%E7%94%A8"><span class="toc-number">5.2.6.</span> <span class="toc-text">宏定义与宏调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dos%E5%8A%9F%E8%83%BD%E8%B0%83%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text">DOS功能调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ppt%E4%B8%8A%E6%B1%87%E7%BC%96%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">5.4.</span> <span class="toc-text">PPT上汇编的例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">5.4.1.</span> <span class="toc-text">顺序执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.2.</span> <span class="toc-text">分支结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.3.</span> <span class="toc-text">循环结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.4.4.</span> <span class="toc-text">子程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.4.5.</span> <span class="toc-text">设计实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%BD%9C%E4%B8%9A"><span class="toc-number">5.5.</span> <span class="toc-text">汇编作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E5%92%8C%E5%AD%98%E5%82%A8"><span class="toc-number">6.</span> <span class="toc-text">总线和存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E5%88%86%E7%B1%BB-1"><span class="toc-number">6.1.</span> <span class="toc-text">总线分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.</span> <span class="toc-text">总线结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-number">6.3.</span> <span class="toc-text">总线基本功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">6.4.</span> <span class="toc-text">存储器分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E4%BD%9C%E4%B8%9A"><span class="toc-number">6.5.</span> <span class="toc-text">总线作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#io"><span class="toc-number">7.</span> <span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%8E%A5%E5%8F%A3%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.</span> <span class="toc-text">IO接口要解决的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%8E%A5%E5%8F%A3%E5%8A%9F%E8%83%BD"><span class="toc-number">7.2.</span> <span class="toc-text">IO接口功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%8E%A5%E5%8F%A3%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">7.3.</span> <span class="toc-text">IO接口编址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E7%BC%96%E5%9D%80"><span class="toc-number">7.3.1.</span> <span class="toc-text">统一编址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E7%BC%96%E5%9D%80"><span class="toc-number">7.3.2.</span> <span class="toc-text">独立编址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E5%A4%96%E8%AE%BE%E4%BF%A1%E6%81%AF"><span class="toc-number">7.4.</span> <span class="toc-text">接收外设信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-number">7.4.1.</span> <span class="toc-text">查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">7.4.2.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dma"><span class="toc-number">7.4.3.</span> <span class="toc-text">DMA</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%8A%AF%E7%89%87"><span class="toc-number">8.</span> <span class="toc-text">8253计时器&#x2F;定时器芯片</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6"><span class="toc-number">8.1.</span> <span class="toc-text">如何实现定时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%86%B5"><span class="toc-number">8.2.</span> <span class="toc-text">8253概况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%BA%BF%E5%9B%BE"><span class="toc-number">8.3.</span> <span class="toc-text">8253引线图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E8%87%B3%E7%B3%BB%E7%BB%9F%E7%AB%AF%E7%9A%84%E4%B8%BB%E8%A6%81%E5%BC%95%E7%BA%BF"><span class="toc-number">8.3.1.</span> <span class="toc-text">连接至系统端的主要引线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E9%80%9A%E9%81%93%E7%9A%84%E4%B8%BB%E8%A6%81%E5%BC%95%E7%BA%BF"><span class="toc-number">8.3.2.</span> <span class="toc-text">计数通道的主要引线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">8.4.</span> <span class="toc-text">8253内部结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E8%AE%A1%E6%95%B0%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">8.5.</span> <span class="toc-text">8253定时&#x2F;计数工作过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">8.5.1.</span> <span class="toc-text">工作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E5%86%85%E9%83%A8"><span class="toc-number">8.5.2.</span> <span class="toc-text">通道内部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%80%BC%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">8.5.3.</span> <span class="toc-text">计数值的设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">8.6.</span> <span class="toc-text">计数启动方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">8.7.</span> <span class="toc-text">8253工作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F0%E8%AE%A1%E6%95%B0%E7%BB%93%E6%9D%9F%E4%B8%AD%E6%96%AD"><span class="toc-number">8.7.1.</span> <span class="toc-text">方式0——计数结束中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%A7%A6%E5%8F%91%E7%9A%84%E5%8D%95%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">8.7.2.</span> <span class="toc-text">方式1——可重复触发的单稳态触发器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F2%E9%A2%91%E7%8E%87%E5%8F%91%E7%94%9F%E5%99%A8"><span class="toc-number">8.7.3.</span> <span class="toc-text">方式2——频率发生器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F3%E6%96%B9%E6%B3%A2%E5%8F%91%E7%94%9F%E5%99%A8"><span class="toc-number">8.7.4.</span> <span class="toc-text">方式3——方波发生器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F4%E8%BD%AF%E4%BB%B6%E8%A7%A6%E5%8F%91%E9%80%89%E9%80%9A"><span class="toc-number">8.7.5.</span> <span class="toc-text">方式4——软件触发选通</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F5%E7%A1%AC%E4%BB%B6%E8%A7%A6%E5%8F%91%E9%80%89%E9%80%9A"><span class="toc-number">8.7.6.</span> <span class="toc-text">方式5——硬件触发选通</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-number">8.7.7.</span> <span class="toc-text">各种工作方式总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F0%E8%AE%A1%E6%95%B0%E7%BB%93%E6%9D%9F%E4%B8%AD%E6%96%AD-1"><span class="toc-number">8.7.7.1.</span> <span class="toc-text">方式0（计数结束中断）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1%E5%8D%95%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">8.7.7.2.</span> <span class="toc-text">方式1（单稳态触发器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F2%E9%A2%91%E7%8E%87%E5%8F%91%E7%94%9F%E5%99%A8-1"><span class="toc-number">8.7.7.3.</span> <span class="toc-text">方式2（频率发生器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F3%E6%96%B9%E6%B3%A2%E5%8F%91%E7%94%9F%E5%99%A8-1"><span class="toc-number">8.7.7.4.</span> <span class="toc-text">方式3（方波发生器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F4%E8%BD%AF%E4%BB%B6%E8%A7%A6%E5%8F%91%E9%80%89%E9%80%9A-1"><span class="toc-number">8.7.7.5.</span> <span class="toc-text">方式4（软件触发选通）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F5%E7%A1%AC%E4%BB%B6%E8%A7%A6%E5%8F%91%E9%80%89%E9%80%9A-1"><span class="toc-number">8.7.7.6.</span> <span class="toc-text">方式5（硬件触发选通）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gate%E4%BF%A1%E5%8F%B7%E5%8A%9F%E8%83%BD%E8%A1%A8"><span class="toc-number">8.7.8.</span> <span class="toc-text">GATE信号功能表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AD%97"><span class="toc-number">8.8.</span> <span class="toc-text">8253控制字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AD%97%E6%A0%BC%E5%BC%8F"><span class="toc-number">8.8.1.</span> <span class="toc-text">控制字格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">8.9.</span> <span class="toc-text">8253初始化顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%9B%BE"><span class="toc-number">8.10.</span> <span class="toc-text">8253与系统的连接图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%BB%E5%87%BA%E5%BD%93%E5%89%8D%E8%AE%A1%E6%95%B0%E5%80%BC"><span class="toc-number">8.11.</span> <span class="toc-text">如何读出当前计数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%AE%9A%E6%97%B6%E8%AE%A1%E6%95%B0%E8%8C%83%E5%9B%B4"><span class="toc-number">8.12.</span> <span class="toc-text">扩展定时&#x2F;计数范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-number">8.13.</span> <span class="toc-text">8253应用举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A-1"><span class="toc-number">8.14.</span> <span class="toc-text">8253作业</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#section"><span class="toc-number">8.14.1.</span> <span class="toc-text">1.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#section-1"><span class="toc-number">8.14.2.</span> <span class="toc-text">2.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%8F%AF%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E8%8A%AF%E7%89%87"><span class="toc-number">9.</span> <span class="toc-text">8255并行可编程接口芯片</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%86%B5-1"><span class="toc-number">9.1.</span> <span class="toc-text">8255概况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%BA%BF%E5%9B%BE-1"><span class="toc-number">9.2.</span> <span class="toc-text">8255引线图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E8%87%B3%E7%B3%BB%E7%BB%9F%E7%AB%AF%E7%9A%84%E4%B8%BB%E8%A6%81%E5%BC%95%E7%BA%BF-1"><span class="toc-number">9.2.1.</span> <span class="toc-text">连接至系统端的主要引线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%A4%96%E8%AE%BE%E7%AB%AF%E7%9A%84%E5%BC%95%E8%84%9A"><span class="toc-number">9.2.2.</span> <span class="toc-text">连接外设端的引脚</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-1"><span class="toc-number">9.3.</span> <span class="toc-text">8255内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E5%8F%A3%E5%8F%AF%E4%BD%9C%E4%B8%BAab%E4%B8%A4%E7%AB%AF%E5%8F%A3%E7%9A%84%E4%BF%A1%E5%8F%B7%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">9.3.1.</span> <span class="toc-text">C口可作为AB两端口的信号输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ab%E7%AB%AF%E5%8F%A3%E6%8E%A7%E5%88%B6"><span class="toc-number">9.3.2.</span> <span class="toc-text">AB端口控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF%E7%BC%93%E5%86%B2%E5%99%A8"><span class="toc-number">9.3.3.</span> <span class="toc-text">数据总线缓冲器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%9B%BE-1"><span class="toc-number">9.4.</span> <span class="toc-text">8255与系统的连接图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F-1"><span class="toc-number">9.5.</span> <span class="toc-text">8255工作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F0%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">9.5.1.</span> <span class="toc-text">方式0：基本输入&#x2F;输出方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F0%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">9.5.1.1.</span> <span class="toc-text">方式0的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1%E9%80%89%E9%80%9A%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">9.5.2.</span> <span class="toc-text">方式1：选通输入&#x2F;输出方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E9%80%9A%E8%BE%93%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">9.5.2.1.</span> <span class="toc-text">选通输入方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%8A%9F%E8%83%BD"><span class="toc-number">9.5.2.1.1.</span> <span class="toc-text">信号功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B"><span class="toc-number">9.5.2.1.2.</span> <span class="toc-text">发送数据过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%A1%E6%89%8B%E4%BF%A1%E5%8F%B7"><span class="toc-number">9.5.2.1.3.</span> <span class="toc-text">握手信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A4%E6%97%B6%E7%9A%84%E7%8A%B6%E6%80%81%E5%AD%97"><span class="toc-number">9.5.2.1.4.</span> <span class="toc-text">此时的状态字</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E9%80%9A%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">9.5.2.2.</span> <span class="toc-text">选通输出方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%8A%9F%E8%83%BD-1"><span class="toc-number">9.5.2.2.1.</span> <span class="toc-text">信号功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B-1"><span class="toc-number">9.5.2.2.2.</span> <span class="toc-text">发送数据过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%A1%E6%89%8B%E4%BF%A1%E5%8F%B7-1"><span class="toc-number">9.5.2.2.3.</span> <span class="toc-text">握手信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A4%E6%97%B6%E7%8A%B6%E6%80%81%E5%AD%97"><span class="toc-number">9.5.2.2.4.</span> <span class="toc-text">此时状态字</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">9.5.2.3.</span> <span class="toc-text">方式1的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F2%E5%8F%8C%E5%90%91%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F%E4%BB%85a%E5%8F%A3"><span class="toc-number">9.5.3.</span> <span class="toc-text">方式2：双向传输方式（仅A口）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AD%97-1"><span class="toc-number">9.6.</span> <span class="toc-text">8255控制字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AD%97%E6%A0%BC%E5%BC%8F-1"><span class="toc-number">9.6.1.</span> <span class="toc-text">控制字格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E6%8E%A7%E5%88%B6%E5%AD%97"><span class="toc-number">9.6.2.</span> <span class="toc-text">方式控制字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E5%8F%A3%E7%BD%AE%E4%BD%8D%E5%A4%8D%E4%BD%8D%E6%8E%A7%E5%88%B6%E5%AD%97"><span class="toc-number">9.6.3.</span> <span class="toc-text">C口置位&#x2F;复位控制字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%85%A5%E7%8A%B6%E6%80%81%E5%AD%97"><span class="toc-number">9.6.4.</span> <span class="toc-text">读入状态字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A-2"><span class="toc-number">9.7.</span> <span class="toc-text">8255作业</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#section-2"><span class="toc-number">9.7.1.</span> <span class="toc-text">1.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#section-3"><span class="toc-number">9.7.2.</span> <span class="toc-text">2.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD-1"><span class="toc-number">10.</span> <span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">10.1.</span> <span class="toc-text">中断的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%BA%90"><span class="toc-number">10.2.</span> <span class="toc-text">中断源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD"><span class="toc-number">10.2.1.</span> <span class="toc-text">外部中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E4%B8%AD%E6%96%AD"><span class="toc-number">10.2.2.</span> <span class="toc-text">内部中断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">10.3.</span> <span class="toc-text">引入中断的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BA%94%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="toc-number">10.4.</span> <span class="toc-text">中断五个步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82"><span class="toc-number">10.4.1.</span> <span class="toc-text">中断请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%88%A4%E4%BC%98"><span class="toc-number">10.4.2.</span> <span class="toc-text">中断判优</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">10.4.2.1.</span> <span class="toc-text">中断优先级控制方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%88%A4%E4%BC%98"><span class="toc-number">10.4.2.1.1.</span> <span class="toc-text">硬件判优</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%88%A4%E4%BC%98"><span class="toc-number">10.4.2.1.2.</span> <span class="toc-text">软件判优</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94"><span class="toc-number">10.4.3.</span> <span class="toc-text">中断响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1"><span class="toc-number">10.4.4.</span> <span class="toc-text">中断服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E8%BF%94%E5%9B%9E"><span class="toc-number">10.4.5.</span> <span class="toc-text">中断返回</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8ivt"><span class="toc-number">10.5.</span> <span class="toc-text">中断向量表（IVT）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">10.5.1.</span> <span class="toc-text">中断向量表初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B"><span class="toc-number">10.6.</span> <span class="toc-text">8086中断响应过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">10.6.1.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%84%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">10.7.</span> <span class="toc-text">8086系统各中断优先级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#a%E5%8F%AF%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">11.</span> <span class="toc-text">8259A可编程中断控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#a%E5%BC%95%E8%84%9A"><span class="toc-number">11.1.</span> <span class="toc-text">8259A引脚</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">11.2.</span> <span class="toc-text">8259A内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E5%AF%84%E5%AD%98%E5%99%A8irr"><span class="toc-number">11.2.1.</span> <span class="toc-text">中断请求寄存器IRR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%AF%84%E5%AD%98%E5%99%A8isr"><span class="toc-number">11.2.2.</span> <span class="toc-text">中断服务寄存器ISR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E5%AF%84%E5%AD%98%E5%99%A8imr"><span class="toc-number">11.2.3.</span> <span class="toc-text">中断屏蔽寄存器IMR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E6%9D%83%E5%88%A4%E5%88%AB%E7%94%B5%E8%B7%AF"><span class="toc-number">11.2.4.</span> <span class="toc-text">中断优先权判别电路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">11.3.</span> <span class="toc-text">8259A工作过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">11.4.</span> <span class="toc-text">8259A工作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E6%96%B9%E5%BC%8F"><span class="toc-number">11.4.1.</span> <span class="toc-text">中断优先方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">11.4.1.1.</span> <span class="toc-text">固定优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">11.4.1.2.</span> <span class="toc-text">循环优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%B5%8C%E5%A5%97%E6%96%B9%E5%BC%8F"><span class="toc-number">11.4.2.</span> <span class="toc-text">中断嵌套方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9D%9F%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">11.4.3.</span> <span class="toc-text">中断结束处理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD%E6%BA%90%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">11.4.4.</span> <span class="toc-text">屏蔽中断源的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="toc-number">11.4.5.</span> <span class="toc-text">中断触发方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A7%E8%81%94%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">11.4.6.</span> <span class="toc-text">级联工作方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a%E7%9A%84%E7%BC%96%E7%A8%8B%E4%BD%BF%E7%94%A8"><span class="toc-number">11.5.</span> <span class="toc-text">8259A的编程使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99icw"><span class="toc-number">11.5.1.</span> <span class="toc-text">写ICW</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">11.5.1.1.</span> <span class="toc-text">8259A初始化顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#icw1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%97"><span class="toc-number">11.5.1.2.</span> <span class="toc-text">ICW1——初始化字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#icw2%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E7%A0%81"><span class="toc-number">11.5.1.3.</span> <span class="toc-text">ICW2——中断向量码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#icw3%E7%BA%A7%E8%81%94%E6%8E%A7%E5%88%B6%E5%AD%97%E8%BF%9E%E5%9C%A8%E5%93%AA"><span class="toc-number">11.5.1.4.</span> <span class="toc-text">ICW3——级联控制字（连在哪）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#icw4%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9D%9F%E6%96%B9%E5%BC%8F%E5%AD%97"><span class="toc-number">11.5.1.5.</span> <span class="toc-text">ICW4——中断结束方式字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99ocw"><span class="toc-number">11.5.2.</span> <span class="toc-text">写OCW</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ocw1%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E5%AD%97"><span class="toc-number">11.5.2.1.</span> <span class="toc-text">OCW1——中断屏蔽字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ocw2%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9D%9F%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E5%BE%AA%E7%8E%AF"><span class="toc-number">11.5.2.2.</span> <span class="toc-text">OCW2——中断结束和优先级循环</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E4%BC%98%E5%85%88%E7%BA%A7-1"><span class="toc-number">11.5.2.2.1.</span> <span class="toc-text">固定优先级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%85%88%E7%BA%A7-1"><span class="toc-number">11.5.2.2.2.</span> <span class="toc-text">循环优先级</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ocw3%E5%B1%8F%E8%94%BD%E6%96%B9%E5%BC%8F%E5%92%8C%E8%AF%BB%E5%87%BA%E6%8E%A7%E5%88%B6%E5%AD%97"><span class="toc-number">11.5.2.3.</span> <span class="toc-text">OCW3——屏蔽方式和读出控制字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a%E7%BC%96%E7%A8%8B%E4%B8%BE%E4%BE%8B"><span class="toc-number">11.6.</span> <span class="toc-text">8259A编程举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">11.7.</span> <span class="toc-text">中断程序设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A-3"><span class="toc-number">11.8.</span> <span class="toc-text">8259作业</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#section-4"><span class="toc-number">11.8.1.</span> <span class="toc-text">1.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#section-5"><span class="toc-number">11.8.2.</span> <span class="toc-text">2.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#section-6"><span class="toc-number">11.8.3.</span> <span class="toc-text">3.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#section-7"><span class="toc-number">11.8.4.</span> <span class="toc-text">4.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">12.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/25/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/The-Missing-Semester-of-My-CS-Education%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="The Missing Semester of My CS Education学习记录">The Missing Semester of My CS Education学习记录</a><time datetime="2024-05-25T08:10:00.000Z" title="发表于 2024-05-25 16:10:00">2024-05-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/24/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Raycasting%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E8%BF%9B%E9%98%B6%E4%B8%8E%E6%89%A9%E5%B1%95/" title="Raycasting学习记录_进阶与扩展">Raycasting学习记录_进阶与扩展</a><time datetime="2024-05-24T07:00:00.000Z" title="发表于 2024-05-24 15:00:00">2024-05-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/14/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/GAMES101%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="GAMES101学习记录">GAMES101学习记录</a><time datetime="2024-05-14T07:22:42.000Z" title="发表于 2024-05-14 15:22:42">2024-05-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/06/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/LeetCode%E8%AE%AD%E7%BB%83%E8%AE%B0%E5%BD%95/" title="LeetCode训练记录">LeetCode训练记录</a><time datetime="2024-05-06T13:31:21.000Z" title="发表于 2024-05-06 21:31:21">2024-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/13/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2024%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83/" title="2024蓝桥杯训练">2024蓝桥杯训练</a><time datetime="2024-03-13T02:07:17.000Z" title="发表于 2024-03-13 10:07:17">2024-03-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By WinkySpeed</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2d-widget/autoload.js"></script></body></html>