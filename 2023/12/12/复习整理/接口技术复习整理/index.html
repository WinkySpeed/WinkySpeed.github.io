<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>接口技术复习整理 | WinkySpeed's Blog</title><meta name="author" content="WinkySpeed"><meta name="copyright" content="WinkySpeed"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="接口技术复习整理 引言 本课程主要用于计算机控制 计算机控制的实质是不同信号的不同处理过程，一般经过“数据采集过程”和“过程控制”2个阶段  计算机在工业生产过程的闭环控制  总线分类 地址总线AB：用来传送CPU输出的地址信号，确定被访问的存储单元、I&#x2F;O端口。地址线的根数决定了CPU的寻址范围 CPU的寻址范围 &#x3D; \(2^n\)， n：地址线根数 数据总线DB：在CPU">
<meta property="og:type" content="article">
<meta property="og:title" content="接口技术复习整理">
<meta property="og:url" content="http://example.com/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="WinkySpeed&#39;s Blog">
<meta property="og:description" content="接口技术复习整理 引言 本课程主要用于计算机控制 计算机控制的实质是不同信号的不同处理过程，一般经过“数据采集过程”和“过程控制”2个阶段  计算机在工业生产过程的闭环控制  总线分类 地址总线AB：用来传送CPU输出的地址信号，确定被访问的存储单元、I&#x2F;O端口。地址线的根数决定了CPU的寻址范围 CPU的寻址范围 &#x3D; \(2^n\)， n：地址线根数 数据总线DB：在CPU">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/WinkySpeed%20SP%20-%20Repaired.jpg">
<meta property="article:published_time" content="2023-12-12T02:56:09.000Z">
<meta property="article:modified_time" content="2023-12-19T03:39:02.665Z">
<meta property="article:author" content="WinkySpeed">
<meta property="article:tag" content="复习整理">
<meta property="article:tag" content="接口技术">
<meta property="article:tag" content="8086">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/WinkySpeed%20SP%20-%20Repaired.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '接口技术复习整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-19 11:39:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/WinkySpeed%20SP%20-%20Repaired.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/33703665_p0.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="WinkySpeed's Blog"><span class="site-name">WinkySpeed's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">接口技术复习整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-12T02:56:09.000Z" title="发表于 2023-12-12 10:56:09">2023-12-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-19T03:39:02.665Z" title="更新于 2023-12-19 11:39:02">2023-12-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="接口技术复习整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="接口技术复习整理">接口技术复习整理</h1>
<h1 id="引言">引言</h1>
<p>本课程主要用于计算机控制</p>
<p>计算机控制的实质是不同信号的不同处理过程，一般经过“<strong>数据采集过程</strong>”和“<strong>过程控制</strong>”2个阶段</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231213162326913.png" class title="image-20231213162326913">
<h2 id="计算机在工业生产过程的闭环控制">计算机在工业生产过程的闭环控制</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231213162408785.png" class title="image-20231213162408785">
<h2 id="总线分类">总线分类</h2>
<p>地址总线AB：用来传送CPU输出的地址信号，确定被访问的存储单元、I/O端口。地址线的根数决定了CPU的寻址范围</p>
<p>CPU的寻址范围 = <span class="math inline">\(2^n\)</span>，
n：地址线根数</p>
<p>数据总线DB：在CPU与存储器、I/O接口之间数据传送的公共通路。数据总线的条数决定CPU一次最多可以传送的数据宽度</p>
<p>控制总线CB：用来传送各种控制信号</p>
<h2 id="cpu">CPU</h2>
<p>计算机的运算中心和控制中心，提供运算、判断能力</p>
<p>构成：运算器ALU、控制器CU、寄存器组</p>
<h2 id="io接口">I/O接口</h2>
<p>输入/输出接口，简写为I/O接口，是CPU与外部设备间的桥梁，外设通过I/O接口与主机连接，与CPU实现信息传送</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231213162933839.png" class title="image-20231213162933839">
<h3 id="外设通过io接口与总线连接的原因">外设通过I/O接口与总线连接的原因</h3>
<p>CPU、内存能直接连接到总线，外设需要用I/O接口</p>
<p>一般的输入/输出设备都是机械的或机电相结合的产物，它们相对于高速的中央处理器来说，速度要<strong>慢</strong>得多</p>
<p>此外，不同外设的<strong>信号形式、数据格式</strong>也各不相同</p>
<p>因此，外部设备不能与CPU直接相连，需要通过相应的电路来完成它们之间的速度匹配、信号转换，并完成某些控制功能</p>
<h2 id="微机">微机</h2>
<h3 id="微机基本概念">微机基本概念</h3>
<p><strong>微处理器</strong>即CPU,是微型机的主要核心部件，微机和其它大、中、小型计算机的根本区别：微机的CPU由运算器和控制器<strong>集成</strong>而成</p>
<p><strong>微型计算机</strong>由微处理器、接口、I/O设备通过总线连接而成</p>
<p><strong>微型计算机系统</strong>由硬件和软件构成，硬件由微处理器、接口、I/O设备通过总线连接而成；软件由系统软件和应用软件构成。硬件是基础，软件是灵魂，计算机的功能只有在硬件基础上通过软件才能发挥</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231213163340357.png" class title="image-20231213163340357">
<h3 id="微机工作过程">微机工作过程</h3>
<p>①微机上运行高级语言程序，先须经过编译、链接生成机器语言可执行程序才能直接运行</p>
<p>②机器语言程序是按照算法运算顺序由许多机器指令按一定顺序组成的程序，即程序是由多条有逻辑关系的指令组成</p>
<p>③数据和程序均以二进制代码的形式不加区别地存放在存储器中，存放位置由二进制地址指定</p>
<p>④由控制器控制整个机器语言程序和数据的存取以及程序的执行。而指令执行由运算器完成</p>
<p><br></p>
<p>为实现自动连续地执行程序，控制器设置一<strong>程序计数器PC</strong>，它可根据指令的长度自动增量（总是指向下一条指令）</p>
<p>只要给出程序中第一条指令的地址，控制器就可依据存储程序中的指令顺序周而复始地取指令、译码、执行，直到完成全部指令操作为止，即控制器通过<strong>指令流的串行驱动</strong>实现程序控制</p>
<h3 id="微机分类">微机分类</h3>
<p>按照组装形式和系统规模，可以把微型计算机划分为单片机、单板机和个人计算机</p>
<p><strong>单片机</strong>：将CPU、部分存储器、部分I/O接口集成在一个<strong>芯片</strong>上</p>
<p><strong>单板机</strong>：将CPU、存储器、I/O接口及部分I/O设备安装在一个<strong>印刷线路板</strong>上</p>
<p><strong>个人计算机PC</strong>：在主板上连接CPU、存储器、I/O接口，再配置上外设而成</p>
<h3 id="微机组成">微机组成</h3>
<p>微机<strong>原理</strong>组成：运算器、控制器、存储器、输入设备、输出设备</p>
<p>微机<strong>物理结构（实际）</strong>组成：主机（主板、CPU、内存条、硬盘、软驱、光驱、显卡、声卡、网卡等）、外设（显示器、打印机、键盘、鼠标等）</p>
<p>微机<strong>概念</strong>组成：在总线上直接挂接上CPU、内存、I/O接口，外设通过I/O接口实现与计算机连接</p>
<h3 id="微机工作原理">微机工作原理</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231213201627715.png" class title="image-20231213201627715">
<p>运算器部件是计算机中进行数据加工的部件</p>
<p>ALU运算需２个操作数，分别来自ACC和X寄存器，运算结果保存到ACC及MQ寄存器</p>
<p><br></p>
<p>控制器完成一条指令的“取指、分析、执行”</p>
<p>控制器由控制单元CU、指令部件、时序部件、PC（Program
Counter）、IR等组成</p>
<p>指令部件由指令寄存器IR、程序计数器PC、指令译码器ID组成</p>
<p>PC存放当前欲执行指令的地址，具有计数功能</p>
<p>IR存放当前欲执行的指令</p>
<p><br></p>
<p>存储器完成程序、数据、地址码的存储，具有读出和写入两种操作</p>
<p>存储器由地址寄存器MAR、数据缓冲寄存器MDR和存储阵列组成</p>
<p>MAR存放CPU要访问的内存地址，CPU对内存单元的读写都要经过MDR传送</p>
<p><br></p>
<p>I/O系统由I/O接口和I/O设备组成</p>
<p>I/O设备完成程序、数据的I/O操作</p>
<p>I/O接口是I/O设备完成程序、数据I/O操作的中转站</p>
<p>CPU通过对I/O接口<strong>状态寄存器</strong>的读取，来了解外设的工作状态</p>
<p>I/O设备通过I/O接口接受CU发出的各种控制命令完成相应的I/O操作</p>
<h1 id="系统结构">8086系统结构</h1>
<p>在传统的CPU中，采用串行工作方式，总是先从存储器中取出下一条指令，读出一个操作数，然后执行指令，即：</p>
<p>取指→执指→取指→执指→取指→执指</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214210233323.png" class title="image-20231214210233323">
<p>CPU访问存储器(存取数据或指令)时要等待总线操作的完成</p>
<p>CPU执行指令时总线处于空闲状态</p>
<p>缺点：CPU无法全速运行</p>
<p>解决：总线空闲时预取指令，使CPU需要指令时能立刻得到</p>
<p><br></p>
<p>在8086中，这些步骤被分配给两个独立的处理单元执行：</p>
<p>指令执行部件（<strong>EU</strong>）负责执行指令</p>
<p>总线接口部件（<strong>BIU</strong>）负责取指、读出操作数和写入结果</p>
<p>这两个单元可以独立工作，大多数情况下取指令执行指令重叠进行</p>
<p>即取指过程中，指令执行部件也在工作，加快系统运算速率</p>
<p>这种方式是<strong>流水线工作方式</strong></p>
<p><br></p>
<p>EU在执行指令时不需要访存取指令，只需要从指令队列取指，并分析执行</p>
<p>如果指令执行中需要访存或I/O端口，则EU向BIU发送访存的<strong>逻辑</strong>地址，BIU根据要求形成访存<strong>物理</strong>地址，然后访问存储器或I/O端口，取得操作数后送到EU参加运算，必要时再将运算结果写会存储器</p>
<p>EU实际不与外界打交道，所有与外部有关的操作都在BIU控制下完成</p>
<h2 id="cpu结构">8086CPU结构</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214191858981.png" class title="image-20231214191858981">
<p>地址总线是20位</p>
<h3 id="cpu内部结构框图">8086CPU内部结构框图</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214191946410.png" class title="image-20231214191946410">
<h3 id="总线接口部件biubus-interfaceunit">总线接口部件BIU(Bus
InterfaceUnit)</h3>
<p>提供与外部的接口</p>
<p>数据总线 ：<strong>双向</strong>三态，16位</p>
<p>地址总线 ：<strong>单向</strong>三态，20位</p>
<h4 id="biu功能">BIU功能</h4>
<p>地址形成</p>
<p>访存并取指令</p>
<p>指令排队</p>
<p>读/写操作数</p>
<p>总线控制</p>
<h4 id="biu组成">BIU组成</h4>
<h5 id="段寄存器段基址寄存器">段寄存器（段基址寄存器）</h5>
<p>段寄存器都是16位</p>
<p>CS（Code Segment）：代码段寄存器，存放程序代码段起始地址的高16位</p>
<p>DS（Data Segment）：数据段寄存器，存放数据段起始地址的高16位</p>
<p>SS（Stack Segment）：堆栈段寄存器，存放堆栈段起始地址的高16位</p>
<p>ES（Extended
Segment）：扩展段寄存器，存放扩展数据段起始地址的高16位</p>
<h5 id="指令指针寄存器">指令指针寄存器</h5>
<p>IP（Instruction
Pointer）：指令指针寄存器，存指令在代码段中的偏移量，16位</p>
<h5 id="物理地址加法器">物理地址加法器</h5>
<p><span class="math display">\[
物理地址=段基址\times16+偏移地址
\]</span></p>
<p>乘16在二进制数的表现为左移4位</p>
<p>即相当于在16位的段基址最低位后添加4个0，再与偏移地址相加，得到20位的地址</p>
<p>例如：</p>
<p>CS=2000H，IP=003AH
则物理地址<code>CS : IP</code>就为<code>CS x 16 + IP</code>，即2003AH</p>
<p>注意：2000H，003AH，2003AH都为16进制，最后的结果2003AH换算为二进制就是5x4=20位，符合20位物理地址</p>
<p><br></p>
<p>关于<code>CS : IP</code>的解释：</p>
<p>在8086微处理器中，冒号（:）用于连接段寄存器和偏移寄存器，以形成一个完整的内存地址</p>
<p>冒号前面的部分（如CS，DS，SS，ES等）是段寄存器，它存放的是基地址</p>
<p>这个基地址需要乘以16（或者说，向左移动4位），以将它转换为20位的物理地址</p>
<p>然后，将冒号后面的部分（如IP，BX，SI，DI等）加到这个物理地址上，就得到了最终的物理地址</p>
<h5 id="指令队列">指令队列</h5>
<p>存放指令，算是缓冲的作用</p>
<p>空间为6个字节</p>
<p>但不代表只能存6条指令，因为有的指令可能不止1个字节</p>
<p>这些指令队列寄存器通过总线接口单元BIU将后继要执行的指令提前由内存提前调入其内，以加快指令读取速度</p>
<p>利用指令队列寄存器可以构成指令流水线，以提高CPU工作效率</p>
<h5 id="总线控制部件">总线控制部件</h5>
<p>主要功能是产生总线控制信号，如访问存储器或者I/O端口的读写信号等</p>
<p>总线控制逻辑部件负责对CPU全部外部引脚的操作，核心功能是控制系统总线</p>
<p>当执行单元（EU）需要与I/O设备、存储器进行数据交换时，总线控制逻辑部件会协助EU完成数据交换</p>
<h4 id="biu工作过程">BIU工作过程</h4>
<p>CS和IP形成20位地址，送地址总线、送出MEM读信号、取指令到指令队列待用（6字节）</p>
<p>当EU取走指令，则自动调整指针并补充读入，如队列满，则空闲</p>
<p>如指令中需访问MEM或IO，则BIU根据EU给出的逻辑地址形成20位物理地址，由BIU负责读/写</p>
<p>IP寄存器，如CALL指令，则把当前指令的下一条指令的IP入栈，并清队列，根据新地址取6个字节待用，JMP相类似</p>
<p>总线控制部件发出总线控制信号，完成MEM或IO的读写</p>
<h3 id="指令执行部件euexecution-unit">指令执行部件EU(Execution
Unit)</h3>
<p>提供通用寄存器阵列，都为16位</p>
<p>运算器，16位</p>
<h4 id="eu功能">EU功能</h4>
<p>译码</p>
<p>执行</p>
<h4 id="eu组成">EU组成</h4>
<h5 id="算术运算逻辑部件alu">算术运算逻辑部件ALU</h5>
<h5 id="标志寄存器frflag-register">标志寄存器FR（Flag Register）</h5>
<p>标志寄存器16位</p>
<p>标志寄存器里存的信息被称为程序状态字（Program Status Word，PSW）</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214222135576.png" class title="image-20231214222135576">
<p>9个标志位</p>
<h6 id="状态标志">状态标志</h6>
<p>CF（Carry Flag）：进位标志位</p>
<p>CF=1，则本次运算最高位（<span class="math inline">\(D_{15}\)</span>或<span class="math inline">\(D_{7}\)</span>）有进位（加法运算时）或有借位（减法运算时）</p>
<p><br></p>
<p>PF（Parity Flag）：奇偶校验标志位</p>
<p>PF=1，表示本次运算结果中有偶数个“1”；PF=0表示本次运算结果中有奇数个“1”</p>
<p><br></p>
<p>AF（Auxiliary Carry Flag）：辅助进位标志位</p>
<p>AF=1，表示运算结果的8位数据中，低4位向高4位有进位（加法运算时）或有借位（减法运算时）</p>
<p>这个标志位<strong>仅在十进制数即BCD码运算</strong>中有效</p>
<p><br></p>
<p>ZF（Zero Flag）：零标志位</p>
<p>ZF=1，表示本次运算结果为0，ZF=0，运算结果非0</p>
<p><br></p>
<p>SF（Sign Flag）：符号标志位</p>
<p>SF=1，表示本次运算结果的最高位（<span class="math inline">\(D_{15}\)</span>或<span class="math inline">\(D_{7}\)</span>）为“1”，即符号数运算结果为负，否则SF=0</p>
<p><br></p>
<p>OF（Overflow Flag）：溢出标志位</p>
<p>OF=1，表示本次算术运算结果溢出</p>
<p>溢出：字节运算的结果超出了-128 ~ 127；或者字运算超出了-32768 ~
32767</p>
<p>二进制表示：</p>
<p>字节运算的范围：10000000 ~ 01111111（8位）</p>
<p>字运算的范围：1000000000000000 ~ 0111111111111111（16位）</p>
<p><br></p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231215161907482.png" class title="image-20231215161907482">
<p>例子：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231215162403301.png" class title="image-20231215162403301">
<p>可见，超过范围OF置1，最高位为1时SF置1，产生进位CF置1</p>
<h6 id="控制标志">控制标志</h6>
<p>IF（Interrupt Flag）：中断标志位</p>
<p>IF=1，表示允许CPU响应可屏蔽中断</p>
<p>IF=0，表示CPU禁止中断</p>
<p><br></p>
<p>DF（Direction Flag）：方向标志位</p>
<p>串操作指令中，DF=0表示串操作指令地址指针自动增量，即串操作的地址由低地址向高地址进行</p>
<p>DF=1表示地址指针自动减量，即串操作的地址由高地址向低地址进行</p>
<p>"串操作"是一种特殊的操作，它可以对在内存中连续存在的数据进行操作。这些操作通常是组合操作，能完成几条指令的功能</p>
<p><br></p>
<p>TF（Trap Flag）：单步标志位</p>
<p>TF=1，表示控制CPU进入单步工作方式，这种工作方式，CPU每执行完一条指令就自动产生一次内部中断，在调试程序很有用</p>
<h5 id="通用寄存器">通用寄存器</h5>
<p>通用寄存器都是16位</p>
<p>分为两组：数据寄存器和指针变址寄存器</p>
<h6 id="数据寄存器">数据寄存器</h6>
<p>通用数据寄存器既可作为16位寄存器，也可作为8位寄存器，即把16位的寄存器分成高8位和低8位</p>
<p>低8位被命名为AL, BL, CL, DL</p>
<p>高8位被命名为AH, BH ,CH, DH</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214204202684.png" class title="image-20231214204202684">
<p><br></p>
<p>AX（Accumulator
Register）：累加器，用于存放参加运算的数据和结果，在乘、除法运算、I/O操作、BCD数运算中有着不可代替的作用</p>
<p>AX的特殊用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL		BL</span><br></pre></td></tr></table></figure>
<p>8位乘法指令，功能为寄存器<code>AL x BL</code></p>
<p>其中，一个乘数一定放在AL中，另一个乘数可以放在BL中，也可以放在BH,
CL等8位寄存器中，最后的乘积一定放在AX中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL		BX</span><br></pre></td></tr></table></figure>
<p>16位乘法指令，功能为寄存器<code>AX x BX</code></p>
<p>其中，一个乘数一定放在AX中，另一个乘数可以放在BX中，也可以放在CX,
DX等16位寄存器中，乘积一定放在DXAX中，其中DX保存高16位</p>
<p><br></p>
<p>BX（Base
Register）：基址寄存器，除了作为数据寄存器，还可存放<strong>内存的逻辑偏移地址</strong>，<strong>AX,
CX,
DX不能</strong>，即<code>[BX]</code>这个用法是合法的，但是不能用<code>[AX], [CX], [DX]</code>这样的写法</p>
<p>BX的特殊用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV		AL,	[BX]</span><br></pre></td></tr></table></figure>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214211131144.png" class title="image-20231214211131144">
<blockquote>
<p>在汇编语言中，<code>[BX]</code>表示的是一个内存地址，这个地址的偏移量存储在BX寄存器中。例如，如果BX中存放的数是40F6H，那么<code>[BX]</code>就表示的是以40F6H为地址的内存单元。</p>
<p>当我们在指令中使用<code>[BX]</code>时，我们实际上是在引用BX寄存器中存储的地址指向的内存单元的内容。例如，指令<code>MOV AX, [BX]</code>的功能是将BX中存放的数据作为一个偏移地址，段地址默认在DS中，将DS:BX处的数据送入AX中。</p>
<p>这段汇编代码<code>MOV AL, [BX]</code>的含义是将内存中的数据（以BX内容为地址）传送到AL寄存器里。也就是说，执行这条指令后，AL寄存器的内容会变得与内存
<code>[BX]</code>的内容一样。</p>
</blockquote>
<p><br></p>
<p>CX（Counter
Register）：数据寄存器，既可作为数据寄存器，又可在串指令和位移指令中计数用</p>
<p>比如C语言中的<code>for(int i=100; i &gt; 0; i--)</code>，每次循环<code>i</code>都会自减，执行100次后循环结束，在8086中称为“串操作”</p>
<p>CX的特殊用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV CX, 5    ; 设置循环次数为5</span><br><span class="line">MOV AX, 2    ; 初始化AX寄存器的值为2</span><br><span class="line"></span><br><span class="line">START_LOOP:</span><br><span class="line">    ADD AX, AX    ; 将AX寄存器的值加倍</span><br><span class="line">    LOOP START_LOOP    ; 如果CX不为0，减少CX的值并跳转到START_LOOP，否则继续执行下一条指令</span><br></pre></td></tr></table></figure>
<p><code>LOOP</code>指令对CX做减1操作，并将结果返回到CX中，再判断CX的内容，若CX不为0，则回到标号处重新执行，直到CX为0为止，执行后面的语句，相当于C语言循环控制变量<code>i--</code>到<code>0</code></p>
<p>关于汇编语言中循环控制的方法：</p>
<blockquote>
<p>在汇编语言中，循环的实现方式与C语言有所不同。在C语言中，我们可以使用各种循环结构（如for，while，do
while等）并且可以自由地增加或减少循环计数器。但在汇编语言中，循环通常是通过特定的循环指令和一个循环计数器（通常是CX或ECX寄存器）来实现的。</p>
<p>例如，汇编语言中的<code>LOOP</code>指令会自动将CX寄存器的值减1，然后检查CX是否为零。如果CX不为零，程序就会跳转到指定的位置继续执行；如果CX为零，<code>LOOP</code>指令就会结束，程序会继续执行<code>LOOP</code>指令后面的代码。因此，这种循环的行为类似于C语言中的<code>i--</code>。</p>
<p>但是，汇编语言还提供了其他的循环控制指令，如<code>LOOPE/LOOPZ</code>和<code>LOOPNE/LOOPNZ</code>，这些指令除了检查CX或ECX是否为零外，还会检查零标志（ZF）。这就为汇编语言的循环提供了更多的灵活性。</p>
<p>总的来说，虽然汇编语言的循环控制方式与C语言有所不同，但它们都提供了强大的循环控制能力。</p>
</blockquote>
<p><br></p>
<p>DX （Data
Register）：数据寄存器，除了可以作为通用数据寄存器，还在乘除法、带符号数扩展指令中有特殊作用</p>
<p>DX的特殊用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN		AL		DX</span><br></pre></td></tr></table></figure>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231214215836066.png" class title="image-20231214215836066">
<p>DX存的内容可以作为端口的I/O地址，如图所示，若DX存的内容为0080H，则上述指令就是从编号为0080H的I/O端口输入一个8为数据给AL，这是常见的I/O操作，用于从外部设备读取数据</p>
<p>DX内容为<strong>I/O端口地址</strong>的功能是别的寄存器所不具备的</p>
<p><br></p>
<h6 id="指针变址寄存器">指针变址寄存器</h6>
<p>数据寄存器AX, BX, CX,
DX中，只有BX可以作为地址指针，考虑到实际编程中需要大量的地址指针，只有BX指示或寻址数组中的元素是不够的，于是8086引入了指针和变址寄存器，由SI,
DI, SP, BP组成，特殊功能是存放存储器地址</p>
<p><br></p>
<p>SI（Source
Index）：源变址寄存器，用于存放内存的逻辑偏移地址，也可存放数据</p>
<p>DI（Destination
Index）：目标变址寄存器，用于存放内存的逻辑偏移地址，也可存放数据</p>
<p>SP（Stack Pointer）：堆栈指针，用于存放栈顶的逻辑偏移地址</p>
<p>BP（Base Pointer）：基址指针，用于存放内存的逻辑偏移地址</p>
<p><br></p>
<p>SI, DI, BP与BX的功能差不多，但SP有明显差异，主要用于指示堆栈栈顶</p>
<h5 id="eu控制器">EU控制器</h5>
<p>取指控制及时序控制</p>
<h4 id="eu的工作过程">EU的工作过程</h4>
<p>发出控制信号，从指令队列中取出指令译码，完成执行</p>
<p>算术逻辑部件ALU完成算术运算和逻辑运算，改写PSWW</p>
<p>BIU和EU可以并行工作，即流水线技术，但仅当CALL、RET及JMP等指令时，要<strong>改变执行顺序</strong>时，不能并行工作</p>
<h2 id="cpu引脚">8086CPU引脚</h2>
<p>8086CPU可以工作在最小模式和最大模式下</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231215171505623.png" class title="image-20231215171505623">
<p>由于受到当时制造工艺的限制，部分引脚采用分时复用</p>
<p>这里仅写我认为重要的，不看懂就无法理解8086工作原理的几个引脚，剩下的应该不是很重要，查手册就可以</p>
<p><br></p>
<p>AD15 - AD0（Address Data
Bus）：<strong>分时复用</strong>的地址、数据总线</p>
<p><br></p>
<p>A19/S6，A18/S5，A17/S4，A16/S3（Address/Status）：<strong>分时复用</strong>的地址、状态线</p>
<p>作为地址线用时，A19 - A16与AD15 - AD0一起构成了访存的20位地址线</p>
<p>CPU访问I/O端口时，A19 - A16保持低电平“0”</p>
<p>作为状态线用时，S6 -
S3用来输出状态信息，其中S3和S4表示当前正在使用的段寄存器名</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231215170527993.png" class title="image-20231215170527993">
<p>例如S4S3 =
10时，表示当前使用CS寄存器对存储器寻址，或当前正在对I/O端口或中断向量寻址</p>
<p>S5用来表示中断标志状态，与IF状态一致，即S5=0时禁止一切可屏蔽中断，S5=1时允许可屏蔽中断请求</p>
<p>8086工作在最小模式下时，S6恒为0</p>
<p><br></p>
<p>~BHE/S7（Bus High
Enable/Status）：总线高位有效信号（三态输出，低电平有效），表示当前高8位数据总线上的数据有效</p>
<p>低8位数据总线选通信号为AD0（偶地址）</p>
<p>~BHE/S7可以用来控制高八位的存存储器或I/O接口芯片，以区分和控制存取的是一个字节还是一个字</p>
<p>例如，在偶数地址开始的一个字节存取时，<sub>BHE/S7为0，AD0为1（此时高8位数据总线上进行字节传送）；在奇数地址开始的一个字节存取时，</sub>BHE/S7为1，AD0为0（此时低8位数据总线上进行字节传送）</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217162843395.png" class title="image-20231217162843395">
<h2 id="与8088不同之处">8086与8088不同之处</h2>
<table>
<thead>
<tr class="header">
<th></th>
<th>8086</th>
<th>8088</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>外部数据总线</td>
<td>16位</td>
<td>8位</td>
</tr>
<tr class="even">
<td>指令队列</td>
<td>6字节</td>
<td>4字节</td>
</tr>
<tr class="odd">
<td>Memory和IO空间选择</td>
<td>M/IO</td>
<td>IO/M</td>
</tr>
</tbody>
</table>
<h2 id="存储器组织">8086存储器组织</h2>
<p>8086CPU的存储器是一个最多寻址1MB的存储空间，系统为每字节分配一个20位的物理地址（对应十六进制地址范围为00000H~FFFFFH）</p>
<p>存储器中，任何两个相邻的字节被定义为一个“字”</p>
<p>在一个字中，每字节都有一个地址，这两个地址中<strong>较小的一个</strong>被用来作为这个字的地址</p>
<h3 id="线性编址">线性编址</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217155444075.png" class title="image-20231217155444075">
<p>微型计算机的内存储器以<strong>字节</strong>为基本单位存储信息，每个字节占用一个存储单元，每个存储单元给定一个唯一的地址，这个地址称为物理地址，物理地址以二进制无符号整数形式从0开始编号，顺序增1</p>
<h3 id="数据存储">数据存储</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217160333677.png" class title="image-20231217160333677">
<p>一个字的起始地址可以从偶地址开始，如图里的6B07H</p>
<p>一个字的起始地址也可以从奇地址开始，如图里的3E60H</p>
<p><strong>较高地址</strong>的字节存的是该字的<strong>高8位</strong></p>
<p><strong>较低地址</strong>的字节存的是该字的<strong>低8位</strong></p>
<p>如00001H存的是6B07H的6B，00000H存的是07；00006H存的是3E60H的3E，00005H存的是60</p>
<p><br></p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217160608122.png" class title="image-20231217160608122">
<p>偶地址开始存储的是“规则字”</p>
<p>奇地址开始存储的是“非规则字”</p>
<p>对于这两种字的解释在“<a href="#explanation of two words">8086存储器组织-分体结构</a>”中有详细解释</p>
<p><br></p>
<p><strong>总结</strong>：</p>
<p>存储器中<strong>以字节为单位</strong>存储信息</p>
<p>每个存储单元有唯一的物理地址</p>
<p>存放顺序：低字节存放在低地址；高字节存放在高地址</p>
<h3 id="分段技术">分段技术</h3>
<h4 id="存储空间的分段">存储空间的分段</h4>
<p>8086系统把1MB的内存空间（地址线是20根，寻址空间为<span class="math inline">\(2^{20}=1MB\)</span>）分为若干个段，要求：</p>
<p>①每段的容量<strong>不超过64KB</strong>（寄存器只有16根数据线，可寻址<span class="math inline">\(2^{16}=64KB\)</span>）</p>
<p>②段内起始地址必须能被16整除</p>
<p>各段的功能因具体用途而定，可分为代码段、数据段、堆栈段、附加段（对应BIU内的CS,
DS, SS, ES段寄存器）</p>
<p>段内起始单元地址的高16位（<strong>低4位为0</strong>）称为段基址，段内某单元距首单元的位移量称为偏移地址/有效地址</p>
<p>例子：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217161201592.png" class title="image-20231217161201592">
<p>1234H作为段基址，则段内起始单元地址为“12340H”，多出来的低4位0可以保证段内起始单元地址能被16整除：
<span class="math display">\[
12340H = 0\times16^0+4\times16^1+3\times16^2+2\times16^3+1\times16^4
\]</span> 分段技术可以使每个存储单元都可以用两种地址表示：</p>
<p><strong>物理地址</strong>是内存中信息存储的实际地址</p>
<p><strong>逻辑地址</strong>（段基址 <code>:</code>
偏移地址）是允许在程序中编排的地址</p>
<p>CPU必须按照物理地址对对内存进行寻址，访存时首先把逻辑地址转换为物理地址，然后再对内存单元进行读/写</p>
<p><br></p>
<p>将段基址与偏移地址放入BIU的物理地址加法器就可以计算出实际物理地址</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217161803751.png" class title="image-20231217161803751">
<p><br></p>
<p>如每个段都是64K，则最多可分16个段：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217164130441.png" class title="image-20231217164130441">
<p><span class="math display">\[
1MB=2^{20}=2^{16}\times2^{4}=64KB\times16个
\]</span></p>
<p>段与段可以交差甚至重叠：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217164150131.png" class title="image-20231217164150131">
<h4 id="物理地址的形成">物理地址的形成</h4>
<p>BIU里有4个段寄存器：CS, DS, SS, ES</p>
<p>逻辑地址由段寄存器和段内偏移量寄存器组成 <span class="math display">\[
\begin{align*}
物理地址&amp;=段基址\times16+偏移地址\\
&amp;=段寄存器的值\times16+段内偏移量寄存器的值
\end{align*}
\]</span> <img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217164859557.png" class title="image-20231217164859557"></p>
<h4 id="逻辑地址的来源段寄存器与段内指针寄存器搭配使用">逻辑地址的来源（段寄存器与段内指针寄存器搭配使用）</h4>
<p><code>CS : IP</code>指向代码段（当前执行的代码的地址）</p>
<p><code>SS : SP</code>指向堆栈段（SS指向堆栈段首地址，SP指向堆栈段栈顶）</p>
<p><code>DS : BX(SI, DI)</code>指向数据段（指向数据段中的特定位置）</p>
<p><code>ES : DI</code>（串操作）指向附加段</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217165722841.png" class title="image-20231217165722841">
<h3 id="分体结构">分体结构</h3>
<p>在8086系统中，存储器采用分体结构，即1MB的存储空间分为两个512KB的存储体，一个存储体中包含偶数地址，另一个存储体包含奇数地址</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217170434989.png" class title="image-20231217170434989">
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217162843395.png" class title="image-20231217162843395">
<p>可见，数据总线的高8位连接偶地址存储器，低8位连接奇地址存储器</p>
<p>地址线仅用到A19 - A1，原因是A0用于区分当前访问的是哪个存储体</p>
<p><br></p>
<p><a id="explanation of two words"></a></p>
<p>8086的有些指令是访问（读或写）字节的，有些指令是访问（读或写）字的</p>
<p>在同一时间，8086存储器中取出来的信息数量<strong>总是16位</strong>的，而且该16位数据是在存储器中以<strong>偶地址开头</strong>2字节的内容</p>
<p>当8086要访问字节时，在被读出的16位数据中，只要忽略高8位或者低8位就可以得到所需要的1字节信息，如下图(a)(b)所示：</p>
<p>当8086要访问1个字，而这个字是偶地址起始的，只需要使A0=0,
~BHE=0，就可以一次性访问到该字的内容，如下图(c)所示：</p>
<p>当8086要访问1个字，而这个字是奇地址起始的，情况就很复杂，必须对两个连续的偶地址字做<strong>两次</strong>存储器访问，每次访问忽略不要的1字节，保留剩余的1字节，然后变换得到一个完整的字信息，如下图(d)所示：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217203850572.png" class title="image-20231217203850572">
<p>8086编程并不涉及这些细节，一条指令只是访问一个特定的字节或字，细节操作是在处理器的控制下自动实现的</p>
<p>综上，在字访问的情况下，对奇地址存放的字需要进行两次读/写操作，对偶地址存放的字仅需一次读/写操作</p>
<p>为了加快程序的运行速度，希望被访问的存储器的字地址为偶地址，所以偶地址起始的字称为“对准字”或“规则字”，奇地址起始的字称为“非对准字”或“非规则字”</p>
<h4 id="相邻两个单元字的读写">相邻两个单元（字）的读写</h4>
<h5 id="偶地址为低字节的字的读写">偶地址为低字节的字的读写</h5>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217211531747.png" class title="image-20231217211531747">
<p>奇偶存储体都是低电平有效</p>
<p>A0=0, ~BHE=0使得奇偶存储体都有效，再根据A19 - A1获取相应地址</p>
<p>这样数据总线可以一次从奇偶两个存储体读/写16位数据，即一次访存读/写一整个字</p>
<h5 id="奇地址为低字节的字的读写">奇地址为低字节的字的读写</h5>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217212242001.png" class title="image-20231217212242001">
<p>可见奇地址为低字节的两个连续字节形成的字，物理地址最后几位不像偶地址低字节一样仅差一位，奇地址低字节物理地址后三位有差别，所以不能在一次访存中获取这两个字节</p>
<p>于是就需要两次访存，第一次拿出8位的奇字节，第二次拿出8位的偶字节，这样才能拼出完整的字</p>
<p>一次访存是操作16位的数据，所以每次都会舍弃8位不需要的数据</p>
<h4 id="堆栈">堆栈</h4>
<p>SS指向堆栈段首地址</p>
<p>SP指向当前栈顶</p>
<p>8086的堆栈是“向下增长”的，具体来说，栈的空间是从<code>SS : SP</code>指向的地址开始，向低地址方向延伸</p>
<p>举个例子：假设栈初始化为这样：SS=1000H，SP=0100H</p>
<p>假设这个时候栈为空，什么都没存，则说明这个堆栈段最大就只能存0100H个字节，即从<code>SS : SP</code>开始延伸，最大延伸到<code>SS : 0000H</code></p>
<p>在8086中，<code>PUSH</code>和<code>POP</code>指令都是对16位寄存器或存储器两单元的操作数来操作的，但是内存空间（包括栈空间）是以字节（8位）为单位进行存储的，所以无论进栈或出栈，都要使用栈空间的<strong>两个字节</strong>；同时也要注意高地址放高字节，低地址放低字节</p>
<p>此时对栈进行压栈操作，SP的值会减少2个字节，即<code>0100H - 2H = 00FEH</code></p>
<p>同理，出栈操作，SP的值会增加2个字节，即<code>00FEH + 2H = 0100H</code></p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231217225714156.png" class title="image-20231217225714156">
<p>工作过程图解：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219110742329.png" class title="image-20231219110742329">
<h2 id="作业">作业</h2>
<p>急急急，先搞三个芯片，这里先搁置</p>
<h1 id="计时器定时器芯片">8253计时器/定时器芯片</h1>
<p>可编程计数器核心电路就是一个事先可以设置计数常数的计数器，其记录脉冲方式和记满“溢出”方式都可以通过程序设定</p>
<h2 id="如何实现定时">如何实现定时</h2>
<p><strong>软件方法</strong>：用一段程序实现延时</p>
<p>利用程序循环延迟指定时间</p>
<p>缺点：延时精度，降低了CPU利用率</p>
<p><strong>硬件方法</strong>：设计定时/计数器电路</p>
<p>利用脉冲计数在设定的时间输出定时信号</p>
<h2 id="概况">8253概况</h2>
<p>内部有3个独立的16位的定时/计数器（通道），可对3个外设实现定时或计数</p>
<p>每个通道6种工作方式</p>
<p>24引脚双列直插式</p>
<p>最高计数频率2MHz</p>
<p>TTL电平兼容</p>
<p>单电源+5V供电</p>
<h2 id="引线图">8253引线图</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218164333705.png" class title="image-20231218164333705">
<p>具体引脚如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218164310827.png" class title="image-20231218164310827">
<p>~CS为片选信号</p>
<p>9,10,11为通道0，同理13,14,15为通道1，16,17,18为通道3</p>
<h3 id="连接至系统端的主要引线">连接至系统端的主要引线</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218164511901.png" class title="image-20231218164511901">
<h3 id="计数通道的主要引线">计数通道的主要引线</h3>
<p>每个通道均相同</p>
<p>CLK，时钟脉冲输入，计数器的计时基准</p>
<p>GATE，门控信号输入，控制计数器的启停（相当于让CLK信号进入计数器的开关）</p>
<p>OUT，计数器输出信号，不同工作方式下产生不同波形</p>
<h2 id="内部结构">8253内部结构</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218164102679.png" class title="image-20231218164102679">
<p>厂家把计数器电路集成在“通道”中，计数器012就是这3个通道</p>
<p><br></p>
<p>程序员视点：</p>
<p>计数器有3个，每一个计数器内部包括16位初值寄存器，16为计数寄存器（减法计数器）</p>
<p>控制寄存器有1个，存放控制命令字，<strong>仅写</strong>不能读</p>
<p>占用4个地址——3个计数器，1个控制寄存器</p>
<p><br></p>
<p>数据总线缓冲器是CPU与8253交换信息的必经之路</p>
<h2 id="定时计数工作过程">8253定时/计数工作过程</h2>
<h3 id="工作过程">工作过程</h3>
<p>1.设置8253的工作方式</p>
<p>2.设置计数初值到初值寄存器</p>
<p>3.<strong>第一个CLK信号</strong>使初值寄存器的内容置入计数寄存器</p>
<p>4.以后每来一个<strong>CLK</strong>信号，计数寄存器减1</p>
<p>5.减到0时，<strong>OUT</strong>端输出一特殊波形的信号</p>
<p>注：以上计数过程中还受到<strong>GATE</strong>信号的控制</p>
<p><br></p>
<p>首先，外电路的脉冲信号通过CLK进入通道，如果GATE有效，使CLK上的脉冲信号进入计数器计数，8253计数器工作在减1状态，每输入一个计数脉冲，计数器的值减1</p>
<p>当计数器计数到0的时候，OUT信号有效，通知外设计数器产生溢出</p>
<p>在通道工作过程中，CPU可以随时通过对端口的读/写，读取计数器的数据</p>
<h3 id="通道内部">通道内部</h3>
<p>在8253中，每个通道内部设置一个16位计数器，可进行二进制或BCD码计数</p>
<p>采用二进制计数时，最大计数值为0FFFFH</p>
<p>采用BCD码计数时，最大计数值为9999</p>
<p>与此计数器相对应，每个通道内部设置一个16位计数值锁存器，必要时用于锁存计数值</p>
<p>每一个计数器内部如图：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218170911203.png" class title="image-20231218170911203">
<h3 id="计数值的设置">计数值的设置</h3>
<p>当一个通道用作计数器时，应将要计数的次数预置到该通道的计数器中</p>
<p>当用作定时器时，从CLK输入一固定频率的时钟脉冲，再根据要求定时的时间算出定时所需计数值（时间常数），并预置到计数器中</p>
<p>计数值与定时时间、CLK端时钟脉冲信号周期的关系如下： <span class="math display">\[
计数值=\frac{定时时间}{时钟脉冲周期}
\]</span></p>
<p>比如我现在输入8253的时钟频率是2MHZ（<span class="math inline">\(2\times10^6\)</span>HZ）</p>
<p>时钟脉冲周期就是<span class="math inline">\(\dfrac{1}{2\times10^6HZ}=0.5\times10^{-6}s=0.5\mu
s\)</span></p>
<p>我需要随便一个计数器，启动计数10ms后OUT输出高电平</p>
<p>单位换算：<span class="math inline">\(1s=1\times10^{3}ms=1\times10^{6}\mu
s=1\times10^{9}ns\)</span> <span class="math display">\[
计数值=\frac{10ms}{0.5\mu s}=20000
\]</span>
所以就给计数器赋值20000即可，至于工作方式的选择，下面再细讲</p>
<h2 id="计数启动方式">计数启动方式</h2>
<p>程序指令启动——软件启动</p>
<p>外部电路信号启动——硬件启动</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218172704311.png" class title="image-20231218172704311">
<p>软件启动的GATE<strong>保持高电平</strong>，<strong>写入计数初值</strong>后的<strong>第2个</strong>CLK脉冲的<strong>下降沿</strong>开始计数</p>
<p>注：软件启动时GATE保持高电平，如果之后工作过程中GATE变成低电平，则说明计数暂停</p>
<p><br></p>
<p>硬件启动的GATE会有<strong>上升沿</strong>，<strong>对应</strong>CLK脉冲的<strong>下降沿</strong>开始计数</p>
<p>这些与8253的工作方式有关</p>
<h2 id="工作方式">8253工作方式</h2>
<p>总共6种工作方式</p>
<p>编号从0到5</p>
<p>0,4是软件启动</p>
<p>1,5是硬件启动</p>
<p>2,3是软件硬件启动</p>
<p>只有方式2和3自动重复计数</p>
<h3 id="方式0计数结束中断">方式0——计数结束中断</h3>
<p>方式0的作用就是用户可以在设定时间上产生中断信号</p>
<p><strong>软件</strong>启动，不自动重复计数（计数初值一次性使用有效）</p>
<p>控制字写入控制寄存器后，OUT端变低电平（一直保持低信号）</p>
<p>计数初值再写入通道后计数器就开始工作</p>
<p>计数结束OUT输出高电平</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218180112248.png" class title="image-20231218180112248">
<p>可见，方式0的GATE要一直为1才能正常工作，不然就暂停</p>
<h3 id="方式1可重复触发的单稳态触发器">方式1——可重复触发的单稳态触发器</h3>
<p>所谓单稳电路，就是在输入的激励下产生固定宽度的脉冲电路</p>
<p>硬件启动，不自动重复计数（如果再给一个GATE上升沿，会重新计数）</p>
<p>控制字写入控制寄存器后，OUT端变高电平</p>
<p>初始计数值写入通道后并不开始计数工作，而是等触发信号到来，即GATE上升沿</p>
<p>计数开始OUT端变为低电平</p>
<p>计数结束后又变高（类似一个低脉冲的效果）</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218181522702.png" class title="image-20231218181522702">
<p>如图，计数已结束，但是再来一个GATE上升沿仍会重新计数</p>
<p>如图，计数未结束时再来一个GATE上升沿，则会重新计数</p>
<h3 id="方式2频率发生器">方式2——频率发生器</h3>
<p>软、硬件启动，<strong>自动重复计数</strong></p>
<p>装入初值后OUT端变高电平，计数到最后一个CLK时（即计数到1）OUT输出一个CLK时钟的负脉冲，并<strong>连续重复此过程</strong></p>
<p>输入信号是周期性脉冲信号，输出信号也是周期性脉冲信号，从OUT输出</p>
<p>方式2实际上是一个可编程的分频电路，把输入信号分频后以脉冲的形式输出，分频系数是用户事先对通道计数器写入的初始计数值</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218182327100.png" class title="image-20231218182327100">
<h3 id="方式3方波发生器">方式3——方波发生器</h3>
<p>软、硬件启动，<strong>自动重复计数</strong></p>
<p>装入初值后OUT端变高电平</p>
<p>然后OUT连续输出对称方波，即同一周期内，前一半为高电平，后一半为低电平</p>
<p>如果计数初始值N为奇数，则前<span class="math inline">\(\dfrac{N+1}{2}\)</span>个CLK里OUT为高，后<span class="math inline">\(\dfrac{N-1}{2}\)</span>个CLK里OUT为低</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218182702598.png" class title="image-20231218182702598">
<h3 id="方式4软件触发选通">方式4——软件触发选通</h3>
<p>软件出发实际上就是CPU通过指令触发一个选通信号给外设，选通信号在触发后<strong>设定时间点</strong>上发出</p>
<p>软件启动，不自动重复计数</p>
<p>装入初值后输出端维持高电平</p>
<p>计数结束输出<strong>一个CLK宽度</strong>的负脉冲</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218183537455.png" class title="image-20231218183537455">
<h3 id="方式5硬件触发选通">方式5——硬件触发选通</h3>
<p>硬件启动，不自动重复计数</p>
<p>OUT端波形与方式4相同</p>
<p><br></p>
<p>工作波形如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218183646824.png" class title="image-20231218183646824">
<h3 id="各种工作方式总结">各种工作方式总结</h3>
<h4 id="方式0计数结束中断-1">方式0（计数结束中断）</h4>
<p>计数过程中，GATE端应保持<strong>高电平</strong></p>
<p>每写入一次初值计数一个周期，然后停止计数</p>
<p>OUT端输出是一个约(N+1)TCLK宽度的负脉冲（写入控制字时变低，直到计数为0时升高，从头到尾算是一个负脉冲）</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095341089.png" class title="image-20231219095341089">
<p>计数过程中可随时修改初值重新开始计数</p>
<h4 id="方式1单稳态触发器">方式1（单稳态触发器）</h4>
<p>门控信号GATE端的跳变触发计数，可重复触发</p>
<p>若下一次GATE上升沿提前到达，则OUT端负脉冲拉宽为两次计数过程之和</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095419928.png" class title="image-20231219095419928">
<p>计数过程中写入新初值不影响本次计数</p>
<h4 id="方式2频率发生器-1">方式2（频率发生器）</h4>
<p>GATE为计数的控制信号：GATE变低计数停止，再变高时的下一个CLK下降沿，从初值开始重新计数</p>
<p>每个计数周期结束时（<strong>减到1时</strong>），OUT端输出一个TCLK宽度的负脉冲</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095500010.png" class title="image-20231219095500010">
<p>计数过程<strong>自动重复</strong>进行</p>
<p>计数过程中修改初值不影响本轮计数过程</p>
<h4 id="方式3方波发生器-1">方式3（方波发生器）</h4>
<p>OUT输出方波，前半周期为高，后半周期为低，一半一半</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095518357.png" class title="image-20231219095518357">
<p>计数过程中修改初值不影响<strong>本半轮</strong>计数过程</p>
<p>其余的与方式2类似</p>
<h4 id="方式4软件触发选通-1">方式4（软件触发选通）</h4>
<p>计数过程中，GATE端应保持<strong>高电平</strong></p>
<p>每写入一次初值，计数一个周期，然后停止计数</p>
<p>每个计数周期结束时（减到0时），OUT端输出一个TCLK宽度的负脉冲</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095544309.png" class title="image-20231219095544309">
<p>计数过程中修改初值不影响本轮计数过程</p>
<h4 id="方式5硬件触发选通-1">方式5（硬件触发选通）</h4>
<p>写入初值时，GATE端应保持<strong>低电平</strong></p>
<p>GATE每出现一次正脉冲，计数一个周期，然后停止计数</p>
<p>每个计数周期结束时（减到0时），OUT端输出一个TCLK宽度的负脉冲</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219095544309.png" class title="image-20231219095544309">
<p>计数过程中修改初值不影响本轮计数过程</p>
<h3 id="gate信号功能表">GATE信号功能表</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218184150817.png" class title="image-20231218184150817">
<h2 id="控制字">8253控制字</h2>
<p>用于确定各计数器的工作方式</p>
<p>8253必须先初始化才能正常工作</p>
<p>每个计数器都必须初始化一次</p>
<p>CPU通过OUT指令把控制字写入<strong>控制寄存器</strong></p>
<h3 id="控制字格式">控制字格式</h3>
<p>8位控制字</p>
<p>控制字包括：指定计数器，对通道计数器的读写方式，指定通道工作方式，通道计数器计数时采用的数制信息（BCD或二进制）</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218184439221.png" class title="image-20231218184439221">
<p>每个寄存器都要记住</p>
<p>从高到底分别为：</p>
<p>SC1, SC0, RL1, RL0, M2, M1, M0, BCD</p>
<p>前两个SC选择了计数器</p>
<p>两个RL用于确定读/写操作的方式，同时也是计数长度的选择，00锁存，01低8位，10高8位，11先低后高两个字节，即计数值为16位</p>
<p>M2M1M0指定工作方式，其中方式2和3的编码很特殊，不考虑M2位</p>
<p>最低位的BCD指定是否BCD计数</p>
<h2 id="初始化顺序">8253初始化顺序</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218185220397.png" class title="image-20231218185220397">
<p>先写方式控制字，按012的顺序</p>
<p>写计数值低8位后紧接着写同一个计数器的计数值高8位</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218185724423.png" class title="image-20231218185724423">
<h2 id="与系统的连接图">8253与系统的连接图</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218203805355.png" class title="image-20231218203805355">
<h2 id="如何读出当前计数值">如何读出当前计数值</h2>
<p>第1种方法——在计数过程中读计数值</p>
<p>先锁存当前计数值，再用两条输入指令将16位计数值读出</p>
<p><br></p>
<p>第2种方法——停止计数器再读</p>
<p>用GATE信号使计数器停止，再规定RL1和RL0的读写格式，然后读出</p>
<h2 id="扩展定时计数范围">扩展定时/计数范围</h2>
<p>当定时长度不够时，可把2个或3个计数通道串联起来使用，甚至可把多个8253串联起来使用</p>
<p>例如：CLK频率为1MHz，要求在OUT1端产生频率1Hz的脉冲</p>
<p>这时可将计数器0、1串联，工作方式都均为方式3，计数初值均为1000</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218225423320.png" class title="image-20231218225423320">
<h2 id="作业-1">8253作业</h2>
<p>别急</p>
<h1 id="并行可编程接口芯片">8255并行可编程接口芯片</h1>
<p>其实CPU可以直接和外设相连，不用8255也可以</p>
<p>但是CPU只是发送信号，驱动能力很低（电流很低），接很多外设CPU扛不住</p>
<p>于是可以在CPU和外设之间加一块8255，既可以传信号，也可以增加驱动能力，还可以可靠传输</p>
<h2 id="概况-1">8255概况</h2>
<p>8255A是一种通用的可编程并行I/O接口芯片，具有3个独立的带锁存或缓存的数据端口，<strong>可与外设并行进行数据交换</strong></p>
<p>用户可以用程序选择多种操作方式，可为CPU与外设之间提供并行输入/出通道</p>
<p>各端口内具有中断控制逻辑，在外设与CPU之间可用中断方式进行信息交换，使用条件传输方式时可用“联络”线进行控制</p>
<p>可通过编程设置各端口工作方式和数据传送方向（入/出/双向）</p>
<p>并行数据宽度为8位</p>
<h2 id="引线图-1">8255引线图</h2>
<p>共40个引脚</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218203116142.png" class title="image-20231218203116142">
<h3 id="连接至系统端的主要引线-1">连接至系统端的主要引线</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218203215422.png" class title="image-20231218203215422">
<h3 id="连接外设端的引脚">连接外设端的引脚</h3>
<p>PA0-PA7</p>
<p>PB0-PB7</p>
<p>PC0-PC7</p>
<p>对应了A, B, C三个8位输入/输出端口</p>
<p>三个端口可通过<strong>编程</strong>分别指定为输入或输出口</p>
<p>其中，C口即可用作独立的输入/输出口，也可用作A、B口的<strong>控制信号输出</strong>或<strong>状态信号输入</strong></p>
<h2 id="内部结构-1">8255内部结构</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218203534742.png" class title="image-20231218203534742">
<p>厂家除了把输入/输出接口电路集成在一块芯片中，还包括控制这些接口电路的控制部分，以及与CPU接口的总线接口部分</p>
<p><br></p>
<p>8255A芯片中包含3个8位端口：A口，B口，C口</p>
<p>这三个端口均可以作为CPU与外设通信时的缓冲器或锁存器</p>
<p>一般来说，它们做缓冲器使用时，是输入接口；作为锁存器使用时，是输出接口</p>
<p><br></p>
<h3 id="c口可作为ab两端口的信号输入输出">C口可作为AB两端口的信号输入输出</h3>
<p>条件传输方式需要“状态”或“联络”信号</p>
<p>中断传输方式需要“中断”信号</p>
<p>由于8255没有预先从芯片引脚上给出这些信号，因此在用户选择这两种工作方式时，8255A将从C口的8位I/O线中提取若干根线作为“状态”“联络”或“中断”线；在这种状态下，C口剩余的线依然可以作为I/O线</p>
<p>也就是说C口相当于“握手协议”，维持传输的稳定</p>
<p>3个端口通过各自的I/O线与外设联系</p>
<h3 id="ab端口控制">AB端口控制</h3>
<p>8255A有3个端口，但不是每个端口都有自己独立的控制部件，只有两个控制部件</p>
<p>只有A组和B组有控制部件，这样3个端口就会分为2组</p>
<p>A组由A口和C口的高4位组成</p>
<p>B组由B口和C口的低4位组成</p>
<p>A组和B组有自己的控制部件，可同时接受来自读/写控制电路的命令和CPU送来的控制字，并且根据这些来定义各个端口的操作方式</p>
<h3 id="数据总线缓冲器">数据总线缓冲器</h3>
<p>数据总线缓冲器是CPU与8255A交换信息的必经之路</p>
<h2 id="与系统的连接图-1">8255与系统的连接图</h2>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218203732822.png" class title="image-20231218203732822">
<h2 id="工作方式-1">8255工作方式</h2>
<p>总共3种工作方式</p>
<p>编号是0，1，2</p>
<h3 id="方式0基本输入输出方式">方式0：基本输入/输出方式</h3>
<p>方式0主要工作在无条件的输入/输出方式下，不需要“联络”信号</p>
<p>A口，B口，C口均可工作在此方式下，C口只能工作在方式0下</p>
<p>在这种方式下，CPU与端口之间交换数据可以直接由CPU执行IN或OUT指令完成，不需要检测状态线</p>
<p>由于在方式0下，3个端口可以分别定义为输入或输出端口，于是3个端口就会有下图16种输入/输出组合：</p>
<p>16的原因：C口可以分为两个4位的独立端口</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218220935091.png" class title="image-20231218220935091">
<p><br></p>
<p>8255在方式0相当于三个独立的8位简单接口</p>
<p>各端口既可设置为输入口，也可设置为输出口，但<strong>不能同时</strong>实现输入及输出</p>
<p>C端口即可以是一个8位的简单接口，也可以分为<strong>两个独立的</strong>4位端口</p>
<p>设置为输出口时有锁存能力，设置为输入口时无锁存能力</p>
<p><br></p>
<h4 id="方式0的应用">方式0的应用</h4>
<p>用于连接简单外设</p>
<p>适用于：</p>
<p>无条件输入输出方式</p>
<p>查询输入输出方式：把A、B口作为8位数据的输入或输出口，C口的高/低4位分别定义为A、B口的控制位和状态位</p>
<h3 id="方式1选通输入输出方式">方式1：选通输入/输出方式</h3>
<p>方式1主要工作在异步或条件传输方式下</p>
<p>在方式1下，数据的输入、输出操作要在选通信号控制下完成，适合条件传输（必须先检查状态，然后才能传输数据）</p>
<p>仅有A口和B口可工作在此方式下，因为C口的部分位固定用作A、B口的选通控制信号（联络线），相当于握手协议</p>
<p>工作在方式1下的A口和B口可以作为输入接口，也可以作为输出接口</p>
<p>由于输入接口和输出接口所需要的选通控制不同，“联络线”的定义和功能也不同，需要分别介绍</p>
<h4 id="选通输入方式">选通输入方式</h4>
<p>AB口均为输入</p>
<p>在这种方式下，A口或B口需有C口3根线作为联络线</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219091555181.png" class title="image-20231219091555181">
<p>PC3, PC4, PC5作为A口的联络线，PC0, PC1, PC2作为B口的联络线</p>
<h5 id="信号功能">信号功能</h5>
<p>~STBA：A口的选通信号（外设发出，低电平有效），当其有效时，外设把数据输入A口的输入缓冲器</p>
<p>IBFA：A口的输入缓冲器“满”信号，当其有效时，表示A口的输入缓冲器已暂存一个有效数据，是输出信号；此信号由STB的<strong>前沿</strong>产生</p>
<p>INTRA：A口的中断请求信号，当其有效时，8255的A口向CPU申请中断，要求CPU从A口取数，是输出信号；此信号由STB的<strong>后沿</strong>产生</p>
<p>在这种方式下，A口的逻辑电路有一个INTEA信号，称为中断允许信号，这个信号为高时，与门导通，INTEA就可以作为INTRA中断信号输出了。INTEA对应C口输出锁存器的第4位，即通过对C口PC4的置位/复位就可以设置INTEA</p>
<p>即：INTEA =1和IBFA为高电平时，允许发出INTRA请求</p>
<h5 id="发送数据过程">发送数据过程</h5>
<p>在方式1下，外设把一个数据通过A口送给CPU的过程如下：</p>
<p>1.外设把数据送到A口的数据线PA7-PA0后，使选通信号~STBA有效，数据进入A口的输入缓冲区</p>
<p>2.A口的IBFA有效，通知外设或CPU，表示A口接收了一个有效数据</p>
<p>3.A口的INTRA有效，以中断方式通知CPU取走A口的数据</p>
<p>4.CPU读A口，数据进入CPU</p>
<p>5.IBFA和INTRA转为无效</p>
<p>方式1数据输入的时序图如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219093233107.png" class title="image-20231219093233107">
<p><br></p>
<p>可见，当A口接收外部数据以后，会有IBFA和INTRA的输出，对应了两种方式通知CPU取数：</p>
<p>条件查询方式，通过查询缓冲器是否“满”，即IBFA是否为高电平来取数</p>
<p>中断方式，先用控制字把C口的INTEA置位1，当IBFA=1时，这两个高电平通过与门产生高电平INTRA；若CPU允许中断，则中断当前执行的程序，转到对A口读数的中断服务子程序</p>
<h5 id="握手信号">握手信号</h5>
<p>在条件传输中，一般需要有“握手”信号来协调数据的传输</p>
<p>“握手”信号至少要有两位信号线，其中一位由接口电路发给外设，另一位是外设发给接口</p>
<p>在选通方式中，~STBA和IBFA是一对“握手”信号</p>
<p>~STBA是外设发给接口，有效时通知A口，外设传递进来一个数据</p>
<p>IBFA是接口发给外设，有效时通知外设，A口已经接收这个数据</p>
<h5 id="此时的状态字">此时的状态字</h5>
<p>从C口读出的8位数据各位的意义如下</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219101522618.png" class title="image-20231219101522618">
<h4 id="选通输出方式">选通输出方式</h4>
<p>AB口均为输出</p>
<p>在这种方式下，A口或B口需有C口3根线作为联络线</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219101654339.png" class title="image-20231219101654339">
<p>PC3, PC6, PC7作为A口的联络线，PC0, PC1,
PC2作为B口的联络线（与选通输入有点不同：A口的联络线变成了PC3, PC6,
PC7）</p>
<h5 id="信号功能-1">信号功能</h5>
<p>~OBFA：A口输出缓冲区“满”信号，有效时表示A口输出缓冲器已经暂存一个有效数据，通知外设取数据</p>
<p>~ACKA：外设应答信号，由外设发出，低电平有效时表示外设<strong>已经接收</strong>数据</p>
<p>INTRA：A口的中断请求信号，当其有效时，A口向CPU申请中断，要求CPU送数据给A口，由~ACKA上升沿产生（通常接到8259）</p>
<h5 id="发送数据过程-1">发送数据过程</h5>
<p>在方式1输出方式下，CPU把数据通过A口送给外设的过程如下：</p>
<p>1.CPU执行OUT指令，把数据写入A口的输出缓冲器</p>
<p>2.当有效数据进入A口的数据线PA7-PA0时，~OBFA有效通知外设：CPU已把一个有效数据输出到A口，外设可以从A口取数据了</p>
<p>3.外设取走数据时，发~ACKA信号给8255，告诉A口外设已经取完数据</p>
<p>4.A口~OBFA无效，表示A口数据已经被外设取走</p>
<p>5.INTRA有效，以中断的方式通知CPU再输出数据给A口</p>
<p>方式1数据输出的时序图如下：</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219103820080.png" class title="image-20231219103820080">
<p><br></p>
<p>同样，当A口的输出缓冲器数据被外设取走后，有两种方式通知CPU再对A口写入数据：</p>
<p>条件查询方式，查询输出缓冲器是否为“空”，即~OBFA是否为高电平决定CPU是否转向对A口输出数据的程序</p>
<p>中断方式，先用控制字置A口的INTEA位为“1”，若外设取走A口的数据，应答信号<sub>ACKA有效，使</sub>OBFA为高电平；~OBFA和INTEA都为高电平，通过与门产生INTRA中断信号，若CPU允许中断，则中断当前执行的程序，转到对A口写数的中断服务子程序</p>
<h5 id="握手信号-1">握手信号</h5>
<p>在这种方式下，<sub>ACKA和</sub>OBFA是一对握手信号</p>
<p>~OBFA是接口发给外设，通知外设A口有了一个新数据</p>
<p>~ACKA是外设发给接口，通知接口外设已经把数据取走</p>
<h5 id="此时状态字">此时状态字</h5>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219105111892.png" class title="image-20231219105111892">
<h4 id="方式1的应用">方式1的应用</h4>
<p>主要用于中断控制方式下的输入输出</p>
<p>C口除部分位用作选通信号外，其余位可工作在方式0下，作为输入或输出线</p>
<p>特别是A、B均为方式1时仅使用C口的6条线，余下二条线可作为单独的输入输出线，用程序指定其数据传送方向</p>
<h3 id="方式2双向传输方式仅a口">方式2：双向传输方式（仅A口）</h3>
<p>双向方式——既是输入口，又是输出口</p>
<p>利用C口的5条线提供传输联络信号</p>
<p>类似于A口方式1下输入和输出的组合</p>
<p>只有A口可工作在方式2下</p>
<h2 id="控制字-1">8255控制字</h2>
<h3 id="控制字格式-1">控制字格式</h3>
<p>8位控制字</p>
<p>有3种控制字：方式控制字，C口置1清0控制字，读入状态字</p>
<p>要记住所有寄存器</p>
<p>D7为1时，是选择工作方式控制字</p>
<p>D7为0时，是C口置位/复位控制字</p>
<p><br></p>
<h3 id="方式控制字">方式控制字</h3>
<p>控制字包括1位的功能控制，4位的A组控制，3位的B组控制</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218213154942.png" class title="image-20231218213154942">
<p>从高位到低位分别是：</p>
<p>D7功能控制，区分出来两种控制字：<strong>选择工作方式控制字</strong>和<strong>C口置位/复位控制字</strong></p>
<p>D7为1时，是选择工作方式控制字</p>
<p>D7为0时，是C口置位/复位控制字</p>
<p><br></p>
<p>D6, D5, D4, D3是A组控制</p>
<p>其中D6和D5选择工作方式（仅有A口能用方式2）</p>
<p>D4是A口的输入、输出选择</p>
<p>D3为C口高4位的输入、输出选择</p>
<p><br></p>
<p>D2, D1, D0是B组控制</p>
<p>D2为B口的方式选择</p>
<p>D1是B口的输入、输出选择</p>
<p>D0为C口低4位的输入、输出选择</p>
<h3 id="c口置位复位控制字">C口置位/复位控制字</h3>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231218215033167.png" class title="image-20231218215033167">
<p>也就是可以直接操作C口的位</p>
<p>用D3，D2，D1指定PC0-PC7</p>
<p>然后再用D0选择这个口现在的信息</p>
<h3 id="读入状态字">读入状态字</h3>
<p>当8255A工作在方式1或方式2时，C口会根据不同情况产生或接收“联络”信号</p>
<img src="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20231219101327421.png" class title="image-20231219101327421">
<h1 id="中断">中断</h1>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/">复习整理</a><a class="post-meta__tags" href="/tags/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/">接口技术</a><a class="post-meta__tags" href="/tags/8086/">8086</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/20/hexo%E7%9B%B8%E5%85%B3/Hexo_Nunjucks_Error%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" title="Hexo Nunjucks Error解决方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hexo Nunjucks Error解决方法</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/06/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/OOAD%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="OOAD复习整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">OOAD复习整理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/12/06/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/OOAD%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="OOAD复习整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-06</div><div class="title">OOAD复习整理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/WinkySpeed%20SP%20-%20Repaired.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">WinkySpeed</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WinkySpeed"><i class="fab fa-github"></i><span>GitHub</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">接口技术复习整理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">2.</span> <span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9C%A8%E5%B7%A5%E4%B8%9A%E7%94%9F%E4%BA%A7%E8%BF%87%E7%A8%8B%E7%9A%84%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">计算机在工业生产过程的闭环控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">总线分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu"><span class="toc-number">2.3.</span> <span class="toc-text">CPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.</span> <span class="toc-text">I&#x2F;O接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%AE%BE%E9%80%9A%E8%BF%87io%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%80%BB%E7%BA%BF%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.4.1.</span> <span class="toc-text">外设通过I&#x2F;O接口与总线连接的原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA"><span class="toc-number">2.5.</span> <span class="toc-text">微机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.5.1.</span> <span class="toc-text">微机基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">微机工作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA%E5%88%86%E7%B1%BB"><span class="toc-number">2.5.3.</span> <span class="toc-text">微机分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA%E7%BB%84%E6%88%90"><span class="toc-number">2.5.4.</span> <span class="toc-text">微机组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.5.</span> <span class="toc-text">微机工作原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">8086系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">8086CPU结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE"><span class="toc-number">3.1.1.</span> <span class="toc-text">8086CPU内部结构框图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E6%8E%A5%E5%8F%A3%E9%83%A8%E4%BB%B6biubus-interfaceunit"><span class="toc-number">3.1.2.</span> <span class="toc-text">总线接口部件BIU(Bus
InterfaceUnit)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#biu%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">BIU功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#biu%E7%BB%84%E6%88%90"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">BIU组成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E6%AE%B5%E5%9F%BA%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.2.2.1.</span> <span class="toc-text">段寄存器（段基址寄存器）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.2.2.2.</span> <span class="toc-text">指令指针寄存器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%8A%A0%E6%B3%95%E5%99%A8"><span class="toc-number">3.1.2.2.3.</span> <span class="toc-text">物理地址加法器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%98%9F%E5%88%97"><span class="toc-number">3.1.2.2.4.</span> <span class="toc-text">指令队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E6%8E%A7%E5%88%B6%E9%83%A8%E4%BB%B6"><span class="toc-number">3.1.2.2.5.</span> <span class="toc-text">总线控制部件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#biu%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">BIU工作过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%83%A8%E4%BB%B6euexecution-unit"><span class="toc-number">3.1.3.</span> <span class="toc-text">指令执行部件EU(Execution
Unit)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#eu%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">EU功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eu%E7%BB%84%E6%88%90"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">EU组成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E9%80%BB%E8%BE%91%E9%83%A8%E4%BB%B6alu"><span class="toc-number">3.1.3.2.1.</span> <span class="toc-text">算术运算逻辑部件ALU</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8frflag-register"><span class="toc-number">3.1.3.2.2.</span> <span class="toc-text">标志寄存器FR（Flag Register）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A0%87%E5%BF%97"><span class="toc-number">3.1.3.2.2.1.</span> <span class="toc-text">状态标志</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%A0%87%E5%BF%97"><span class="toc-number">3.1.3.2.2.2.</span> <span class="toc-text">控制标志</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.3.2.3.</span> <span class="toc-text">通用寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.3.2.3.1.</span> <span class="toc-text">数据寄存器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.3.2.3.2.</span> <span class="toc-text">指针变址寄存器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#eu%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">3.1.3.2.4.</span> <span class="toc-text">EU控制器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eu%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">EU的工作过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu%E5%BC%95%E8%84%9A"><span class="toc-number">3.2.</span> <span class="toc-text">8086CPU引脚</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E8088%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">3.3.</span> <span class="toc-text">8086与8088不同之处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87"><span class="toc-number">3.4.</span> <span class="toc-text">8086存储器组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BC%96%E5%9D%80"><span class="toc-number">3.4.1.</span> <span class="toc-text">线性编址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">3.4.2.</span> <span class="toc-text">数据存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%8A%80%E6%9C%AF"><span class="toc-number">3.4.3.</span> <span class="toc-text">分段技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E6%AE%B5"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">存储空间的分段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%A2%E6%88%90"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">物理地址的形成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%9A%84%E6%9D%A5%E6%BA%90%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E6%AE%B5%E5%86%85%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8%E6%90%AD%E9%85%8D%E4%BD%BF%E7%94%A8"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">逻辑地址的来源（段寄存器与段内指针寄存器搭配使用）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.4.</span> <span class="toc-text">分体结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E9%82%BB%E4%B8%A4%E4%B8%AA%E5%8D%95%E5%85%83%E5%AD%97%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">相邻两个单元（字）的读写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%B6%E5%9C%B0%E5%9D%80%E4%B8%BA%E4%BD%8E%E5%AD%97%E8%8A%82%E7%9A%84%E5%AD%97%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">3.4.4.1.1.</span> <span class="toc-text">偶地址为低字节的字的读写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A5%87%E5%9C%B0%E5%9D%80%E4%B8%BA%E4%BD%8E%E5%AD%97%E8%8A%82%E7%9A%84%E5%AD%97%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">3.4.4.1.2.</span> <span class="toc-text">奇地址为低字节的字的读写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%A0%88"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">堆栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A"><span class="toc-number">3.5.</span> <span class="toc-text">作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%8A%AF%E7%89%87"><span class="toc-number">4.</span> <span class="toc-text">8253计时器&#x2F;定时器芯片</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6"><span class="toc-number">4.1.</span> <span class="toc-text">如何实现定时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%86%B5"><span class="toc-number">4.2.</span> <span class="toc-text">8253概况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%BA%BF%E5%9B%BE"><span class="toc-number">4.3.</span> <span class="toc-text">8253引线图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E8%87%B3%E7%B3%BB%E7%BB%9F%E7%AB%AF%E7%9A%84%E4%B8%BB%E8%A6%81%E5%BC%95%E7%BA%BF"><span class="toc-number">4.3.1.</span> <span class="toc-text">连接至系统端的主要引线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E9%80%9A%E9%81%93%E7%9A%84%E4%B8%BB%E8%A6%81%E5%BC%95%E7%BA%BF"><span class="toc-number">4.3.2.</span> <span class="toc-text">计数通道的主要引线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.</span> <span class="toc-text">8253内部结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E8%AE%A1%E6%95%B0%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">4.5.</span> <span class="toc-text">8253定时&#x2F;计数工作过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">4.5.1.</span> <span class="toc-text">工作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E5%86%85%E9%83%A8"><span class="toc-number">4.5.2.</span> <span class="toc-text">通道内部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%80%BC%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">4.5.3.</span> <span class="toc-text">计数值的设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">计数启动方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">4.7.</span> <span class="toc-text">8253工作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F0%E8%AE%A1%E6%95%B0%E7%BB%93%E6%9D%9F%E4%B8%AD%E6%96%AD"><span class="toc-number">4.7.1.</span> <span class="toc-text">方式0——计数结束中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%A7%A6%E5%8F%91%E7%9A%84%E5%8D%95%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">4.7.2.</span> <span class="toc-text">方式1——可重复触发的单稳态触发器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F2%E9%A2%91%E7%8E%87%E5%8F%91%E7%94%9F%E5%99%A8"><span class="toc-number">4.7.3.</span> <span class="toc-text">方式2——频率发生器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F3%E6%96%B9%E6%B3%A2%E5%8F%91%E7%94%9F%E5%99%A8"><span class="toc-number">4.7.4.</span> <span class="toc-text">方式3——方波发生器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F4%E8%BD%AF%E4%BB%B6%E8%A7%A6%E5%8F%91%E9%80%89%E9%80%9A"><span class="toc-number">4.7.5.</span> <span class="toc-text">方式4——软件触发选通</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F5%E7%A1%AC%E4%BB%B6%E8%A7%A6%E5%8F%91%E9%80%89%E9%80%9A"><span class="toc-number">4.7.6.</span> <span class="toc-text">方式5——硬件触发选通</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-number">4.7.7.</span> <span class="toc-text">各种工作方式总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F0%E8%AE%A1%E6%95%B0%E7%BB%93%E6%9D%9F%E4%B8%AD%E6%96%AD-1"><span class="toc-number">4.7.7.1.</span> <span class="toc-text">方式0（计数结束中断）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1%E5%8D%95%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">4.7.7.2.</span> <span class="toc-text">方式1（单稳态触发器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F2%E9%A2%91%E7%8E%87%E5%8F%91%E7%94%9F%E5%99%A8-1"><span class="toc-number">4.7.7.3.</span> <span class="toc-text">方式2（频率发生器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F3%E6%96%B9%E6%B3%A2%E5%8F%91%E7%94%9F%E5%99%A8-1"><span class="toc-number">4.7.7.4.</span> <span class="toc-text">方式3（方波发生器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F4%E8%BD%AF%E4%BB%B6%E8%A7%A6%E5%8F%91%E9%80%89%E9%80%9A-1"><span class="toc-number">4.7.7.5.</span> <span class="toc-text">方式4（软件触发选通）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F5%E7%A1%AC%E4%BB%B6%E8%A7%A6%E5%8F%91%E9%80%89%E9%80%9A-1"><span class="toc-number">4.7.7.6.</span> <span class="toc-text">方式5（硬件触发选通）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gate%E4%BF%A1%E5%8F%B7%E5%8A%9F%E8%83%BD%E8%A1%A8"><span class="toc-number">4.7.8.</span> <span class="toc-text">GATE信号功能表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AD%97"><span class="toc-number">4.8.</span> <span class="toc-text">8253控制字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AD%97%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.8.1.</span> <span class="toc-text">控制字格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.9.</span> <span class="toc-text">8253初始化顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%9B%BE"><span class="toc-number">4.10.</span> <span class="toc-text">8253与系统的连接图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%BB%E5%87%BA%E5%BD%93%E5%89%8D%E8%AE%A1%E6%95%B0%E5%80%BC"><span class="toc-number">4.11.</span> <span class="toc-text">如何读出当前计数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%AE%9A%E6%97%B6%E8%AE%A1%E6%95%B0%E8%8C%83%E5%9B%B4"><span class="toc-number">4.12.</span> <span class="toc-text">扩展定时&#x2F;计数范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A-1"><span class="toc-number">4.13.</span> <span class="toc-text">8253作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%8F%AF%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E8%8A%AF%E7%89%87"><span class="toc-number">5.</span> <span class="toc-text">8255并行可编程接口芯片</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%86%B5-1"><span class="toc-number">5.1.</span> <span class="toc-text">8255概况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%BA%BF%E5%9B%BE-1"><span class="toc-number">5.2.</span> <span class="toc-text">8255引线图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E8%87%B3%E7%B3%BB%E7%BB%9F%E7%AB%AF%E7%9A%84%E4%B8%BB%E8%A6%81%E5%BC%95%E7%BA%BF-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">连接至系统端的主要引线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%A4%96%E8%AE%BE%E7%AB%AF%E7%9A%84%E5%BC%95%E8%84%9A"><span class="toc-number">5.2.2.</span> <span class="toc-text">连接外设端的引脚</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-1"><span class="toc-number">5.3.</span> <span class="toc-text">8255内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E5%8F%A3%E5%8F%AF%E4%BD%9C%E4%B8%BAab%E4%B8%A4%E7%AB%AF%E5%8F%A3%E7%9A%84%E4%BF%A1%E5%8F%B7%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">5.3.1.</span> <span class="toc-text">C口可作为AB两端口的信号输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ab%E7%AB%AF%E5%8F%A3%E6%8E%A7%E5%88%B6"><span class="toc-number">5.3.2.</span> <span class="toc-text">AB端口控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF%E7%BC%93%E5%86%B2%E5%99%A8"><span class="toc-number">5.3.3.</span> <span class="toc-text">数据总线缓冲器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%9B%BE-1"><span class="toc-number">5.4.</span> <span class="toc-text">8255与系统的连接图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F-1"><span class="toc-number">5.5.</span> <span class="toc-text">8255工作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F0%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">5.5.1.</span> <span class="toc-text">方式0：基本输入&#x2F;输出方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F0%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">5.5.1.1.</span> <span class="toc-text">方式0的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1%E9%80%89%E9%80%9A%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">5.5.2.</span> <span class="toc-text">方式1：选通输入&#x2F;输出方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E9%80%9A%E8%BE%93%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">5.5.2.1.</span> <span class="toc-text">选通输入方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%8A%9F%E8%83%BD"><span class="toc-number">5.5.2.1.1.</span> <span class="toc-text">信号功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B"><span class="toc-number">5.5.2.1.2.</span> <span class="toc-text">发送数据过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%A1%E6%89%8B%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.5.2.1.3.</span> <span class="toc-text">握手信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A4%E6%97%B6%E7%9A%84%E7%8A%B6%E6%80%81%E5%AD%97"><span class="toc-number">5.5.2.1.4.</span> <span class="toc-text">此时的状态字</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E9%80%9A%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">5.5.2.2.</span> <span class="toc-text">选通输出方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%8A%9F%E8%83%BD-1"><span class="toc-number">5.5.2.2.1.</span> <span class="toc-text">信号功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B-1"><span class="toc-number">5.5.2.2.2.</span> <span class="toc-text">发送数据过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%A1%E6%89%8B%E4%BF%A1%E5%8F%B7-1"><span class="toc-number">5.5.2.2.3.</span> <span class="toc-text">握手信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A4%E6%97%B6%E7%8A%B6%E6%80%81%E5%AD%97"><span class="toc-number">5.5.2.2.4.</span> <span class="toc-text">此时状态字</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">5.5.2.3.</span> <span class="toc-text">方式1的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F2%E5%8F%8C%E5%90%91%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F%E4%BB%85a%E5%8F%A3"><span class="toc-number">5.5.3.</span> <span class="toc-text">方式2：双向传输方式（仅A口）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AD%97-1"><span class="toc-number">5.6.</span> <span class="toc-text">8255控制字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AD%97%E6%A0%BC%E5%BC%8F-1"><span class="toc-number">5.6.1.</span> <span class="toc-text">控制字格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E6%8E%A7%E5%88%B6%E5%AD%97"><span class="toc-number">5.6.2.</span> <span class="toc-text">方式控制字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E5%8F%A3%E7%BD%AE%E4%BD%8D%E5%A4%8D%E4%BD%8D%E6%8E%A7%E5%88%B6%E5%AD%97"><span class="toc-number">5.6.3.</span> <span class="toc-text">C口置位&#x2F;复位控制字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%85%A5%E7%8A%B6%E6%80%81%E5%AD%97"><span class="toc-number">5.6.4.</span> <span class="toc-text">读入状态字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">6.</span> <span class="toc-text">中断</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/20/hexo%E7%9B%B8%E5%85%B3/Hexo_Nunjucks_Error%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" title="Hexo Nunjucks Error解决方法">Hexo Nunjucks Error解决方法</a><time datetime="2023-12-20T10:55:45.000Z" title="发表于 2023-12-20 18:55:45">2023-12-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="接口技术复习整理">接口技术复习整理</a><time datetime="2023-12-12T02:56:09.000Z" title="发表于 2023-12-12 10:56:09">2023-12-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/06/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/OOAD%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="OOAD复习整理">OOAD复习整理</a><time datetime="2023-12-06T13:07:25.000Z" title="发表于 2023-12-06 21:07:25">2023-12-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/09/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Raycasting%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="Raycasting学习记录">Raycasting学习记录</a><time datetime="2023-11-09T01:47:32.000Z" title="发表于 2023-11-09 09:47:32">2023-11-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/28/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%A4%A7%E4%B8%89%E4%B8%93%E4%B8%9A%E8%AF%BE%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/" title="大三专业课上机实验碰到的问题合集">大三专业课上机实验碰到的问题合集</a><time datetime="2023-10-28T09:30:26.000Z" title="发表于 2023-10-28 17:30:26">2023-10-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By WinkySpeed</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2d-widget/autoload.js"></script></body></html>