<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>数据结构复习整理 | WinkySpeed</title><meta name="author" content="WinkySpeed"><meta name="copyright" content="WinkySpeed"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构复习整理 概论 逻辑结构 线性 非线性 线性表 逻辑结构 前驱、后继 存储结构 顺序：顺序表 链式：链表 链表 不带头结点 带头结点  栈与队列 栈 后进先出 应用实例：括号匹配，表达式求值 表达式求值 中缀表达式，用运算符优先级表 中缀表达式转后缀表达式：遇到数字直接输出，遇到运算符，先与栈顶运算符比较 若比栈顶运算符优先级高，则入栈，若优先级">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构复习整理">
<meta property="og:url" content="http://example.com/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="WinkySpeed">
<meta property="og:description" content="数据结构复习整理 概论 逻辑结构 线性 非线性 线性表 逻辑结构 前驱、后继 存储结构 顺序：顺序表 链式：链表 链表 不带头结点 带头结点  栈与队列 栈 后进先出 应用实例：括号匹配，表达式求值 表达式求值 中缀表达式，用运算符优先级表 中缀表达式转后缀表达式：遇到数字直接输出，遇到运算符，先与栈顶运算符比较 若比栈顶运算符优先级高，则入栈，若优先级">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-02-14T12:12:43.000Z">
<meta property="article:modified_time" content="2023-02-28T15:23:52.478Z">
<meta property="article:author" content="WinkySpeed">
<meta property="article:tag" content="复习">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构复习整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-28 23:23:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="WinkySpeed"><span class="site-name">WinkySpeed</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构复习整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-14T12:12:43.000Z" title="发表于 2023-02-14 20:12:43">2023-02-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-28T15:23:52.478Z" title="更新于 2023-02-28 23:23:52">2023-02-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构复习整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构复习整理">数据结构复习整理</h1>
<h1 id="概论">概论</h1>
<h2 id="逻辑结构">逻辑结构</h2>
<p>线性</p>
<p>非线性</p>
<h1 id="线性表">线性表</h1>
<h2 id="逻辑结构-1">逻辑结构</h2>
<p>前驱、后继</p>
<h2 id="存储结构">存储结构</h2>
<p>顺序：顺序表</p>
<p>链式：链表</p>
<h2 id="链表">链表</h2>
<p>不带头结点</p>
<p>带头结点</p>
<h2 id="section"></h2>
<h1 id="栈与队列">栈与队列</h1>
<h2 id="栈">栈</h2>
<p>后进先出</p>
<p>应用实例：括号匹配，表达式求值</p>
<h3 id="表达式求值">表达式求值</h3>
<p>中缀表达式，用运算符优先级表</p>
<p>中缀表达式转后缀表达式：遇到数字直接输出，遇到运算符，先与栈顶运算符比较</p>
<p>若比栈顶运算符优先级高，则入栈，若优先级低，则栈顶运算符出栈</p>
<p>中缀表达式运算：遇到数字直接进数字栈，遇到运算符，先与运算符栈顶运算符比较</p>
<p>若比栈顶运算符优先级高，则入运算符栈，若优先级低，则运算符栈顶运算符出栈，并从数字运算符栈拿出相应数字计算</p>
<p>然后把新数压数字栈</p>
<p>后缀表达式求值：不管优先级，遇到运算符就拿出对应的数运算，然后再把新数压栈</p>
<h3 id="栈和递归">栈和递归</h3>
<p>应用：深度优先搜索</p>
<h3 id="递归工作栈">递归工作栈</h3>
<p>将递归转化为非递归</p>
<h2 id="队列">队列</h2>
<p>先进先出</p>
<p>假溢出问题：引入循环队列</p>
<h3 id="循环队列">循环队列</h3>
<p>进队</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(队满)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">data[rear]=x;</span><br><span class="line">rear=(rear+<span class="number">1</span>)%maxSize;</span><br></pre></td></tr></table></figure>
<p>出队</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(队空)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x=data[front];</span><br><span class="line">front=(front+<span class="number">1</span>)%maxSize;</span><br></pre></td></tr></table></figure>
<p>造成浪费一个空间，故判断队满</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SeqQueue::IsFull</span><span class="params">()</span></span>&#123; </span><br><span class="line">     <span class="keyword">return</span> (rear+<span class="number">1</span>) % maxSize == front;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>循环队列用于解决假溢出问题</p>
<p>循环队列少用一个存储空间为了解决队列判满问题</p>
<h3 id="队列应用">队列应用</h3>
<p>广度优先搜索：迷宫最短路径</p>
<h1 id="数组串和广义表">数组，串和广义表</h1>
<h2 id="特殊矩阵">特殊矩阵</h2>
<p>特殊矩阵是指非零元素或零元素的分布有一定规律的矩阵</p>
<h2 id="特殊矩阵的压缩">特殊矩阵的压缩</h2>
<p>存储主要是针对阶数很高的特殊矩阵</p>
<p>为节省存储空间，对可以不存储的元素，如零元素或对称元素，不再存储</p>
<h3 id="对称矩阵的压缩">对称矩阵的压缩</h3>
<p>为节约存储，只存对角线及对角线以上的元素，或者只存对角线或对角线以下的元素</p>
<p>前者称为上三角矩阵，后者称为下三角矩阵</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230216210822668.png" class title="image-20230216210822668">
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230216210830681.png" class title="image-20230216210830681">
<p>把它们按行存放于一个一维数组 B 中，称之为对称矩阵 A
的压缩存储方式</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230216211212881.png" class title="image-20230216211212881">
<p>数组 B 共有 <span class="math inline">\(n+(n-1)+ \cdots +1 = n \cdot
(n+1)/2\)</span> 个元素</p>
<h3 id="三对角矩阵的压缩">三对角矩阵的压缩</h3>
<h2 id="稀疏矩阵">稀疏矩阵</h2>
<h3 id="概念">概念</h3>
<p>设矩阵 A 中有 s 个非零元素，若 s 远远小于矩阵元素的总数（即 <span class="math inline">\(s \ll m\cdot n\)</span>），则称 A 为稀疏矩阵</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230216211402331.png" class title="image-20230216211402331">
<h3 id="稀疏矩阵的存储">稀疏矩阵的存储</h3>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230216211539046.png" class title="image-20230216211539046">
<h3 id="稀疏矩阵的转置">稀疏矩阵的转置</h3>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230216211652806.png" class title="image-20230216211652806">
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230216211705676.png" class title="image-20230216211705676">
<h2 id="广义表">广义表</h2>
<p>广义表是 <span class="math inline">\(n ( n \ge 0 )\)</span>
个表元素组成的有限序列，记作 <span class="math display">\[
LS(a_1,a_2,a_3,\cdots,a_n)
\]</span> LS 是表名，<span class="math inline">\(a_i\)</span>
是表元素，可以是表（称为子表），可以是数据元素（称为原子）</p>
<p>n为表的长度，<span class="math inline">\(n = 0\)</span>
的广义表为空表</p>
<p><span class="math inline">\(n &gt;
0\)</span>时，表的第一个表元素称为广义表的表头（head），除此之外，其它表元素组成的表称为广义表的表尾（tail）</p>
<h1 id="树与二叉树">树与二叉树</h1>
<h2 id="树基本概念">树基本概念</h2>
<p>结点的度：结点拥有的子树棵数</p>
<p>树的度：各个节点度的最大值</p>
<p>分支节点（非终端节点）：除叶结点以外的节点</p>
<p>兄弟节点：同一父节点的子女</p>
<p>祖先节点：从根节点到该节点所经的所有节点</p>
<p>节点层次：根节点到该节点的层数</p>
<p>树的深度：距离根节点最远的节点的层数</p>
<p>树的高度：叶节点高度为1，非叶节点高度等于子女+1</p>
<p>森林：树的集合</p>
<h2 id="二叉树">二叉树</h2>
<h3 id="二叉树特点">二叉树特点</h3>
<p>每个结点最多有两个子女，分别称为该结点的左孩子和右孩子</p>
<p>二叉树中不存在度大于2的结点，并且二叉树的子树有左右子分，其子树的次序不能颠倒</p>
<h3 id="二叉树性质">二叉树性质</h3>
<p>1、若二叉树结点的层次从 1 开始, 则在二叉树的第 i 层最多有 $ 2^{i-1} $
个结点。( i≥1)</p>
<p>2、深度为 k 的二叉树最少有 k 个结点，最多有$ 2^{k-1} $个结点。( k≥1
)</p>
<p>3、对任何一棵二叉树，如果其叶结点有 <span class="math inline">\(n_0\)</span> 个, 度为 2 的非叶结点有 <span class="math inline">\(n_2\)</span> 个, 则有 <span class="math inline">\(n_0＝n_2+1\)</span></p>
<p>性质3证明：设总结点数为 <span class="math inline">\(n\)</span> <span class="math display">\[
\begin{align*}
树的边数 &amp;= 节点数-1 \\
2 \times n_2 &amp;= n_0 + n_2 - 1 \\
n_0 &amp;= n_2 + 1
\end{align*}
\]</span></p>
<h3 id="满二叉树">满二叉树</h3>
<p>每层节点都是最大个数</p>
<p>设深度为k，共 <span class="math inline">\(2^{k}-1\)</span>个节点，除叶子结点以外度都为2</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215151346275.png" class title="image-20230215151346275">
<h3 id="完全二叉树">完全二叉树</h3>
<p>除最底层外，其它层都是满二叉树</p>
<p>设深度为k，除第k层外，其它层节点数都最大</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215151509955.png" class title="image-20230215151509955">
<h3 id="完全二叉树性质">完全二叉树性质</h3>
<p>设深度为k，节点数为n，则 <span class="math inline">\(2^{k-1}-1&lt;n\le 2^k-1\)</span></p>
<p>具有n个节点的完全二叉树 <span class="math inline">\((n\ge0)\)</span>
深度为 <span class="math inline">\(\lceil{\log_2{(n+1)}\rceil}\)</span>
(向上取整)</p>
<p>若给完全二叉树编号，从根节点开始标1，依次往下：<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215152223383.png" class title="image-20230215152223383"></p>
<p><span class="math display">\[
\begin{gather*}
i=1, 则节点无双亲 \\
i&gt;1, i的双亲为\lfloor i\div2 \rfloor \\
i的左子女为i\times2 \\
i的右子女为i\times2+1 \\
i为奇数，且i\ne1,左兄弟为i-1 \\
i为偶数，且i\ne{n},右兄弟为i+1 \\
\end{gather*}
\]</span></p>
<h2 id="二叉树的存储表示">二叉树的存储表示</h2>
<h3 id="数组存储">数组存储</h3>
<p>极端情况，仅有右子树的二叉树，浪费空间</p>
<h3 id="链表存储">链表存储</h3>
<h4 id="二叉链表">二叉链表</h4>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215153115523.png" class title="image-20230215153115523">
<h4 id="三叉链表">三叉链表</h4>
<p>多一个指向双亲的指针</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215153146662.png" class title="image-20230215153146662">
<h4 id="二叉树链表示例">二叉树链表示例</h4>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215153258336.png" class title="image-20230215153258336">
<h2 id="二叉树遍历">二叉树遍历</h2>
<h3 id="递归遍历">递归遍历</h3>
<p>设访问根结点记作 V</p>
<p>遍历根的左子树记作 L</p>
<p>遍历根的右子树记作 R</p>
<h4 id="前序-vlr">前序 （VLR）</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(<span class="type">int</span> subroot)</span>	<span class="comment">//数组存储写法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp = subroot;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (subroot &gt; <span class="keyword">this</span>-&gt;num - <span class="number">1</span>)	</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;lst[subroot] == <span class="number">0</span>)	<span class="comment">//0没存值跳过</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;lst[subroot] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">        subroot = temp * <span class="number">2</span> + <span class="number">1</span>;		<span class="comment">//左孩子</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(subroot);</span><br><span class="line"></span><br><span class="line">        subroot = temp * <span class="number">2</span> + <span class="number">2</span>;		<span class="comment">//右孩子</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(subroot);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序-lvr">中序 （LVR）</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(<span class="type">int</span> subroot)</span>	<span class="comment">//数组存储写法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp = subroot;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (subroot &gt; <span class="keyword">this</span>-&gt;num - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subroot = temp * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">InOrder</span>(subroot);</span><br><span class="line"></span><br><span class="line">        subroot = temp;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;lst[subroot] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;lst[subroot] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">        subroot = temp * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">InOrder</span>(subroot);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="后序lrv">后序（LRV）</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(TreeNode* subroot)</span>		<span class="comment">//链表存储写法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (subroot == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">PostOrder</span>(subroot-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostOrder</span>(subroot-&gt;rchild);</span><br><span class="line">        cout &lt;&lt; subroot-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="层次遍历">层次遍历</h3>
<p>利用队列，循环条件是队列非空，依次将出队元素的左右孩子节点加入队中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lst.<span class="built_in">EnQueue</span>(*<span class="keyword">this</span>-&gt;Root);</span><br><span class="line">        <span class="keyword">while</span> (!lst.<span class="built_in">IsEmpty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode temp;</span><br><span class="line">            lst.<span class="built_in">DeQueue</span>(temp);</span><br><span class="line">            <span class="keyword">if</span> (temp.lchild != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lst.<span class="built_in">EnQueue</span>(*temp.lchild);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.rchild != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lst.<span class="built_in">EnQueue</span>(*temp.rchild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lst.<span class="built_in">PrintData</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归遍历">非递归遍历</h3>
<p>把前序中序后序改成非递归，自建一个栈存储信息</p>
<h2 id="二叉树重建">二叉树重建</h2>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215155101873.png" class title="image-20230215155101873">
<p>前序：1, 2, 5, 3, 6, 7</p>
<p>中序：2, 5, 1, 6, 3, 7</p>
<p>后序：5, 2, 6, 7, 3, 1</p>
<p>层次：1, 2, 3, 5, 6, 7</p>
<p><br></p>
<p>先序遍历第一个是根节点，后序遍历最后一个是根节点</p>
<p>层次遍历第一个是根节点</p>
<p>中序遍历，根节点左边的在左子树上，右边的在右子树上</p>
<p><br></p>
<p>根据中序遍历和其他任意一种遍历可以重建二叉树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> data, TreeNode*&amp; subroot)</span>    <span class="comment">//建树一定要对原来指针进行修改，即传递指针的引用 ********</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (subroot == <span class="literal">NULL</span>)		<span class="comment">//插入节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* newNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(data);</span><br><span class="line">            subroot = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FindNum</span>(data) &lt; <span class="built_in">FindNum</span>(subroot-&gt;data))	</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Build</span>(data, subroot-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FindNum</span>(data) &gt; <span class="built_in">FindNum</span>(subroot-&gt;data))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Build</span>(data, subroot-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Build</span>(PreOrder[i], <span class="keyword">this</span>-&gt;Root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="线索二叉树">线索二叉树</h2>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215160747349.png" class title="image-20230215160747349">
<p>此树中序遍历：B, D, A, E, C</p>
<p>此树中有5个结点，10个链域（其中4个是非空，6个为空）</p>
<p>利用N+1个空的链域存放结点直接前驱和直接后继的信息</p>
<h3 id="线索二叉树核心思想">线索二叉树核心思想</h3>
<p><strong>如果结点中leftChild指向空，则令leftChild指向当前结点的直接前驱；</strong></p>
<p><strong>如果结点中rightChild指向空，则令rightChild指向当前结点的直接后继</strong></p>
<h3 id="中序线索二叉树例">中序线索二叉树例</h3>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215161124911.png" class title="image-20230215161124911">
<p>B左孩子空，没有直接前驱，指空</p>
<p>D左孩子空，指向B</p>
<p>D右孩子空，指向A</p>
<p>E左孩子空，指向A</p>
<p>E右孩子空，指向C</p>
<p>C右孩子空，没有直接后继，指空</p>
<p><br></p>
<h3 id="表示线索二叉树">表示线索二叉树</h3>
<p>增加两个tag</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215161445641.png" class title="image-20230215161445641">
<p>ltag (或rtag) = 0，表示相应指针指示左子女（或右子女结点）</p>
<p>ltag (或rtag) = 1， 表示相应指针为前驱（或后继）线索</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215161538579.png" class title="image-20230215161538579">
<h3 id="中序线索二叉树遍历">中序线索二叉树遍历</h3>
<p>中序序列中第一个结点为二叉树最左边，左孩子为空的结点</p>
<p>查找第一个节点：从根结点开始，如果结点中ltag为0，移动到当前结点左孩子；此过程一直持续，直到结点的ltag为1</p>
<p>中序序列中最后一个结点为二叉树最右边，右孩子为空的结点</p>
<p>查最后一个节点：从根结点开始，如果结点中rtag为0，移动到当前结点右孩子；此过程一直持续，直到结点的rtag为1</p>
<h2 id="树的存储表示">树的存储表示</h2>
<h3 id="广义表表示">广义表表示</h3>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215162745910.png" class title="image-20230215162745910">
<p><strong>A(B(E, F), C, D(G)) </strong></p>
<h3 id="父指针表示">父指针表示</h3>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215162649778.png" class title="image-20230215162649778">
<h3 id="子女链表表示">子女链表表示</h3>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215162719249.png" class title="image-20230215162719249">
<h3 id="子女兄弟表示树的二叉树表示">子女兄弟表示（树的二叉树表示）</h3>
<p>节点构造</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215162856093.png" class title="image-20230215162856093">
<p>例</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215162931910.png" class title="image-20230215162931910">
<p>广义表转子女兄弟表示：</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215163507022.png" class title="image-20230215163507022">
<h2 id="森林">森林</h2>
<h3 id="森林和二叉树的转换">森林和二叉树的转换</h3>
<p>先将所有树用<strong>子女兄弟表示法</strong>化成二叉树</p>
<p>再将树连一起</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215163743943.png" class title="image-20230215163743943">
<h2 id="树与森林的遍历">树与森林的遍历</h2>
<h3 id="树的遍历">树的遍历</h3>
<h4 id="深度优先">深度优先</h4>
<h5 id="先根遍历">先根遍历</h5>
<p>树的<strong>先根遍历</strong>结果与其对应二叉树表示的<strong>前序遍历</strong>结果相同</p>
<p>可借助二叉树表示的前序遍历实现</p>
<h5 id="后根遍历">后根遍历</h5>
<p>树的<strong>后根遍历</strong>结果与其对应二叉树表示的<strong>中序遍历</strong>结果相同</p>
<p>可借助二叉树表示的中序遍历实现</p>
<h4 id="广度优先">广度优先</h4>
<p>借助队列</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215164411456.png" class title="image-20230215164411456">
<h3 id="森林的遍历">森林的遍历</h3>
<p>先根遍历、后根遍历、层次遍历</p>
<h1 id="堆">堆</h1>
<h2 id="堆基本概念">堆基本概念</h2>
<h3 id="最小堆">最小堆</h3>
<p><span class="math display">\[
\begin{gather*}
K_i\le K_{2i+1} \\
K_i\le K_{2i+2}
\end{gather*}
\]</span></p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215165321381.png" class title="image-20230215165321381">
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215165459084.png" class title="image-20230215165459084">
<h3 id="最大堆">最大堆</h3>
<p><span class="math display">\[
\begin{gather*}
K_i\ge K_{2i+1}\\
K_i\ge K_{2i+2}
\end{gather*}
\]</span></p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215165437920.png" class title="image-20230215165437920">
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215165449651.png" class title="image-20230215165449651">
<h2 id="堆的创建">堆的创建</h2>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230222093637450.png" class title="image-20230222093637450">
<h2 id="堆的特点">堆的特点</h2>
<p>树形结构</p>
<p>局部有序，堆不唯一</p>
<h1 id="哈夫曼树">哈夫曼树</h1>
<h2 id="路径">路径</h2>
<p>从树中一个结点到另一个结点之间的分支构成该两结点之间的路径</p>
<h2 id="路径长度">路径长度</h2>
<p>路径上的分支条数</p>
<h2 id="树的路径长度">树的路径长度</h2>
<p>从树的根结点到每一个结点的路径长度之和</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215165932770.png" class title="image-20230215165932770">
<h2 id="最小路径长度">最小路径长度</h2>
<p>完全二叉树和理想平衡二叉树满足要求</p>
<h2 id="扩充二叉树">扩充二叉树</h2>
<p>叶子结点带权的树</p>
<p>带权叶节点叫外结点，其余叫内节点</p>
<p>外结点的带权路径长度为T的根到该结点的路径长度与该结点上权值的乘积</p>
<p>WPL: 带权路径长度 <span class="math display">\[
\begin{gather*}
WPL = \sum_{i=1}^{n}w_i\cdot l_i\\
w_i: 外结点i带的权值\\
l_i: 外结点i到根节点的路径长度
\end{gather*}
\]</span> WPL最小的扩充二叉树为最优二叉树</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215170611589.png" class title="image-20230215170611589">
<h2 id="huffman树">Huffman树</h2>
<p><strong>带权路径长度最小的二叉树</strong>即是Huffman树，Huffman树中权值大的外结点离根结点最近</p>
<h2 id="huffman树的构造">Huffman树的构造</h2>
<p>重复以下步骤, 直到 F 中仅剩一棵树为止：</p>
<p>在 F 中选取两棵<strong>根结点的权值最小</strong>的扩充二叉树,
做为左、右子树构造一棵新的二叉树</p>
<p>置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和</p>
<p>在 F 中删去这两棵二叉树</p>
<p>把新的二叉树加入 F</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215171500149.png" class title="image-20230215171500149">
<h2 id="huffman树的应用huffman编码">Huffman树的应用：Huffman编码</h2>
<h3 id="等长编码">等长编码</h3>
<p>所有编码都等长，表示 n 个不同的字符需要 <span class="math inline">\(\log_2n\)</span>位</p>
<p>字符的使用频率相等</p>
<p>ASCII码</p>
<h3 id="不等长编码">不等长编码</h3>
<p>经常出现的字符的编码较短，不常出现的字符编码较长</p>
<h3 id="前缀编码">前缀编码</h3>
<p>任何一个字符的编码都不是另外一个字符编码的前缀</p>
<p>这种前缀特性保证了代码串被反编码时，不会有多种可能</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215171849915.png" class title="image-20230215171849915">
<p>如图是一种前缀编码，对于 “000110”，可以翻译出唯一的字符串“EEEL”</p>
<h3 id="huffman编码过程">Huffman编码过程</h3>
<p>首先，按照“权”(例如频率)将字符排为一列</p>
<p>接着，拿走前两个字符(“权”最小的两个字符)</p>
<p>再将它们标记为Huffman树的树叶，将这两个树叶标为一个分支结点的两个孩子，而该结点的权即为两树叶的权之和</p>
<p>将所得“权”放回序列，使“权”的顺序保持</p>
<p>重复上述步骤直至序列处理完毕</p>
<h1 id="哈希表">哈希表</h1>
<h2 id="概念-1">概念</h2>
<p>冲突：不同关键字，用同一个哈希函数得到相同哈希地址</p>
<p>同义词：发生冲突的关键字</p>
<h2 id="哈希函数构造方法">哈希函数构造方法</h2>
<ol type="1">
<li><p>直接定址法</p></li>
<li><p>除留余数法</p></li>
<li><p>数字分析法</p></li>
<li><p>平方取中法</p></li>
<li><p>折叠法</p></li>
<li><p>随机数法</p></li>
</ol>
<h2 id="冲突处理">冲突处理</h2>
<p>（1）开放定址法（开地址法）：线性探测、二次探测、伪随机探测</p>
<p>（2）链地址法（拉链法）</p>
<p>（3）再哈希法（双哈希函数法）</p>
<p>（4）建立一个公共溢出区</p>
<h2 id="哈希表查找分析">哈希表查找分析</h2>
<p>哈希查找的速度是否为真正的O(1) ？</p>
<p>不是</p>
<p>由于冲突的产生，使得哈希表的查找过程仍然要进行比较，用平均查找长度ASL和装填因子α来衡量</p>
<p>装填因子α = 表中填入的记录数 / 哈希表的长度</p>
<p>α 越小，发生冲突的可能性越小</p>
<p>反之，发生冲突的可能性越大</p>
<h1 id="搜索结构">搜索结构</h1>
<h2 id="搜索的概念">搜索的概念</h2>
<p>通常称用于搜索的数据集合为搜索结构，它是由同一数据类型的对象(或记录)组成</p>
<p>在每个对象中有若干属性，其中有一个属性，其值可唯一地标识这个对象，称为关键码。</p>
<p>使用基于关键码的搜索，搜索结果应是唯一的。</p>
<h2 id="静态搜索结构">静态搜索结构</h2>
<h3 id="静态搜索表">静态搜索表</h3>
<h3 id="顺序搜索">顺序搜索</h3>
<h3 id="二分搜索">二分搜索</h3>
<h2 id="二叉搜索树二叉排序树二叉查找树">二叉搜索树（二叉排序树，二叉查找树）</h2>
<h3 id="性质">性质</h3>
<p>每个结点都有一个作为搜索依据的关键码(key)，<strong>所有结点的关键码互不相同</strong></p>
<p>左子树（如果非空）上所有结点的关键码都小于根结点的关键码</p>
<p>右子树（如果非空）上所有结点的关键码都大于根结点的关键码</p>
<p>左子树和右子树也是二叉搜索树</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215194052388.png" class title="image-20230215194052388">
<p>如果对一棵二叉搜索树进行中序遍历，可以按从小到大的顺序，将各结点关键码排列起来，所以也称二叉搜索树为二叉排序树</p>
<h3 id="插入">插入</h3>
<p>插入元素前要先检查元素在树中是否存在</p>
<h3 id="删除">删除</h3>
<p>删除叶结点，只需将其双亲结点指向它的指针清零，再释放它即可</p>
<p>被删结点右子树为空，可以拿它的左子女结点顶替它的位置，再释放它</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215194514450.png" class title="image-20230215194514450">
<p>被删结点左子树为空，可以拿它的右子女结点顶替它的位置，再释放它</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215194532431.png" class title="image-20230215194532431">
<p>被删结点左、右子树都不为空，可以在它的右子树中寻找中序下的第一个结点(关键码最小),用它的值填补到被删结点中</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215194653084.png" class title="image-20230215194653084">
<h2 id="avl树">AVL树</h2>
<h3 id="性质-1">性质</h3>
<p>一棵 AVL 树或者是空树，或者是具有下列性质的二叉搜索树</p>
<p>它的左子树和右子树都是 AVL
树，且<strong>左子树和右子树的高度之差的绝对值不超过1</strong></p>
<p>h为深度，求树最少有多少结点，可以写为递归式</p>
<p><span class="math inline">\(N_h=N_{h-1}+N_{h-2}+1\)</span></p>
<p>高度为h的平衡二叉树，节点个数为高度为h-1的平衡二叉树节点个数+高度为h-2的平衡二叉树节点个数+1</p>
<h3 id="平衡因子">平衡因子</h3>
<p>每个结点附加一个数字，给出该结点<strong>右子树的高度减去左子树的高度</strong>所得的高度差，这个数字即为结点的平衡因子bf</p>
<p>AVL树任一结点平衡因子只能取 -1, 0, 1</p>
<p>如果一个结点的平衡因子的绝对值大于1，则这棵二叉搜索树就失去了平衡，不再是AVL树</p>
<p>如果一棵有 n 个结点的二叉搜索树是高度平衡的，其高度可保持在<span class="math inline">\(O(\log_2n)\)</span>，平均搜索长度也可保持在<span class="math inline">\(O(\log_2n)\)</span></p>
<h3 id="平衡化旋转">平衡化旋转</h3>
<p>书上讲太复杂了，有个视频可以很好理解 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16m4y1F7do">平衡二叉树的调整</a></p>
<p>注意要顺着插入的新节点路径往上找，找与不平衡节点最近的三个节点，调整即可</p>
<h4 id="ll">LL</h4>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215195532038.png" class title="image-20230215195532038">
<h4 id="rr">RR</h4>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215195601020.png" class title="image-20230215195601020">
<h4 id="rl">RL</h4>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215195623639.png" class title="image-20230215195623639">
<h4 id="lr">LR</h4>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215195654762.png" class title="image-20230215195654762">
<h3 id="元素删除">元素删除</h3>
<p>注意树的调整</p>
<h1 id="图">图</h1>
<h2 id="概念-2">概念</h2>
<h3 id="有向图">有向图</h3>
<p><span class="math inline">\(Path (x, y)\)</span>表示从 x 到 y
的一条单向通路, 它是有方向的</p>
<p><span class="math inline">\(Graph＝( V, E )\)</span></p>
<p>其中<span class="math inline">\(V = \{ x | x \in
某个数据对象\}\)</span> 是顶点的有穷非空集合</p>
<p><span class="math inline">\(E = \{&lt;x, y&gt; | x, y \in V
\&amp;\&amp; Path (x, y)
\}\)</span>是顶点之间关系的有穷集合，也叫做边(edge)集合</p>
<h3 id="无向图">无向图</h3>
<p><span class="math inline">\(Graph＝( V, E )\)</span></p>
<p>其中<span class="math inline">\(V = \{ x | x \in
某个数据对象\}\)</span> 是顶点的有穷非空集合</p>
<p><span class="math inline">\(E = \{&lt;x, y&gt; | x, y \in V
\}\)</span>是顶点之间关系的有穷集合，也叫做边(edge)集合</p>
<h3 id="完全图">完全图</h3>
<p>有 <span class="math inline">\(n\)</span> 个顶点的无向图有 $n(n-1)/2
$条边, 则此图为完全无向图</p>
<p>有 <span class="math inline">\(n\)</span> 个顶点的有向图有$n(n-1)
$条边, 则此图为完全有向图</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215201123807.png" class title="image-20230215201123807">
<p>完全图中边数达到最大</p>
<h3 id="带权图">带权图</h3>
<p>边带权</p>
<h3 id="子图">子图</h3>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215201236812.png" class title="image-20230215201236812">
<h3 id="顶点的度">顶点的度</h3>
<p>一个顶点v的度是<strong>与它相关联的边的条数</strong>。记作TD(v)</p>
<p>在有向图中, 顶点的度等于该顶点的入度与出度之和</p>
<p>其中，顶点v的入度是以v为终点的有向边的条数，记作indeg(v)</p>
<p>顶点v的出度是以v为始点的有向边的条数, 记作outdeg(v)</p>
<h3 id="路径-1">路径</h3>
<p>在图 <span class="math inline">\(G＝(V, E)\)</span> 中, 若从顶点
<span class="math inline">\(v_i\)</span> 出发, 沿一些边经过一些顶点
<span class="math inline">\(v_{p1}, v_{p2}, …,
v_{pm}\)</span>，到达顶点<span class="math inline">\(v_j\)</span>，则称顶点序列 $ (v_i，v_{p1}，v_{p2}
…v_{pm}， v_j) $ 为从顶点<span class="math inline">\(v_i\)</span> 到顶点
<span class="math inline">\(v_j\)</span> 的路径。它经过的边<span class="math inline">\((v_i, v_{p1})、(v_{p1}, v_{p2})、...、(v_{pm},
v_j)\)</span> 应是属于<span class="math inline">\(E\)</span>的边。</p>
<h3 id="简单路径">简单路径</h3>
<p>路径上各顶点不重复</p>
<h3 id="回路">回路</h3>
<p>起点与终点重合</p>
<h3 id="连通图和连通分量">连通图和连通分量</h3>
<p>在<strong>无向图</strong>中, 若从顶点v1到顶点v2有路径,
则称顶点v1与v2是连通的</p>
<p>如果图中任意一对顶点都是连通的, 则称此图是连通图</p>
<p>非连通图的极大连通子图叫做连通分量</p>
<h3 id="强连通图和强连通分量">强连通图和强连通分量</h3>
<p>在<strong>有向图</strong>中, 若对于每一对顶点vi和vj,
都存在一条从vi到vj和从vj到vi的路径, 则称此图是强连通图</p>
<p>非强连通图的极大强连通子图叫做强连通分量</p>
<h3 id="生成树">生成树</h3>
<p>一个连通图的生成树是其极小连通子图，在 n 个顶点的情形下，有 n-1
条边</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215202143761.png" class title="image-20230215202143761">
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215202151187.png" class title="image-20230215202151187">
<h2 id="图的存储结构">图的存储结构</h2>
<h3 id="邻接矩阵">邻接矩阵</h3>
<p>设图$ A = (V, E) $是一个有 n 个顶点的图, 图的邻接矩阵是一个二维数组
<span class="math inline">\(A.edge[n][n]\)</span></p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215202449206.png" class title="image-20230215202449206">
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215202306701.png" class title="image-20230215202306701">
<p>无向图的邻接矩阵是对称的</p>
<p>有向图的邻接矩阵可能是不对称的</p>
<p>在有向图中, 统计第 i 行 1 的个数可得顶点 i 的出度，统计第 j 列 1
的个数可得顶点 j 的入度</p>
<p>在无向图中, 统计第 i 行 (列) 1 的个数可得顶点 i 的度</p>
<h3 id="邻接表">邻接表</h3>
<h4 id="无向图-1">无向图</h4>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215202726061.png" class title="image-20230215202726061">
<p>统计某顶点对应边链表中结点个数，可得该顶点的度</p>
<p>某条边<span class="math inline">\((v_i,
v_j)\)</span>在邻接表中有两个边结点，分别在第 i 个顶点和第 j
个顶点对应的边链表中</p>
<h4 id="有向图-1">有向图</h4>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215202911683.png" class title="image-20230215202911683">
<h4 id="带权图-1">带权图</h4>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215203016926.png" class title="image-20230215203016926">
<h3 id="邻接矩阵和邻接表">邻接矩阵和邻接表</h3>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215203117392.png" class title="image-20230215203117392">
<h2 id="图的遍历">图的遍历</h2>
<p>为了避免重复访问，可设置一个标志顶点是否被访问过的辅助数组 visited [
]</p>
<h3 id="深度优先搜索">深度优先搜索</h3>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215203416520.png" class title="image-20230215203416520">
<h3 id="广度优先搜索">广度优先搜索</h3>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215203501188.png" class title="image-20230215203501188">
<h2 id="最短路">最短路</h2>
<p>边上<strong>权值非负</strong>情形的单源最短路径问题</p>
<p>​ <strong>— Dijkstra算法</strong></p>
<p>边上权值为任意值的单源最短路径问题</p>
<p>​ — Bellman和Ford算法（了解即可）</p>
<p>所有顶点之间的最短路径</p>
<p>​ — Floyd算法（了解即可）</p>
<p>Dijkstra算法：优先队列（也可排序），根节点到各节点最短路径数组（每次更新），标记数组</p>
<p>从根节点出发，更新根节点到各点最短路径数组</p>
<p>选取路径数组中最短的路径，以及节点O，通过节点O更新最短路径数组（新的最短路径为节点O到对应节点的路径+根节点到节点O的路径），跟原最短路径数组对比，若更小，则更新</p>
<p>循环重复该过程，直到队列空</p>
<h2 id="最小生成树">最小生成树</h2>
<p>图 G 的生成树是一棵包含 G
的所有顶点的树，树上所有权值总和表示代价</p>
<p>那么在 G 的所有的生成树中代价最小的生成树称为图 G 的 最小生成树(简称
MST)</p>
<h2 id="最小生成树算法">最小生成树算法</h2>
<h3 id="prime算法">Prime算法</h3>
<p>从起点出发，选择与起点距离最短的点（权最小）加入生成树顶点集合U中</p>
<p>每次找最短路：<strong>条件是起点在U中，终点不在U中</strong><del>（Debug的终点）</del></p>
<p>直到所有点加入U中为止</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Prim:&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="type">int</span>** mat = <span class="keyword">new</span> <span class="type">int</span>*[n];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				mat[i] = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">				&#123;</span><br><span class="line">					mat[i][j] = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;								<span class="comment">//初始化二维数组</span></span><br><span class="line">		</span><br><span class="line">			<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">			<span class="type">int</span> MinEdge = defaultsize;</span><br><span class="line">			<span class="type">int</span> MinStart = <span class="number">0</span>;</span><br><span class="line">			<span class="type">int</span> MinFinal = <span class="number">0</span>;</span><br><span class="line">			MyQueue que;</span><br><span class="line">			<span class="function">EdgeNode <span class="title">tmp</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			flag[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (num != n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">PrintMap</span>(mat);</span><br><span class="line">				cout &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)				<span class="comment">//在出队节点的终点里寻找边，最开始为0</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (Matrix[MinFinal][i] == <span class="number">0</span>)		<span class="comment">//边长为0跳过</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (flag[i] == <span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="function">EdgeNode <span class="title">temp</span><span class="params">(Matrix[MinFinal][i], MinFinal, i)</span></span>;</span><br><span class="line">					que.<span class="built_in">EnQueue</span>(temp);					<span class="comment">//边长不为0入队</span></span><br><span class="line">				&#125;</span><br><span class="line">				que.<span class="built_in">Sort</span>();							    <span class="comment">//给队列排序，充当优先队列作用</span></span><br><span class="line">				<span class="comment">//que.Print();</span></span><br><span class="line">				<span class="keyword">while</span> (num != n)						<span class="comment">//↓↓↓↓↓↓↓↓↓极其重要↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line">				&#123;</span><br><span class="line">					que.<span class="built_in">DeQueue</span>(tmp);					<span class="comment">//出队，此时要保证终点不在集合里，即flag为0，debug的终点</span></span><br><span class="line">					<span class="keyword">if</span> (que.<span class="built_in">isEmpty</span>())					<span class="comment">//队空退出</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (flag[tmp.<span class="keyword">final</span>] == <span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				MinFinal = tmp.<span class="keyword">final</span>;</span><br><span class="line">				MinStart = tmp.start;</span><br><span class="line">				MinEdge = tmp.length;</span><br><span class="line">				mat[MinStart][MinFinal] = MinEdge;</span><br><span class="line">				mat[MinFinal][MinStart] = MinEdge;		<span class="comment">//无向图存2次</span></span><br><span class="line">				flag[MinFinal] = <span class="number">1</span>;						<span class="comment">//更新flag</span></span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h3 id="kruskal算法">Kruskal算法</h3>
<p>现将所有边按从小到大排序，依次选择最小的构成树，条件是<strong>属于不同连通分量</strong>，直至所有边全加入树</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215220953811.png" class title="image-20230215220953811">
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215220333697.png" class title="image-20230215220333697">
<p>用<strong>并查集</strong>判断同一条边关联的两个顶点是否属于同一连通分量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>		<span class="comment">//并查集判断是否属于同一连通分量</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="type">int</span> i = x;</span><br><span class="line">			<span class="keyword">while</span> (flag[i] != i)	<span class="comment">//查出i号的Boss是谁</span></span><br><span class="line">			&#123;</span><br><span class="line">				i = flag[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> j = y;</span><br><span class="line">			<span class="keyword">while</span> (flag[j] != j)	<span class="comment">//查出j号的Boss是谁</span></span><br><span class="line">			&#123;</span><br><span class="line">				j = flag[j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> i == j;			<span class="comment">//i的Boss == j的Boss，则同一连通分量</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getBoss</span><span class="params">(<span class="type">int</span> x)</span>		<span class="comment">//与上面相同的函数</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (flag[x] != x)</span><br><span class="line">			&#123;</span><br><span class="line">				x = flag[x];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> x;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Kruskal:&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="type">int</span>** mat = <span class="keyword">new</span> <span class="type">int</span>* [n];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				mat[i] = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">				&#123;</span><br><span class="line">					mat[i][j] = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;								<span class="comment">//初始化二维数组</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				flag[i] = i;				<span class="comment">//用于并查集的数组</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			EdgeNode lst[defaultsize];</span><br><span class="line">			<span class="type">int</span> Iterator = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++)	<span class="comment">//只考虑其中一个边</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (Matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="function">EdgeNode <span class="title">temp</span><span class="params">(Matrix[i][j], i, j)</span></span>;</span><br><span class="line">					lst[Iterator] = temp;</span><br><span class="line">					Iterator++;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;								<span class="comment">//生成lst</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Iterator<span class="number">-1</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Iterator-i<span class="number">-1</span>; j++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (lst[j].length &gt; lst[j + <span class="number">1</span>].length)</span><br><span class="line">					&#123;</span><br><span class="line">						EdgeNode temp = lst[j];</span><br><span class="line">						lst[j] = lst[j + <span class="number">1</span>];</span><br><span class="line">						lst[j + <span class="number">1</span>] = temp;</span><br><span class="line"> 					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;								<span class="comment">//lst排序</span></span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">			<span class="type">int</span> it = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (num != n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">PrintMap</span>(mat);							<span class="comment">//打印矩阵</span></span><br><span class="line">				cout &lt;&lt; endl;</span><br><span class="line">				num++;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">while</span> (num != n)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> len = lst[it].length;</span><br><span class="line">					<span class="type">int</span> start = lst[it].start;</span><br><span class="line">					<span class="type">int</span> <span class="keyword">final</span> = lst[it].<span class="keyword">final</span>;</span><br><span class="line">					<span class="keyword">if</span> (!<span class="built_in">isConnected</span>(start, <span class="keyword">final</span>))		<span class="comment">//如果lst中最小边起点终点不相连</span></span><br><span class="line">					&#123;</span><br><span class="line">						mat[start][<span class="keyword">final</span>] = len;</span><br><span class="line">						mat[<span class="keyword">final</span>][start] = len;		<span class="comment">//输出矩阵更新</span></span><br><span class="line">						flag[<span class="built_in">getBoss</span>(<span class="keyword">final</span>)] = start;	<span class="comment">//更新flag，终点的顶点改为起点</span></span><br><span class="line">						it++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span>								<span class="comment">//如果lst中最小边起点终点相连，跳过</span></span><br><span class="line">					&#123;</span><br><span class="line">						it++;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用边表示活动的网络aov网络">用边表示活动的网络（AOV网络）</h2>
<h3 id="aov网络概念">AOV网络概念</h3>
<p>可以用有向图表示一个工程</p>
<p>用顶点表示活动，用有向边&lt;Vi, Vj&gt;表示活动Vi 必须先于活动Vj
进行</p>
<p>这种有向图叫做顶点表示活动的AOV网络 (Activity On Vertices)</p>
<p>在AOV网络中<strong>不能出现有向回路</strong>, 即有向环</p>
<p>如果出现了有向环，则意味着某项活动应以自己作为先决条件</p>
<p>对给定的AOV网络，必须先判断它是否存在有向环</p>
<h3 id="检测有向环拓扑排序">检测有向环：拓扑排序</h3>
<p>如果通过拓扑排序能将AOV网络的所有顶点都排入一个拓扑有序的序列中,
则该网络中必定不会出现有向环</p>
<p>拓扑序列不唯一</p>
<h3 id="拓扑排序实现">拓扑排序实现</h3>
<p>在AOV网络中选一个<strong>没有直接前驱</strong>的顶点（单独一个节点也算没有前驱，如下图C3）,
并输出</p>
<p>从图中删去该顶点, 同时删去所有它发出的有向边</p>
<p>重复以上步骤，直至全部顶点均已输出，拓扑有序序列形成，拓扑排序完成</p>
<p>或图中还有未输出的顶点, 但已跳出处理循环，说明图中还剩下一些顶点,
它们都有直接前驱，这时网络中必存在有向环</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215222445048.png" class title="image-20230215222445048">
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215222551776.png" class title="image-20230215222551776">
<h2 id="用顶点表示活动的网络aoe网络">用顶点表示活动的网络（AOE网络）</h2>
<h3 id="aoe网络概念">AOE网络概念</h3>
<p>在<strong>无有向环</strong>的带权有向图中</p>
<p>用有向边表示一个工程中的活动 (Activity)</p>
<p>用边上权值表示活动持续时间 (Duration)</p>
<p>用顶点表示事件 (Event)</p>
<p>则这样的有向图叫做用边表示活动的网络, 简称 AOE ( Activity On Edges )
网络</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215222751278.png" class title="image-20230215222751278">
<p>完成整个工程所需的时间取决于从源点到汇点的<strong>最长路径长度</strong>,
即在这条路径上所有活动的持续时间之和</p>
<p>这条路径长度最长的路径就叫做关键路径(Critical Path)</p>
<p>要找出关键路径，必须找出关键活动,
即不按期完成就会影响整个工程完成的活动</p>
<p>关键路径上的所有活动都是关键活动，因此, 只要找到了关键活动,
就可以找到关键路径</p>
<h3 id="与关键活动有关的量">与关键活动有关的量</h3>
<p>分清楚活动 $ a_k $ 和事件 <span class="math inline">\(V_i\)</span></p>
<p>活动 $a_k $ 是箭头，事件 <span class="math inline">\(V_i\)</span>
是节点</p>
<p>事件 <span class="math inline">\(V_i\)</span>
的<strong>最早可能开始时间</strong> <span class="math inline">\(V_e(i)\)</span> ，即从源点 <span class="math inline">\(V_0\)</span> 到顶点 <span class="math inline">\(V_i\)</span> 的<strong>最长路径长度</strong></p>
<p>事件<span class="math inline">\(V_i\)</span> 的最迟允许开始时间 <span class="math inline">\(V_l(i)\)</span> 是在保证汇点 <span class="math inline">\(V_{n-1}\)</span> 在 <span class="math inline">\(V_e(n-1)\)</span> 时刻完成的前提下，事件<span class="math inline">\(V_i\)</span> 允许的最迟开始时间</p>
<p>活动 <span class="math inline">\(a_k\)</span>
的<strong>最早可能开始时间 <span class="math inline">\(e[k]\)</span></strong>，设活动<span class="math inline">\(a_k\)</span> 在边<span class="math inline">\(&lt;V_i, V_j&gt;\)</span>上，<span class="math inline">\(e[k] = V_e(i)\)</span></p>
<p>活动 <span class="math inline">\(a_k\)</span> 的最迟允许开始时间
<span class="math inline">\(l[k]\)</span> 是在不会引起时间延误的前提下,
该活动允许的最迟开始时间，<span class="math inline">\(l[k] =
V_l(j)-dur(&lt;i, j&gt;)\)</span></p>
<p>时间余量 <span class="math inline">\(l[k]-e[k]\)</span> 表示活动<span class="math inline">\(a_k\)</span>的松弛时间，<span class="math inline">\(l[k] = e[k]\)</span>表示活动 <span class="math inline">\(a_k\)</span> 是没有时间余量的关键活动</p>
<p><strong>为找出关键活动, 需要求各个活动的 <span class="math inline">\(e[k]\)</span> 与 <span class="math inline">\(l[k]\)</span>，以判别是否 <span class="math inline">\(l[k] == e[k]\)</span></strong></p>
<h3 id="计算">计算</h3>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215231905517.png" class title="image-20230215231905517">
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215231912175.png" class title="image-20230215231912175">
<p>这两个递推公式的计算必须分别在<strong>拓扑有序</strong>及<strong>逆拓扑有序</strong>的前提下进行</p>
<p><span class="math inline">\(e[k] = V_e(i)\)</span>（<span class="math inline">\(a_k\)</span>在边<span class="math inline">\(&lt;V_i, V_j&gt;\)</span>上）</p>
<p><span class="math inline">\(l[k] = V_l(j)-dur(&lt;i,
j&gt;)\)</span>（<span class="math inline">\(a_k\)</span>在边<span class="math inline">\(&lt;V_i, V_j&gt;\)</span>上，即指向节点的<span class="math inline">\(V_l - a_k\)</span>）</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215222751278.png" class title="image-20230215222751278">
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215233700409.png" class title="image-20230215233700409">
<p>这个例子不明显，看看书上的例子</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230215234510730.png" class title="image-20230215234510730">
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/QQ%E5%9B%BE%E7%89%872023021523421111.jpg" class title="QQ图片2023021523421111">
<p>如上图</p>
<p><span class="math display">\[
\begin{align*}
l(6)&amp;=V_l(5)-a_6\\
&amp;=10-2\\
&amp;=8
\end{align*}
\]</span></p>
<h1 id="排序">排序</h1>
<h2 id="概念-3">概念</h2>
<h3 id="排序算法稳定性">排序算法稳定性</h3>
<p>如果在元素序列中有两个元素r[i]和r[j], 它们的排序码 k[i] == k[j] ,
且在排序之前, 元素r[i]排在r[j]前面</p>
<p>如果在排序之后, 元素r[i]仍在元素r[j]的前面, 则称这个排序方法是稳定的,
否则称这个排序方法是不稳定的</p>
<h3 id="内排序与外排序">内排序与外排序</h3>
<p>内排序是指在排序期间<strong>数据元素全部存放在内存</strong>的排序</p>
<p>外排序是指在排序期间全部元素个数太多，不能同时存放在内存，必须根据排序过程的要求，不断在内、外存之间移动的排序</p>
<h2 id="插入排序">插入排序</h2>
<h3 id="基本思想">基本思想</h3>
<p>每步将一个待排序的元素，按其排序码大小，插入到前面已经排好序的一组元素的适当位置上,
直到元素全部插入为止</p>
<h3 id="直接插入排序">直接插入排序</h3>
<h3 id="折半插入排序">折半插入排序</h3>
<h3 id="希尔排序">希尔排序</h3>
<p>空间复杂度为<span class="math inline">\(O(1)\)</span></p>
<h2 id="交换排序">交换排序</h2>
<h3 id="基本思想-1">基本思想</h3>
<p>两两比较待排序元素的排序码，如果发生逆序(即排列顺序与排序后的次序正好相反)，则交换之，直到所有元素都排好序为止</p>
<h3 id="冒泡排序">冒泡排序</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">Swap</span>(&amp;a[j],&amp;a[j+<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序">快速排序</h3>
<p>快排是递归的</p>
<h2 id="选择排序">选择排序</h2>
<h3 id="基本思想-2">基本思想</h3>
<p>每一趟 (例如第 i 趟, i = 0, 1, …, n-2) 在后面 n-i
个待排序元素中选出排序码最小的元素，作为有序元素序列的第 i 个元素</p>
<p>待到第 n-2 趟完，待排序元素只剩下1个, 就不用再选了</p>
<h3 id="直接选择排序">直接选择排序</h3>
<h3 id="堆排序">堆排序</h3>
<h2 id="归并排序">归并排序</h2>
<h3 id="基本思想-3">基本思想</h3>
<p>将两个或两个以上的有序表合并成一个新的有序表</p>
<h2 id="基数排序">基数排序</h2>
<h3 id="基本思想-4">基本思想</h3>
<p>基数排序是采用“分配”与“收集”的办法，用对<strong>多排序码</strong>进行排序的思想，实现对单排序码进行排序的方法</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230216205811235.png" class title="image-20230216205811235">
<h3 id="最高位优先msd">最高位优先(MSD)</h3>
<p>先根据最高位排序码 <span class="math inline">\(K^1\)</span>排序,
得到若干元素组, 元素组中各元素都有相同排序码 <span class="math inline">\(K^1\)</span></p>
<p>再分别对每组中元素根据排序码 <span class="math inline">\(K^2\)</span>
进行排序, 按 <span class="math inline">\(K^2\)</span> 值的不同,
再分成若干个更小的子组, 每个子组中的元素具有相同的 <span class="math inline">\(K^1\)</span>和 <span class="math inline">\(K^2\)</span>值</p>
<p>依此重复, 直到对排序码 <span class="math inline">\(K^d\)</span>完成排序为止</p>
<p>最后, 把所有子组中的元素依次连接起来，就得到一个有序的元素序列</p>
<h3 id="最低位优先lsd">最低位优先(LSD)</h3>
<p>首先依据最低位排序码 <span class="math inline">\(K^d\)</span>对所有元素进行一趟排序</p>
<p>再依据次低位排序码 <span class="math inline">\(K^{d-1}\)</span>对上一趟排序的结果再排序</p>
<p>依次重复，直到依据排序码 <span class="math inline">\(K^1\)</span>最后一趟排序完成，就可以得到一个有序的序列</p>
<p>使用这种排序方法对每一个排序码进行排序时，不需要再分组，而是整个元素组都参加排序</p>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230216212357460.png" class title="image-20230216212357460">
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230216212416333.png" class title="image-20230216212416333">
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230216212433083.png" class title="image-20230216212433083">
<h2 id="排序对比">排序对比</h2>
<img src="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/image-20230216210306427.png" class title="image-20230216210306427">
<h1 id="考后总结">考后总结</h1>
<p>哈希表竟然出大题了，这下嘻哈了</p>
<p>编程题出的是链表和二叉搜索树，还是比较容易实现的</p>
<p>填空题更是重量级，考高中的排列组合就不说了，竟然考手算递归，阿克曼函数归(3,3)，问题是还有人归出来了，太哈人了</p>
<p>不过考Ackermann(3,3)应该就是看你能不能即时放弃吧，毕竟这玩意归个(4,3)能把计算机递归瘸了</p>
<p><br></p>
<p><br></p>
<p><br></p>
<hr>
<h1 id="参考资料">参考资料</h1>
<p><a href="202.117.179.110">数据结构课程PPT</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16m4y1F7do">AVL树调整</a></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%8D%E4%B9%A0/">复习</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/16/Hexo%E5%8D%9A%E5%AE%A2LaTeX%E5%85%AC%E5%BC%8F%E7%9A%84%E6%98%BE%E7%A4%BA/" title="Hexo博客LaTeX公式的显示"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hexo博客LaTeX公式的显示</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/Java%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="Java复习整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java复习整理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/12/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/Java%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="Java复习整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-12</div><div class="title">Java复习整理</div></div></a></div><div><a href="/2023/02/16/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="操作系统复习整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-16</div><div class="title">操作系统复习整理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">WinkySpeed</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WinkySpeed"><i class="fab fa-github"></i><span>GitHub</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">数据结构复习整理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%AE%BA"><span class="toc-number">2.</span> <span class="toc-text">概论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">逻辑结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84-1"><span class="toc-number">3.1.</span> <span class="toc-text">逻辑结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#section"><span class="toc-number">3.4.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">4.1.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">4.1.1.</span> <span class="toc-text">表达式求值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%80%92%E5%BD%92"><span class="toc-number">4.1.2.</span> <span class="toc-text">栈和递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%B7%A5%E4%BD%9C%E6%A0%88"><span class="toc-number">4.1.3.</span> <span class="toc-text">递归工作栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">4.2.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.2.1.</span> <span class="toc-text">循环队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%BA%94%E7%94%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">队列应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%B2%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">数组，串和广义表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5"><span class="toc-number">5.1.</span> <span class="toc-text">特殊矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9"><span class="toc-number">5.2.</span> <span class="toc-text">特殊矩阵的压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9"><span class="toc-number">5.2.1.</span> <span class="toc-text">对称矩阵的压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9"><span class="toc-number">5.2.2.</span> <span class="toc-text">三对角矩阵的压缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="toc-number">5.3.</span> <span class="toc-text">稀疏矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">5.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">5.3.2.</span> <span class="toc-text">稀疏矩阵的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BD%AC%E7%BD%AE"><span class="toc-number">5.3.3.</span> <span class="toc-text">稀疏矩阵的转置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-number">5.4.</span> <span class="toc-text">广义表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">树基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.2.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%89%B9%E7%82%B9"><span class="toc-number">6.2.1.</span> <span class="toc-text">二叉树特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A8"><span class="toc-number">6.2.2.</span> <span class="toc-text">二叉树性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.2.3.</span> <span class="toc-text">满二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.2.4.</span> <span class="toc-text">完全二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A8"><span class="toc-number">6.2.5.</span> <span class="toc-text">完全二叉树性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">6.3.</span> <span class="toc-text">二叉树的存储表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8"><span class="toc-number">6.3.1.</span> <span class="toc-text">数组存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8"><span class="toc-number">6.3.2.</span> <span class="toc-text">链表存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">二叉链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="toc-number">6.3.2.2.</span> <span class="toc-text">三叉链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%93%BE%E8%A1%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.3.2.3.</span> <span class="toc-text">二叉树链表示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-number">6.4.</span> <span class="toc-text">二叉树遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">6.4.1.</span> <span class="toc-text">递归遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F-vlr"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">前序 （VLR）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F-lvr"><span class="toc-number">6.4.1.2.</span> <span class="toc-text">中序 （LVR）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8Flrv"><span class="toc-number">6.4.1.3.</span> <span class="toc-text">后序（LRV）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">6.4.2.</span> <span class="toc-text">层次遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">6.4.3.</span> <span class="toc-text">非递归遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%87%8D%E5%BB%BA"><span class="toc-number">6.5.</span> <span class="toc-text">二叉树重建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.6.</span> <span class="toc-text">线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">6.6.1.</span> <span class="toc-text">线索二叉树核心思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BE%8B"><span class="toc-number">6.6.2.</span> <span class="toc-text">中序线索二叉树例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.6.3.</span> <span class="toc-text">表示线索二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-number">6.6.4.</span> <span class="toc-text">中序线索二叉树遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">6.7.</span> <span class="toc-text">树的存储表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">6.7.1.</span> <span class="toc-text">广义表表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E6%8C%87%E9%92%88%E8%A1%A8%E7%A4%BA"><span class="toc-number">6.7.2.</span> <span class="toc-text">父指针表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%A5%B3%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">6.7.3.</span> <span class="toc-text">子女链表表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%A5%B3%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%A0%91%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A1%A8%E7%A4%BA"><span class="toc-number">6.7.4.</span> <span class="toc-text">子女兄弟表示（树的二叉树表示）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97"><span class="toc-number">6.8.</span> <span class="toc-text">森林</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.8.1.</span> <span class="toc-text">森林和二叉树的转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">6.9.</span> <span class="toc-text">树与森林的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">6.9.1.</span> <span class="toc-text">树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88"><span class="toc-number">6.9.1.1.</span> <span class="toc-text">深度优先</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E6%A0%B9%E9%81%8D%E5%8E%86"><span class="toc-number">6.9.1.1.1.</span> <span class="toc-text">先根遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E6%A0%B9%E9%81%8D%E5%8E%86"><span class="toc-number">6.9.1.1.2.</span> <span class="toc-text">后根遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88"><span class="toc-number">6.9.1.2.</span> <span class="toc-text">广度优先</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">6.9.2.</span> <span class="toc-text">森林的遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">7.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">堆基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%A0%86"><span class="toc-number">7.1.1.</span> <span class="toc-text">最小堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%A0%86"><span class="toc-number">7.1.2.</span> <span class="toc-text">最大堆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">7.2.</span> <span class="toc-text">堆的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">7.3.</span> <span class="toc-text">堆的特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text">哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84"><span class="toc-number">8.1.</span> <span class="toc-text">路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="toc-number">8.2.</span> <span class="toc-text">路径长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="toc-number">8.3.</span> <span class="toc-text">树的路径长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="toc-number">8.4.</span> <span class="toc-text">最小路径长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%85%85%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.5.</span> <span class="toc-text">扩充二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#huffman%E6%A0%91"><span class="toc-number">8.6.</span> <span class="toc-text">Huffman树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#huffman%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">8.7.</span> <span class="toc-text">Huffman树的构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#huffman%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8huffman%E7%BC%96%E7%A0%81"><span class="toc-number">8.8.</span> <span class="toc-text">Huffman树的应用：Huffman编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E9%95%BF%E7%BC%96%E7%A0%81"><span class="toc-number">8.8.1.</span> <span class="toc-text">等长编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E7%AD%89%E9%95%BF%E7%BC%96%E7%A0%81"><span class="toc-number">8.8.2.</span> <span class="toc-text">不等长编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%BC%96%E7%A0%81"><span class="toc-number">8.8.3.</span> <span class="toc-text">前缀编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#huffman%E7%BC%96%E7%A0%81%E8%BF%87%E7%A8%8B"><span class="toc-number">8.8.4.</span> <span class="toc-text">Huffman编码过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">9.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">9.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">哈希函数构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86"><span class="toc-number">9.3.</span> <span class="toc-text">冲突处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9F%A5%E6%89%BE%E5%88%86%E6%9E%90"><span class="toc-number">9.4.</span> <span class="toc-text">哈希表查找分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%84"><span class="toc-number">10.</span> <span class="toc-text">搜索结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">10.1.</span> <span class="toc-text">搜索的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%84"><span class="toc-number">10.2.</span> <span class="toc-text">静态搜索结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%90%9C%E7%B4%A2%E8%A1%A8"><span class="toc-number">10.2.1.</span> <span class="toc-text">静态搜索表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2"><span class="toc-number">10.2.2.</span> <span class="toc-text">顺序搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="toc-number">10.2.3.</span> <span class="toc-text">二分搜索</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">10.3.</span> <span class="toc-text">二叉搜索树（二叉排序树，二叉查找树）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-number">10.3.1.</span> <span class="toc-text">性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">10.3.2.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">10.3.3.</span> <span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#avl%E6%A0%91"><span class="toc-number">10.4.</span> <span class="toc-text">AVL树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8-1"><span class="toc-number">10.4.1.</span> <span class="toc-text">性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90"><span class="toc-number">10.4.2.</span> <span class="toc-text">平衡因子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E5%8C%96%E6%97%8B%E8%BD%AC"><span class="toc-number">10.4.3.</span> <span class="toc-text">平衡化旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ll"><span class="toc-number">10.4.3.1.</span> <span class="toc-text">LL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rr"><span class="toc-number">10.4.3.2.</span> <span class="toc-text">RR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rl"><span class="toc-number">10.4.3.3.</span> <span class="toc-text">RL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lr"><span class="toc-number">10.4.3.4.</span> <span class="toc-text">LR</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4"><span class="toc-number">10.4.4.</span> <span class="toc-text">元素删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">11.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">11.1.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">11.1.1.</span> <span class="toc-text">有向图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-number">11.1.2.</span> <span class="toc-text">无向图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%9B%BE"><span class="toc-number">11.1.3.</span> <span class="toc-text">完全图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%9D%83%E5%9B%BE"><span class="toc-number">11.1.4.</span> <span class="toc-text">带权图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%9B%BE"><span class="toc-number">11.1.5.</span> <span class="toc-text">子图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9A%84%E5%BA%A6"><span class="toc-number">11.1.6.</span> <span class="toc-text">顶点的度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84-1"><span class="toc-number">11.1.7.</span> <span class="toc-text">路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%B7%AF%E5%BE%84"><span class="toc-number">11.1.8.</span> <span class="toc-text">简单路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B7%AF"><span class="toc-number">11.1.9.</span> <span class="toc-text">回路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%92%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">11.1.10.</span> <span class="toc-text">连通图和连通分量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%92%8C%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">11.1.11.</span> <span class="toc-text">强连通图和强连通分量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">11.1.12.</span> <span class="toc-text">生成树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">11.2.</span> <span class="toc-text">图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">11.2.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">11.2.2.</span> <span class="toc-text">邻接表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE-1"><span class="toc-number">11.2.2.1.</span> <span class="toc-text">无向图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE-1"><span class="toc-number">11.2.2.2.</span> <span class="toc-text">有向图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E6%9D%83%E5%9B%BE-1"><span class="toc-number">11.2.2.3.</span> <span class="toc-text">带权图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">11.2.3.</span> <span class="toc-text">邻接矩阵和邻接表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">11.3.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">11.3.1.</span> <span class="toc-text">深度优先搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">11.3.2.</span> <span class="toc-text">广度优先搜索</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">11.4.</span> <span class="toc-text">最短路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">11.5.</span> <span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95"><span class="toc-number">11.6.</span> <span class="toc-text">最小生成树算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#prime%E7%AE%97%E6%B3%95"><span class="toc-number">11.6.1.</span> <span class="toc-text">Prime算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">11.6.2.</span> <span class="toc-text">Kruskal算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E8%BE%B9%E8%A1%A8%E7%A4%BA%E6%B4%BB%E5%8A%A8%E7%9A%84%E7%BD%91%E7%BB%9Caov%E7%BD%91%E7%BB%9C"><span class="toc-number">11.7.</span> <span class="toc-text">用边表示活动的网络（AOV网络）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#aov%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5"><span class="toc-number">11.7.1.</span> <span class="toc-text">AOV网络概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%9C%89%E5%90%91%E7%8E%AF%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">11.7.2.</span> <span class="toc-text">检测有向环：拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.7.3.</span> <span class="toc-text">拓扑排序实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E9%A1%B6%E7%82%B9%E8%A1%A8%E7%A4%BA%E6%B4%BB%E5%8A%A8%E7%9A%84%E7%BD%91%E7%BB%9Caoe%E7%BD%91%E7%BB%9C"><span class="toc-number">11.8.</span> <span class="toc-text">用顶点表示活动的网络（AOE网络）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#aoe%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5"><span class="toc-number">11.8.1.</span> <span class="toc-text">AOE网络概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8%E6%9C%89%E5%85%B3%E7%9A%84%E9%87%8F"><span class="toc-number">11.8.2.</span> <span class="toc-text">与关键活动有关的量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97"><span class="toc-number">11.8.3.</span> <span class="toc-text">计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">12.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-3"><span class="toc-number">12.1.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">12.1.1.</span> <span class="toc-text">排序算法稳定性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%A4%96%E6%8E%92%E5%BA%8F"><span class="toc-number">12.1.2.</span> <span class="toc-text">内排序与外排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">12.2.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">12.2.1.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">12.2.2.</span> <span class="toc-text">直接插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">12.2.3.</span> <span class="toc-text">折半插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">12.2.4.</span> <span class="toc-text">希尔排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">12.3.</span> <span class="toc-text">交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-1"><span class="toc-number">12.3.1.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">12.3.2.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">12.3.3.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">12.4.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-2"><span class="toc-number">12.4.1.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">12.4.2.</span> <span class="toc-text">直接选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">12.4.3.</span> <span class="toc-text">堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">12.5.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-3"><span class="toc-number">12.5.1.</span> <span class="toc-text">基本思想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">12.6.</span> <span class="toc-text">基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-4"><span class="toc-number">12.6.1.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%AB%98%E4%BD%8D%E4%BC%98%E5%85%88msd"><span class="toc-number">12.6.2.</span> <span class="toc-text">最高位优先(MSD)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%8E%E4%BD%8D%E4%BC%98%E5%85%88lsd"><span class="toc-number">12.6.3.</span> <span class="toc-text">最低位优先(LSD)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">12.7.</span> <span class="toc-text">排序对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%80%83%E5%90%8E%E6%80%BB%E7%BB%93"><span class="toc-number">13.</span> <span class="toc-text">考后总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">14.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/09/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%B0%E5%BD%95/" title="蓝桥杯记录">蓝桥杯记录</a><time datetime="2023-04-09T02:09:34.000Z" title="发表于 2023-04-09 10:09:34">2023-04-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/19/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/CUDA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="CUDA学习记录">CUDA学习记录</a><time datetime="2023-03-19T02:21:27.000Z" title="发表于 2023-03-19 10:21:27">2023-03-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/16/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="操作系统复习整理">操作系统复习整理</a><time datetime="2023-02-16T13:39:58.000Z" title="发表于 2023-02-16 21:39:58">2023-02-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/16/Hexo%E5%8D%9A%E5%AE%A2LaTeX%E5%85%AC%E5%BC%8F%E7%9A%84%E6%98%BE%E7%A4%BA/" title="Hexo博客LaTeX公式的显示">Hexo博客LaTeX公式的显示</a><time datetime="2023-02-16T05:14:16.000Z" title="发表于 2023-02-16 13:14:16">2023-02-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/14/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="数据结构复习整理">数据结构复习整理</a><time datetime="2023-02-14T12:12:43.000Z" title="发表于 2023-02-14 20:12:43">2023-02-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By WinkySpeed</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2d-widget/autoload.js"></script></body></html>